<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go mod 私有仓库搭建</title>
      <link href="/2019/11/01/go-mod-goproxy/"/>
      <url>/2019/11/01/go-mod-goproxy/</url>
      
        <content type="html"><![CDATA[<h1 id="Go-包管理"><a href="#Go-包管理" class="headerlink" title="Go 包管理"></a>Go 包管理</h1><ol><li><code>godep</code></li><li><code>govendor</code></li></ol><p>都有各自的优缺点,本次着重介绍go mod</p><h1 id="Go-mod-使用"><a href="#Go-mod-使用" class="headerlink" title="Go mod 使用"></a>Go mod 使用</h1><p><code>go modules</code>是 golang 1.11 新加的特性。现在1.12 已经发布了，是时候用起来了。Modules官方定义为：</p><p>   模块是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。</p><p>Go mod 通过git获取github上项目资源，针对一些企业级项目很多情况下一些内部的SDK,TOOLS面临着无法直接require</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h2 id="利用-replace"><a href="#利用-replace" class="headerlink" title="利用 replace"></a>利用 replace</h2><ol><li>把需要引用的SDK导入到项目中，vendor或者其他目录</li><li>go.mod require gitlab.xxx.com/csi/common v0.0.0</li><li>go.mod replace gitlab.xxx.com/csi/common v0.0.0 -&gt; ./vendor/itlab.xxx.com/csi/common</li></ol><p>主要是利用gomod replace功能把本地文件引用进去，类似于java的maven导入本地jar包<br>不足： 多个项目需要重复执行</p><h1 id="goproxy利器"><a href="#goproxy利器" class="headerlink" title="goproxy利器"></a>goproxy利器</h1><p>开源项目<a href="https://github.com/goproxyio/goproxy" target="_blank" rel="noopener">https://github.com/goproxyio/goproxy</a></p><pre><code>                                         direct                      +----------------------------------&gt; private repo                      |                 match|pattern                      |                  +---+---+           +----------+go get  +-------&gt; |goproxy| +-------&gt; |goproxy.io| +---&gt; golang.org/x/net                  +-------+           +----------+                 router mode           proxy mode</code></pre><h2 id="搭建内网goproxy"><a href="#搭建内网goproxy" class="headerlink" title="搭建内网goproxy"></a>搭建内网goproxy</h2><h3 id="比较重要的2个参数"><a href="#比较重要的2个参数" class="headerlink" title="比较重要的2个参数"></a>比较重要的2个参数</h3><ol><li>proxy <a href="https://goproxy.io" target="_blank" rel="noopener">https://goproxy.io</a>  可以在配置一个goproxy可以用来获取被墙的package</li><li>exclude gitlab.*.com 将 <code>direct</code>走内网服务</li></ol><h3 id="发现代理gitlab还有些不足"><a href="#发现代理gitlab还有些不足" class="headerlink" title="发现代理gitlab还有些不足"></a>发现代理gitlab还有些不足</h3><p>我们需要在这个container配置gitlab <code>~/.ssh/id_rsa.pub</code><br>还有一个重要的配置就是git</p><h3 id="目的是将所有https转换出ssh"><a href="#目的是将所有https转换出ssh" class="headerlink" title="目的是将所有https转换出ssh"></a>目的是将所有https转换出ssh</h3><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --global url.git@gitlab.xxxx.com:.insteadOf https://gitlab.xxxx.com/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="goproxy-修改"><a href="#goproxy-修改" class="headerlink" title="goproxy 修改"></a>goproxy 修改</h3><p>goproxy默认不支持 ssh</p><p>只需要修改dockerfile即可</p><p><a href="https://github.com/goproxyio/goproxy/blob/master/Dockerfile#L12" target="_blank" rel="noopener">https://github.com/goproxyio/goproxy/blob/master/Dockerfile#L12</a></p><pre><code>FROM golang:alpine AS buildRUN apk add --no-cache -U make git mercurial subversion bzr fossilCOPY . /src/goproxyRUN cd /src/goproxy &amp;&amp;\    export CGO_ENABLED=0 &amp;&amp;\    makeFROM golang:alpineRUN apk add --no-cache -U git mercurial subversion bzr fossil openssh-client #加入openssh-clientCOPY --from=build /src/goproxy/bin/goproxy /goproxyVOLUME /goEXPOSE 8081ENTRYPOINT [&quot;/goproxy&quot;]CMD []</code></pre><h3 id="重新编译"><a href="#重新编译" class="headerlink" title="重新编译"></a>重新编译</h3><p>docker build -t registry.cn-hangzhou.aliyuncs.com/bamboo/goproxy:1.0  .</p><h3 id="启动goproxy"><a href="#启动goproxy" class="headerlink" title="启动goproxy"></a>启动goproxy</h3><pre><code>docker run -d -p80:8081 -v /root/.ssh/:/root/.ssh \ registry.cn-hangzhou.aliyuncs.com/bamboo/goproxy:1.0  \ -proxy https://goproxy.io  -exclude &quot;gitlab.*.com&quot;</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>go get -u -v gitlab.xxx.com/csi/common</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Q: goprpxy无法代理gitlab<br>A: 进入容器内部执行</p><pre><code>go env -w GOPROXY=https://goproxy.cn,directgo env -w GOPRIVATE=gitlab.*.com</code></pre><p>Q: goprpxy还是不能获取被墙的package<br>A: 检查go env</p><pre><code>$ echo $GOPROXYhttps://goproxy.io$ echo $GO111MODULEon不符合就 export 设置一下</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul><li><a href="https://segmentfault.com/a/1190000018536993" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018536993</a></li><li><a href="https://github.com/golang/go/wiki/Modules" target="_blank" rel="noopener">https://github.com/golang/go/wiki/Modules</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> go,proxy,gomod,gitlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S日志库源码分析：klog</title>
      <link href="/2019/10/01/k8s-klog/"/>
      <url>/2019/10/01/k8s-klog/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/kubernetes/klog/" target="_blank" rel="noopener">klog</a>是著名google开源C++日志库<a href="https://github.com/google/glog" target="_blank" rel="noopener">glog</a>的golang版本，具有轻量级、简单、稳定和高效等特性</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>主要有以下特点：</p><ul><li>支持四种日志等级INFO &lt; WARING &lt; ERROR &lt; FATAL，不支持DEBUG等级。</li><li>每个日志等级对应一个日志文件，低等级的日志文件中除了包含该等级的日志，还会包含高等级的日志。</li><li>日志文件可以根据大小切割，但是不能根据日期切割。</li><li>日志文件名称格式：program.host.userName.log.log_level.date-time.pid，不可自定义。</li><li>固定日志输出格式：Lmmdd hh:mm:ss.uuuuuu threadid file:line] msg…，不可自定义。</li><li>程序开始时必须调用flag.Parse()解析命令行参数，退出时必须调用glog.Flush()确保将缓存区日志输出。</li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Example：</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"flag"</span>    <span class="token string">"fmt"</span>    <span class="token string">"os"</span>    <span class="token string">"k8s.io/klog"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    klog<span class="token punctuation">.</span><span class="token function">InitFlags</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//Init the command-line flags.</span>    flag<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Will be ignored as the program has exited in Fatal().</span>    <span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Message in defer"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Flushes all pending log I/O.</span>    <span class="token keyword">defer</span> klog<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// The temp folder for log files when --log_dir is not set.</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Temp folder for log files: %s\n"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span><span class="token function">TempDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    klog<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"Info"</span><span class="token punctuation">)</span>    klog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"L1 info"</span><span class="token punctuation">)</span>    klog<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">)</span>    klog<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span><span class="token string">"Fatal"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Will be ignored as the program has exited in Fatal().</span>    klog<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">"Error after Fatal"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Output</p><pre class="line-numbers language-shell"><code class="language-shell">$ go run klog.go  -logtostderr=false                                                                                                                                                                                                                      1 ↵Temp folder for log files: /tmpE1030 15:13:03.257539    5821 klog.go:30] ErrorF1030 15:13:03.257736    5821 klog.go:31] Fatalgoroutine 1 [running]:k8s.io/klog.stacks(0xc00008c200, 0xc0000d2000, 0x30, 0x40)        /home/bamboo/test/go/pkg/mod/k8s.io/klog@v1.0.0/klog.go:875 +0xb8k8s.io/klog.(*loggingT).output(0x5b5fc0, 0xc000000003, 0xc0000c4000, 0x59c9eb, 0x7, 0x1f, 0x0)        /home/bamboo/test/go/pkg/mod/k8s.io/klog@v1.0.0/klog.go:826 +0x330k8s.io/klog.(*loggingT).printDepth(0x5b5fc0, 0xc000000003, 0x1, 0xc0000cbf00, 0x1, 0x1)        /home/bamboo/test/go/pkg/mod/k8s.io/klog@v1.0.0/klog.go:698 +0x129k8s.io/klog.(*loggingT).print(...)        /home/bamboo/test/go/pkg/mod/k8s.io/klog@v1.0.0/klog.go:689k8s.io/klog.Fatal(...)        /home/bamboo/test/go/pkg/mod/k8s.io/klog@v1.0.0/klog.go:1256main.main()        /home/bamboo/test/go/src/bamboo/test/klog.go:31 +0x326exit status 255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Usage</p><pre class="line-numbers language-shell"><code class="language-shell"> $ go run klog.go -h                                                                                                                                                                                                                                       1 ↵Usage of /tmp/go-build023011031/b001/exe/klog:  -add_dir_header        If true, adds the file directory to the header 如果为true，则将文件目录添加到标题中  -alsologtostderr         log to standard error as well as files  同时输出到os.Stderr和log files   -log_backtrace_at value         when logging hits line file:N, emit a stack trace 当日志长度超过定义的行数时，忽略堆栈信息。  -log_dir string        If non-empty, write log files in this directory  指定log files的目录，默认是os.TempDir()   -log_file string         If non-empty, use this log file 指定log files的文件名，如果是空安排日志级别分别创建日志文件，并且创建软连  -log_file_max_size uint          Defines the maximum size a log file can grow to. Unit is megabytes. If the value is 0, the maximum file size is unlimited. (default 1800) 日志文件大小单位MB  -logtostderr        log to standard error instead of files (default true) 输出日志到标准错误控制台，不输出到文件。  -skip_headers        If true, avoid header prefixes in the log messages 如果为true，请在日志消息中避免标题前缀  -skip_log_headers        If true, avoid headers when opening log files 如果为true，则在打开日志文件时避免标题  -stderrthreshold value         logs at or above this threshold go to stderr (default 2)  大于等于该severity的log，会输出到os.Stderr   -v value         number for the log level verbosity  设置vLog的等级   -vmodule value        comma-separated list of pattern=N settings for file-filtered logging 定输出日志的模块，格式如下：pattern=N，使用逗号分隔。exit status 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Log files输出到默认的临时目录（/tmp）下。在标准输出上只能看到Info Error和Fatal log，是因为默认的<code>--v</code>为0。</p><p>需要注意的是， <code>-logtostderr=true</code> 调用glog.Fatal(“Fatal”)，程序会输出所有goroutine的堆栈信息，然后调用os.Exit()退出程序。所以，其前面的defer代码以及后面的代码，都不会执行。</p><h1 id="日志输出到文件配置："><a href="#日志输出到文件配置：" class="headerlink" title="日志输出到文件配置："></a>日志输出到文件配置：</h1><pre class="line-numbers language-shell"><code class="language-shell">- --v=5- --logtostderr=false- --log_dir=/xxx/xxx- --log_file=/xx/xx/xx.log- --stderrthreshold=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>klog的代码非常简单，总共代码行数1.4K左右，分两个文件： <code>klog_file.go</code> <code>klog.go</code></p><ul><li>klog.go：主要实现log等级定义、输出以及vlog。</li><li>klog_file.go：主要实现日志文件目录和各等级日志文件的创建。</li></ul><h2 id="Log-Levels-Definition"><a href="#Log-Levels-Definition" class="headerlink" title="Log Levels Definition"></a>Log Levels Definition</h2><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// severity identifies the sort of log: info, warning etc. It also implements</span><span class="token comment" spellcheck="true">// the flag.Value interface. The -stderrthreshold flag is of type severity and</span><span class="token comment" spellcheck="true">// should be modified only through the flag.Value interface. The values match</span><span class="token comment" spellcheck="true">// the corresponding constants in C++.</span><span class="token keyword">type</span> severity <span class="token builtin">int32</span> <span class="token comment" spellcheck="true">// sync/atomic int32</span><span class="token comment" spellcheck="true">// These constants identify the log levels in order of increasing severity.</span><span class="token comment" spellcheck="true">// A message written to a high-severity log file is also written to each</span><span class="token comment" spellcheck="true">// lower-severity log file.</span><span class="token keyword">const</span> <span class="token punctuation">(</span>    infoLog severity <span class="token operator">=</span> <span class="token boolean">iota</span>    warningLog    errorLog    fatalLog    numSeverity <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">const</span> severityChar <span class="token operator">=</span> <span class="token string">"IWEF"</span><span class="token keyword">var</span> severityName <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>    infoLog<span class="token punctuation">:</span>    <span class="token string">"INFO"</span><span class="token punctuation">,</span>    warningLog<span class="token punctuation">:</span> <span class="token string">"WARNING"</span><span class="token punctuation">,</span>    errorLog<span class="token punctuation">:</span>   <span class="token string">"ERROR"</span><span class="token punctuation">,</span>    fatalLog<span class="token punctuation">:</span>   <span class="token string">"FATAL"</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Flush-Daemon"><a href="#Flush-Daemon" class="headerlink" title="Flush Daemon"></a>Flush Daemon</h2><p>klog在初始化的时候，会定义一些命令行参数，同时启动flush守护进程。Flush守护进程会间隔5s周期性地flush缓冲区中的log。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">const</span> flushInterval <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token comment" spellcheck="true">// flushDaemon periodically flushes the log file buffers.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>loggingT<span class="token punctuation">)</span> <span class="token function">flushDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token keyword">range</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>flushInterval<span class="token punctuation">)</span><span class="token punctuation">.</span>C <span class="token punctuation">{</span>        l<span class="token punctuation">.</span><span class="token function">lockAndFlushAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Log输出原理"><a href="#Log输出原理" class="headerlink" title="Log输出原理"></a>Log输出原理</h2><p>所有的log都支持多种输出模式，例如，Info<a href="">f|ln|Depth</a>，最终都是调用output()来输出到log files或者Stderr。</p><p><code>Info()</code>与<code>Infoln()</code>没有区别，因为glog为了保证每行只有一条log记录，会主动check末尾是否有换行符，如果没有的话，会自动加上。 <code>InfoDepth()</code>提供的<code>depth</code>参数，用来指定log信息中source file number来自的堆栈的深度。当<code>depth</code>为0时，就等价于<code>Info()</code>。 由于<code>depth</code>的设置很难有一个明确的参考标准，因此<code>InfoDepth()</code>不常用。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>loggingT<span class="token punctuation">)</span> <span class="token function">println</span><span class="token punctuation">(</span>s severity<span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    buf<span class="token punctuation">,</span> file<span class="token punctuation">,</span> line <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintln</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>    l<span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> file<span class="token punctuation">,</span> line<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>loggingT<span class="token punctuation">)</span> <span class="token function">print</span><span class="token punctuation">(</span>s severity<span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    l<span class="token punctuation">.</span><span class="token function">printDepth</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>loggingT<span class="token punctuation">)</span> <span class="token function">printDepth</span><span class="token punctuation">(</span>s severity<span class="token punctuation">,</span> depth <span class="token builtin">int</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    buf<span class="token punctuation">,</span> file<span class="token punctuation">,</span> line <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> depth<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprint</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> buf<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>buf<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\n'</span> <span class="token punctuation">{</span>        buf<span class="token punctuation">.</span><span class="token function">WriteByte</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    l<span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> file<span class="token punctuation">,</span> line<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>loggingT<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span>s severity<span class="token punctuation">,</span> format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    buf<span class="token punctuation">,</span> file<span class="token punctuation">,</span> line <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> buf<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>buf<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token string">'\n'</span> <span class="token punctuation">{</span>        buf<span class="token punctuation">.</span><span class="token function">WriteByte</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    l<span class="token punctuation">.</span><span class="token function">output</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> file<span class="token punctuation">,</span> line<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">...</span><span class="token operator">...</span><span class="token comment" spellcheck="true">// Info logs to the INFO log.</span><span class="token comment" spellcheck="true">// Arguments are handled in the manner of fmt.Print; a newline is appended if missing.</span><span class="token keyword">func</span> <span class="token function">Info</span><span class="token punctuation">(</span>args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logging<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>infoLog<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// InfoDepth acts as Info but uses depth to determine which call frame to log.</span><span class="token comment" spellcheck="true">// InfoDepth(0, "msg") is the same as Info("msg").</span><span class="token keyword">func</span> <span class="token function">InfoDepth</span><span class="token punctuation">(</span>depth <span class="token builtin">int</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logging<span class="token punctuation">.</span><span class="token function">printDepth</span><span class="token punctuation">(</span>infoLog<span class="token punctuation">,</span> depth<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Infoln logs to the INFO log.</span><span class="token comment" spellcheck="true">// Arguments are handled in the manner of fmt.Println; a newline is appended if missing.</span><span class="token keyword">func</span> <span class="token function">Infoln</span><span class="token punctuation">(</span>args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logging<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>infoLog<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Infof logs to the INFO log.</span><span class="token comment" spellcheck="true">// Arguments are handled in the manner of fmt.Printf; a newline is appended if missing.</span><span class="token keyword">func</span> <span class="token function">Infof</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    logging<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>infoLog<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>output()</code>在输出log的整个过程中都会加锁，以防止写冲突。每次输出log时都会check是否已调用<code>flag.Parse()</code>。  </p><p>如果没有调用就直接将log输出到Stderr，同时在其前面提示ERROR: logging before flag.Parse: 的错误。  </p><p>如果已经调用就会根据命令行参数来决定输出行为：如果设置–toStderr=true，就只会输出到Stderr  </p><p>如果设置<code>--alsoToStderr=true</code>，且输出log level大于或等于<code>--stderrThreshold</code>的话， 输出到log file的同时也会输出到Stderr  </p><p><code>stderrThreshold</code>的默认值是<code>ERROR</code> </p><p>klog还有另外一个很赞的功能就是，遇到Fatal log会在自动退出程序，并在退出前将所有goroutine的堆栈信息输出，方便排错。因此，在程序需要异常退出的时候，直接调用Fatal<a href="">f|ln|Depth</a>，应该成为一种标准做法。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// output writes the data to the log files and releases the buffer.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>l <span class="token operator">*</span>loggingT<span class="token punctuation">)</span> <span class="token function">output</span><span class="token punctuation">(</span>s severity<span class="token punctuation">,</span> buf <span class="token operator">*</span>buffer<span class="token punctuation">,</span> file <span class="token builtin">string</span><span class="token punctuation">,</span> line <span class="token builtin">int</span><span class="token punctuation">,</span> alsoToStderr <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    l<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> l<span class="token punctuation">.</span>traceLocation<span class="token punctuation">.</span><span class="token function">isSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> l<span class="token punctuation">.</span>traceLocation<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> line<span class="token punctuation">)</span> <span class="token punctuation">{</span>            buf<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token function">stacks</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    data <span class="token operator">:=</span> buf<span class="token punctuation">.</span><span class="token function">Bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token operator">!</span>flag<span class="token punctuation">.</span><span class="token function">Parsed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        os<span class="token punctuation">.</span>Stderr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"ERROR: logging before flag.Parse: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        os<span class="token punctuation">.</span>Stderr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> l<span class="token punctuation">.</span>toStderr <span class="token punctuation">{</span>        os<span class="token punctuation">.</span>Stderr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> alsoToStderr <span class="token operator">||</span> l<span class="token punctuation">.</span>alsoToStderr <span class="token operator">||</span> s <span class="token operator">>=</span> l<span class="token punctuation">.</span>stderrThreshold<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            os<span class="token punctuation">.</span>Stderr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> l<span class="token punctuation">.</span>file<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> err <span class="token operator">:=</span> l<span class="token punctuation">.</span><span class="token function">createFiles</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                os<span class="token punctuation">.</span>Stderr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Make sure the message appears somewhere.</span>                l<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">switch</span> s <span class="token punctuation">{</span>        <span class="token keyword">case</span> fatalLog<span class="token punctuation">:</span>            l<span class="token punctuation">.</span>file<span class="token punctuation">[</span>fatalLog<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">fallthrough</span>        <span class="token keyword">case</span> errorLog<span class="token punctuation">:</span>            l<span class="token punctuation">.</span>file<span class="token punctuation">[</span>errorLog<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">fallthrough</span>        <span class="token keyword">case</span> warningLog<span class="token punctuation">:</span>            l<span class="token punctuation">.</span>file<span class="token punctuation">[</span>warningLog<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">fallthrough</span>        <span class="token keyword">case</span> infoLog<span class="token punctuation">:</span>            l<span class="token punctuation">.</span>file<span class="token punctuation">[</span>infoLog<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> s <span class="token operator">==</span> fatalLog <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// If we got here via Exit rather than Fatal, print no stacks.</span>        <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadUint32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fatalNoStacks<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>            l<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token function">timeoutFlush</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>            os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Dump all goroutine stacks before exiting.</span>        <span class="token comment" spellcheck="true">// First, make sure we see the trace for the current goroutine on standard error.</span>        <span class="token comment" spellcheck="true">// If -logtostderr has been specified, the loop below will do that anyway</span>        <span class="token comment" spellcheck="true">// as the first stack in the full dump.</span>        <span class="token keyword">if</span> <span class="token operator">!</span>l<span class="token punctuation">.</span>toStderr <span class="token punctuation">{</span>            os<span class="token punctuation">.</span>Stderr<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token function">stacks</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Write the stack trace for all goroutines to the files.</span>        trace <span class="token operator">:=</span> <span class="token function">stacks</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>        logExitFunc <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// If we get a write error, we'll still exit below.</span>        <span class="token keyword">for</span> log <span class="token operator">:=</span> fatalLog<span class="token punctuation">;</span> log <span class="token operator">>=</span> infoLog<span class="token punctuation">;</span> log<span class="token operator">--</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> f <span class="token operator">:=</span> l<span class="token punctuation">.</span>file<span class="token punctuation">[</span>log<span class="token punctuation">]</span><span class="token punctuation">;</span> f <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Can be nil if -logtostderr is set.</span>                f<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span>trace<span class="token punctuation">)</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        l<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token function">timeoutFlush</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        os<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// C++ uses -1, which is silly because it's anded with 255 anyway.</span>    <span class="token punctuation">}</span>    l<span class="token punctuation">.</span><span class="token function">putBuffer</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span>    l<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> stats <span class="token operator">:=</span> severityStats<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token punctuation">;</span> stats <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stats<span class="token punctuation">.</span>lines<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>stats<span class="token punctuation">.</span>bytes<span class="token punctuation">,</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vLog"><a href="#vLog" class="headerlink" title="vLog"></a>vLog</h2><p>vLog是用户自定义的log级别，与glog自带的log级别完全独立，使log等级控制更加丰富，灵活。 不过只提供<code>Info()</code>，<code>Infof()</code>和<code>Infoln()</code>三个方法，因此只能对infoLog进行更细粒度的等级划分，可以认为是补充DEBUG等级。</p><p>使用方法很简单，有如下两种等价形式。虽然第二种简短，不过第一种代价更低。</p><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">if</span> glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    glog<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"log this"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Equals</span>glog<span class="token punctuation">.</span><span class="token function">V</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"log this"</span><span class="token punctuation">)</span><span class="token string">``</span>vLog的实现原理也很简单：<span class="token string">``</span>`<span class="token keyword">go</span><span class="token operator">/</span> Verbose is a boolean <span class="token keyword">type</span> that implements <span class="token function">Infof</span> <span class="token punctuation">(</span>like Printf<span class="token punctuation">)</span> etc<span class="token punctuation">.</span><span class="token comment" spellcheck="true">// See the documentation of V for more information.</span><span class="token keyword">type</span> Verbose <span class="token builtin">bool</span><span class="token keyword">func</span> <span class="token function">V</span><span class="token punctuation">(</span>level Level<span class="token punctuation">)</span> Verbose <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Here is a cheap but safe test to see if V logging is enabled globally.</span>    <span class="token keyword">if</span> logging<span class="token punctuation">.</span>verbosity<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> level <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">Verbose</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> atomic<span class="token punctuation">.</span><span class="token function">LoadInt32</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>logging<span class="token punctuation">.</span>filterLength<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        logging<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">defer</span> logging<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> runtime<span class="token punctuation">.</span><span class="token function">Callers</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> logging<span class="token punctuation">.</span>pcs<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">Verbose</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> logging<span class="token punctuation">.</span>vmap<span class="token punctuation">[</span>logging<span class="token punctuation">.</span>pcs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>            v <span class="token operator">=</span> logging<span class="token punctuation">.</span><span class="token function">setV</span><span class="token punctuation">(</span>logging<span class="token punctuation">.</span>pcs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">Verbose</span><span class="token punctuation">(</span>v <span class="token operator">>=</span> level<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">Verbose</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Info is equivalent to the global Info function, guarded by the value of v.</span><span class="token comment" spellcheck="true">// See the documentation of V for usage.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>v Verbose<span class="token punctuation">)</span> <span class="token function">Info</span><span class="token punctuation">(</span>args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> v <span class="token punctuation">{</span>        logging<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>infoLog<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Infoln is equivalent to the global Infoln function, guarded by the value of v.</span><span class="token comment" spellcheck="true">// See the documentation of V for usage.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>v Verbose<span class="token punctuation">)</span> <span class="token function">Infoln</span><span class="token punctuation">(</span>args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> v <span class="token punctuation">{</span>        logging<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>infoLog<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Infof is equivalent to the global Infof function, guarded by the value of v.</span><span class="token comment" spellcheck="true">// See the documentation of V for usage.</span><span class="token keyword">func</span> <span class="token punctuation">(</span>v Verbose<span class="token punctuation">)</span> <span class="token function">Infof</span><span class="token punctuation">(</span>format <span class="token builtin">string</span><span class="token punctuation">,</span> args <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> v <span class="token punctuation">{</span>        logging<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span>infoLog<span class="token punctuation">,</span> format<span class="token punctuation">,</span> args<span class="token operator">...</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="flag-Parse-问题"><a href="#flag-Parse-问题" class="headerlink" title="flag.Parse()问题"></a>flag.Parse()问题</h1><p>在引用klog的同事千万注意不能在引用glog，不然启动的时候会出错</p><pre class="line-numbers language-shell"><code class="language-shell">panic: /tmp/___go_build_klog_go flag redefined: log_dir<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> kubernetes,klog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s-csi 版本变化</title>
      <link href="/2019/08/03/k8s-15-cun-chu-04/"/>
      <url>/2019/08/03/k8s-15-cun-chu-04/</url>
      
        <content type="html"><![CDATA[<h1 id="kubernetes-csi-版本变化"><a href="#kubernetes-csi-版本变化" class="headerlink" title="kubernetes-csi 版本变化"></a>kubernetes-csi 版本变化</h1><p><a href="https://kubernetes-csi.github.io/docs/introduction.html" target="_blank" rel="noopener">原文链接</a></p><h2 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h2><p><a href="https://github.com/container-storage-interface/spec/blob/master/lib/go/csi/csi.pb.go" target="_blank" rel="noopener">grpc pb</a></p><h2 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a>changelog</h2><h3 id="Kubernetes-1-15"><a href="#Kubernetes-1-15" class="headerlink" title="Kubernetes 1.15"></a>Kubernetes 1.15</h3><ul><li>New features:<ul><li>Volume capacity usage metrics</li></ul></li><li>New alpha features:<ul><li>Volume cloning</li><li>Ephemeral local volumes</li><li>Resizing secrets</li></ul></li></ul><h2 id="sidecar-containers"><a href="#sidecar-containers" class="headerlink" title="sidecar-containers"></a>sidecar-containers</h2><h3 id="external-provisioner"><a href="#external-provisioner" class="headerlink" title="external-provisioner"></a>external-provisioner</h3><ul><li>相关源码<ul><li><a href="https://github.com/kubernetes-csi/external-provisioner" target="_blank" rel="noopener">https://github.com/kubernetes-csi/external-provisioner</a></li></ul></li><li>主要接口:<ul><li>ControllerCreateVolume</li><li>ControllerDeleteVolume</li><li>Probe</li><li>GetPluginInfo</li><li>GetPluginCapabilitiesRequest</li><li>ControllerGetCapabilities</li></ul></li></ul><h3 id="external-attacher"><a href="#external-attacher" class="headerlink" title="external-attacher"></a>external-attacher</h3><ul><li>相关源码<ul><li><a href="https://github.com/kubernetes-csi/external-attacher" target="_blank" rel="noopener">https://github.com/kubernetes-csi/external-attacher</a></li></ul></li><li>主要接口:<ul><li>ControllerPublish</li><li>ControllerUnpublish</li><li>Probe</li><li>GetPluginInfo</li><li>GetPluginCapabilitiesRequest</li><li>ControllerGetCapabilities</li></ul></li></ul><h3 id="external-snapshotter"><a href="#external-snapshotter" class="headerlink" title="external-snapshotter"></a>external-snapshotter</h3><p>Volume Snapshot &amp; Restore.</p><ul><li>相关源码<ul><li><a href="https://github.com/kubernetes-csi/external-snapshotter" target="_blank" rel="noopener">https://github.com/kubernetes-csi/external-snapshotter</a></li></ul></li></ul><h3 id="node-driver-registrar"><a href="#node-driver-registrar" class="headerlink" title="node-driver-registrar"></a>node-driver-registrar</h3><ul><li>相关源码<ul><li><a href="https://github.com/kubernetes-csi/node-driver-registrar" target="_blank" rel="noopener">https://github.com/kubernetes-csi/node-driver-registrar</a></li></ul></li></ul><p><del>### cluster-driver-registrar 废弃</del></p><h3 id="livenessprobe"><a href="#livenessprobe" class="headerlink" title="livenessprobe"></a>livenessprobe</h3><ul><li>相关源码<ul><li><a href="https://github.com/kubernetes-csi/livenessprobe" target="_blank" rel="noopener">https://github.com/kubernetes-csi/livenessprobe</a></li></ul></li></ul><h3 id="external-resizer"><a href="#external-resizer" class="headerlink" title="external-resizer"></a>external-resizer</h3><ul><li>相关源码<ul><li><a href="https://github.com/kubernetes-csi/external-resizer/" target="_blank" rel="noopener">https://github.com/kubernetes-csi/external-resizer/</a></li></ul></li></ul><h2 id="相关功能点待补充"><a href="#相关功能点待补充" class="headerlink" title="相关功能点待补充"></a>相关功能点待补充</h2>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> csi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker隔离的缺陷</title>
      <link href="/2019/03/03/docker-03-zi-yuan-ge-chi/"/>
      <url>/2019/03/03/docker-03-zi-yuan-ge-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-里面的-LXCFS-机制"><a href="#Linux-里面的-LXCFS-机制" class="headerlink" title="Linux 里面的 LXCFS 机制"></a>Linux 里面的 LXCFS 机制</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>知道如何修复容器中的 top 指令以及 /proc 文件系统中的信息呢</p><p><a href="https://github.com/fabric8io-images/run-java-sh/blob/master/fish-pepper/run-java-sh/readme.md" target="_blank" rel="noopener">https://github.com/fabric8io-images/run-java-sh/blob/master/fish-pepper/run-java-sh/readme.md</a></p><h2 id="解决docker-run-java"><a href="#解决docker-run-java" class="headerlink" title="解决docker run java"></a>解决docker run java</h2><ol><li><p>-Xmx 设置最大堆大小</p><pre><code>JAVA_OPTIONS=&#39;-Xmx300m&#39;</code></pre></li><li><p>Fabric8</p></li></ol><p><a href="https://github.com/fabric8io-images/run-java-sh/tree/master/fish-pepper/run-java-sh" target="_blank" rel="noopener">https://github.com/fabric8io-images/run-java-sh/tree/master/fish-pepper/run-java-sh</a></p><ul><li>core_limit<pre><code>local cpu_period_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_period_us&quot;local cpu_quota_file=&quot;/sys/fs/cgroup/cpu/cpu.cfs_quota_us&quot;</code></pre></li><li>max_memory<pre><code>local mem_file=&quot;/sys/fs/cgroup/memory/memory.limit_in_bytes&quot;</code></pre></li></ul><p>…..</p><p>echo “-XX:ParallelGCThreads=${core_limit} “ <br>         “-XX:ConcGCThreads=${core_limit} “ <br>         “-Djava.util.concurrent.ForkJoinPool.common.parallelism=${core_limit} “ <br>         “-XX:CICompilerCount=$(ci_compiler_count $core_limit)”</p><pre><code>jvm参数详情[http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html](http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)## 新版JDK对docker容器的支持### cpu limit即如果没有显式指定-XX:ParalllelGCThreads 或者 -XX:CICompilerCount, 那么JVM使用docker的cpu限制。如果docker有指定cpu limit，jvm参数也有指定-XX:ParalllelGCThreads 或者 -XX:CICompilerCount，那么以指定的参数为准。### memory limit在java8u131+及java9，需要加上-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap才能使得Xmx感知docker的memory limit。#### 查看参数默认值java9</code></pre><p>java -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+PrintFlagsFinal<br>bool UseCGroupMemoryLimitForHeap              = false                               {experimental} {default}</p><pre><code>可以看到在java9，UseCGroupMemoryLimitForHeap参数还是实验性的，默认关闭。|参数/版本 |XX:+UseCGroupMemoryLimitForHeap|XX:ActiveProcessorCount|XX:+UseContainerSupport|    |---------|-------|--------|--------||java9    |experimental，默认false|    |无|    无||java10    |experimental，默认false|    |-1    |无||java11    |移除    |-1|    product，默认true|# LXCFS简介社区中常见的做法是利用 lxcfs来提供容器中的资源可见性。lxcfs 是一个开源的FUSE（用户态文件系统）实现来支持LXC容器，它也可以支持Docker容器。LXCFS通过用户态文件系统，在容器中提供下列 procfs 的文件。</code></pre><p>/proc/cpuinfo<br>/proc/diskstats<br>/proc/meminfo<br>/proc/stat<br>/proc/swaps<br>/proc/uptime</p><pre><code>比如，把宿主机的 /var/lib/lxcfs/proc/memoinfo 文件挂载到Docker容器的/proc/meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制。从而使得应用获得正确的资源约束设定。## 测试安装 lxcfs 的RPM包</code></pre><p>wget <a href="https://copr-be.cloud.fedoraproject.org/results/ganto/lxd/epel-7-x86_64/00486278-lxcfs/lxcfs-2.0.5-3.el7.centos.x86_64.rpm" target="_blank" rel="noopener">https://copr-be.cloud.fedoraproject.org/results/ganto/lxd/epel-7-x86_64/00486278-lxcfs/lxcfs-2.0.5-3.el7.centos.x86_64.rpm</a><br>yum install lxcfs-2.0.5-3.el7.centos.x86_64.rpm  </p><pre><code>启动 lxcfs</code></pre><p>lxcfs /var/lib/lxcfs &amp;  </p><pre><code>测试</code></pre><p>$docker run -it -m 256m <br>      -v /var/lib/lxcfs/proc/cpuinfo:/proc/cpuinfo:rw <br>      -v /var/lib/lxcfs/proc/diskstats:/proc/diskstats:rw <br>      -v /var/lib/lxcfs/proc/meminfo:/proc/meminfo:rw <br>      -v /var/lib/lxcfs/proc/stat:/proc/stat:rw <br>      -v /var/lib/lxcfs/proc/swaps:/proc/swaps:rw <br>      -v /var/lib/lxcfs/proc/uptime:/proc/uptime:rw <br>      ubuntu:16.04 /bin/bash</p><p>root@f4a2a01e61cd:/# free<br>              total        used        free      shared  buff/cache   available<br>Mem:         262144         708      261436        2364           0      261436<br>Swap:             0           0           0</p><pre><code>我们可以看到total的内存为256MB，配置已经生效。## K8s如何注入K8s 最小单元是pod一个pod 包含多个container思路：一个init container处理 lxcfs隔离一个业务container如果解决部署问题：0. 通过: Kubernetes提供了 Initializer 扩展机制，自动添加lxcfs container 1. 通过: MutatingAdmissionWebhookdemo：shttps://juejin.im/post/5ba3547ae51d450e425ec6a52. 或者： podpreset 就是一个预设一个pod模版然后提交pod 填充模版的的数据### demo</code></pre><p>apiVersion: settings.k8s.io/v1alpha1<br>kind: PodPreset<br>metadata:<br>  name: allow-database<br>spec:<br>  selector:<br>    matchLabels:<br>      role: frontend<br>  env:<br>    - name: DB_PORT<br>      value: “6379”<br>  volumeMounts:<br>    - mountPath: /cache<br>      name: cache-volume<br>  volumes:<br>    - name: cache-volume<br>      emptyDir: {}</p><pre><code></code></pre><p>apiVersion: v1<br>kind: Pod<br>metadata:<br>  name: website<br>  labels:<br>    app: website<br>    role: frontend<br>spec:<br>  containers:<br>    - name: website<br>      image: nginx<br>      ports:<br>        - containerPort: 80</p><pre><code>最后：</code></pre><p>apiVersion: settings.k8s.io/v1alpha1<br>kind: PodPreset<br>metadata:<br>  name: allow-database<br>spec:<br>  selector:<br>    matchLabels:<br>      role: frontend<br>  env:<br>    - name: DB_PORT<br>      value: “6379”<br>  volumeMounts:<br>    - mountPath: /cache<br>      name: cache-volume<br>  volumes:<br>    - name: cache-volume<br>      emptyDir: {}</p><p>```</p><p>详细 <a href="https://kubernetes.io/docs/concepts/workloads/pods/podpreset/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/pods/podpreset/</a></p><p><a href="https://yq.aliyun.com/articles/566208?spm=a2c4e.11153959.blogcont566208.18.3fb44193UJVlwG" target="_blank" rel="noopener">https://yq.aliyun.com/articles/566208?spm=a2c4e.11153959.blogcont566208.18.3fb44193UJVlwG</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cgroup</title>
      <link href="/2019/03/02/docker-02-zi-yuan-ge-chi/"/>
      <url>/2019/03/02/docker-02-zi-yuan-ge-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-里面的-Cgroup-机制"><a href="#Linux-里面的-Cgroup-机制" class="headerlink" title="Linux 里面的 Cgroup 机制"></a>Linux 里面的 Cgroup 机制</h1><p>cgroup和namespace类似，也是将进程进行分组，但它的目的和namespace不一样，namespace是为了隔离进程组之间的资源，而cgroup是为了对一组进程进行统一的资源监控和限制。</p><p>cgroup分v1和v2两个版本，v1实现较早，功能比较多，但是由于它里面的功能都是零零散散的实现的，所以规划的不是很好，导致了一些使用和维护上的不便，v2的出现就是为了解决v1中这方面的问题，在最新的4.5内核中，cgroup v2声称已经可以用于生产环境了，但它所支持的功能还很有限，随着v2一起引入内核的还有cgroup namespace。v1和v2可以混合使用，但是这样会更复杂，所以一般没人会这样用。</p><h1 id="Cgroup-意义"><a href="#Cgroup-意义" class="headerlink" title="Cgroup 意义"></a>Cgroup 意义</h1><p>在Linux里，一直以来就有对进程进行分组的概念和需求，比如session group， progress group等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和IO使用情况等，于是出现了cgroup，用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理等。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><pre><code>$ cat /proc/cgroups#subsys_name    hierarchy    num_cgroups    enabledcpuset    7    1    1cpu    3    70    1cpuacct    3    70    1blkio    10    70    1memory    2    112    1devices    8    70    1freezer    5    1    1net_cls    11    1    1perf_event    9    1    1net_prio    11    1    1hugetlb    4    1    1pids    6    71    1</code></pre><p>从左到右，字段的含义分别是：</p><ol><li>subsystem的名字</li><li>subsystem所关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么他们的这个字段将一样，比如这里的cpu和cpuacct就一样，表示他们绑定到了同一颗树。如果出现下面的情况，这个字段将为0：</li></ol><ul><li>当前subsystem没有和任何cgroup树绑定</li><li>当前subsystem已经和cgroup v2的树绑定</li><li>当前subsystem没有被内核开启</li></ul><ol start="3"><li>subsystem所关联的cgroup树中进程组的个数，也即树上节点的个数</li><li>1表示开启，0表示没有被开启(可以通过设置内核的启动参数“cgroup_disable”来控制subsystem的开启).</li></ol><h1 id="如何使用cgroup"><a href="#如何使用cgroup" class="headerlink" title="如何使用cgroup"></a>如何使用cgroup</h1><p>利用cgroup </p><h2 id="创建子cgroup"><a href="#创建子cgroup" class="headerlink" title="创建子cgroup"></a>创建子cgroup</h2><p>在ubuntu下，systemd已经帮我们mount好了cpu子系统，我们只需要在相应的目录下创建子目录就可以了</p><pre><code>#从这里的输出可以看到，cpuset被挂载在了/sys/fs/cgroup/cpuset，#而cpu和cpuacct一起挂载到了/sys/fs/cgroup/cpu,cpuacct下面dev@ubuntu:~$ mount|grep cpucgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)#进入/sys/fs/cgroup/cpu,cpuacct并创建子cgroupdev@ubuntu:~$ cd /sys/fs/cgroup/cpu,cpuacctdev@ubuntu:/sys/fs/cgroup/cpu,cpuacct$ sudo mkdir testdev@ubuntu:/sys/fs/cgroup/cpu,cpuacct$ cd testdev@ubuntu:/sys/fs/cgroup/cpu,cpuacct/test$ lscgroup.clone_children  cpuacct.stat   cpuacct.usage_percpu  cpu.cfs_quota_us  cpu.stat           taskscgroup.procs           cpuacct.usage  cpu.cfs_period_us     cpu.shares        notify_on_release</code></pre><p>除了cgroup里面通用的cgroup.clone_children、tasks、cgroup.procs、notify_on_release这几个文件外，以cpuacct.开头的文件跟cpuacct子系统有关，我们这里只需要关注cpu.开头的文件。</p><h3 id="cpu-cfs-period-us-amp-cpu-cfs-quota-us"><a href="#cpu-cfs-period-us-amp-cpu-cfs-quota-us" class="headerlink" title="cpu.cfs_period_us &amp; cpu.cfs_quota_us"></a>cpu.cfs_period_us &amp; cpu.cfs_quota_us</h3><p>cfs_period_us用来配置时间周期长度，cfs_quota_us用来配置当前cgroup在设置的周期长度内所能使用的CPU时间数，两个文件配合起来设置CPU的使用上限。两个文件的单位都是微秒（us），cfs_period_us的取值范围为1毫秒（ms）到1秒（s），cfs_quota_us的取值大于1ms即可，如果cfs_quota_us的值为-1（默认值），表示不受cpu时间的限制。下面是几个例子：</p><pre><code>1.限制只能使用1个CPU（每250ms能使用250ms的CPU时间）    # echo 250000 &gt; cpu.cfs_quota_us /* quota = 250ms */    # echo 250000 &gt; cpu.cfs_period_us /* period = 250ms */2.限制使用2个CPU（内核）（每500ms能使用1000ms的CPU时间，即使用两个内核）    # echo 1000000 &gt; cpu.cfs_quota_us /* quota = 1000ms */    # echo 500000 &gt; cpu.cfs_period_us /* period = 500ms */3.限制使用1个CPU的20%（每50ms能使用10ms的CPU时间，即使用一个CPU核心的20%）    # echo 10000 &gt; cpu.cfs_quota_us /* quota = 10ms */    # echo 50000 &gt; cpu.cfs_period_us /* period = 50ms */</code></pre><h3 id="cpu-shares"><a href="#cpu-shares" class="headerlink" title="cpu.shares"></a>cpu.shares</h3><p>shares用来设置CPU的相对值，并且是针对所有的CPU（内核），默认值是1024，假如系统中有两个cgroup，分别是A和B，A的shares值是1024，B的shares值是512，那么A将获得1024/(1204+512)=66%的CPU资源，而B将获得33%的CPU资源。shares有两个特点：</p><ul><li>如果A不忙，没有使用到66%的CPU时间，那么剩余的CPU时间将会被系统分配给B，即B的CPU使用率可以超过33%</li><li>如果添加了一个新的cgroup C，且它的shares值是1024，那么A的限额变成了1024/(1204+512+1024)=40%，B的变成了20%</li></ul><p>从上面两个特点可以看出：</p><ul><li>在闲的时候，shares基本上不起作用，只有在CPU忙的时候起作用，这是一个优点。</li><li>由于shares是一个绝对值，需要和其它cgroup的值进行比较才能得到自己的相对限额，而在一个部署很多容器的机器上，cgroup的数量是变化的，所以这个限额也是变化的，自己设置了一个高的值，但别人可能设置了一个更高的值，所以这个功能没法精确的控制CPU使用率。</li></ul><h3 id="cpu-stat"><a href="#cpu-stat" class="headerlink" title="cpu.stat"></a>cpu.stat</h3><p>包含了下面三项统计结果</p><ul><li>nr_periods： 表示过去了多少个cpu.cfs_period_us里面配置的时间周期</li><li>nr_throttled： 在上面的这些周期中，有多少次是受到了限制（即cgroup中的进程在指定的时间周期中用光了它的配额）</li><li>throttled_time: cgroup中的进程被限制使用CPU持续了多长时间(纳秒)</li></ul><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>这里以cfs_period_us &amp; cfs_quota_us为例，演示一下如何控制CPU的使用率。</p><pre><code>继续使用上面创建的子cgroup： test#设置只能使用1个cpu的20%的时间dev@ubuntu:/sys/fs/cgroup/cpu,cpuacct/test$ sudo sh -c &quot;echo 50000 &gt; cpu.cfs_period_us&quot;dev@ubuntu:/sys/fs/cgroup/cpu,cpuacct/test$ sudo sh -c &quot;echo 10000 &gt; cpu.cfs_quota_us&quot;#将当前bash加入到该cgroupdev@ubuntu:/sys/fs/cgroup/cpu,cpuacct/test$ echo $$5456dev@ubuntu:/sys/fs/cgroup/cpu,cpuacct/test$ sudo sh -c &quot;echo 5456 &gt; cgroup.procs&quot;#在bash中启动一个死循环来消耗cpu，正常情况下应该使用100%的cpu（即消耗一个内核）dev@ubuntu:/sys/fs/cgroup/cpu,cpuacct/test$ while :; do echo test &gt; /dev/null; done#--------------------------重新打开一个shell窗口----------------------#通过top命令可以看到5456的CPU使用率为20%左右，说明被限制住了#不过这时系统的%us+%sy在10%左右，那是因为我测试的机器上cpu是双核的，#所以系统整体的cpu使用率为10%左右dev@ubuntu:~$ topTasks: 139 total,   2 running, 137 sleeping,   0 stopped,   0 zombie%Cpu(s):  5.6 us,  6.2 sy,  0.0 ni, 88.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :   499984 total,    15472 free,    81488 used,   403024 buff/cacheKiB Swap:        0 total,        0 free,        0 used.   383332 avail Mem  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND 5456 dev       20   0   22640   5472   3524 R  20.3  1.1   0:04.62 bash#这时可以看到被限制的统计结果dev@ubuntu:~$ cat /sys/fs/cgroup/cpu,cpuacct/test/cpu.statnr_periods 1436nr_throttled 1304throttled_time 5154229183</code></pre><h1 id="chroot-与-Mount-namespace"><a href="#chroot-与-Mount-namespace" class="headerlink" title="chroot 与  Mount namespace"></a>chroot 与  Mount namespace</h1><h2 id="chroot"><a href="#chroot" class="headerlink" title="chroot"></a>chroot</h2><p>change root file system</p><p>在 Linux 操作系统里，有一个名为 chroot 的命令可以帮助你在 shell 中方便地完成这个工作。顾名思义，它的作用就是帮你“change root file system”，即改变进程的根目录到你指定的位置。它的用法也非常简单。</p><p>假设，我们现在有一个 $HOME/test 目录，想要把它作为一个 /bin/bash 进程的根目录。</p><p>首先，创建一个 test 目录和几个 lib 文件夹：</p><pre><code>$ mkdir -p $HOME/test$ mkdir -p $HOME/test/{bin,lib64,lib}</code></pre><p>然后，把 bash 命令拷贝到 test 目录对应的 bin 路径下：</p><pre><code>$ cp -v /bin/{bash,ls} $HOME/test/bin</code></pre><p>接下来，把 bash 命令需要的所有 so 文件，也拷贝到 test 目录对应的 lib 路径下。找到 so 文件可以用 ldd 命令：</p><pre><code>$ T=$HOME/test$ list=&quot;$(ldd /bin/ls | egrep -o &#39;/lib.*\.[0-9]&#39;)&quot;$ for i in $list; do cp -v &quot;$i&quot; &quot;${T}${i}&quot;; done</code></pre><p>最后，执行 chroot 命令，告诉操作系统，我们将使用 $HOME/test 目录作为 /bin/bash 进程的根目录：</p><pre><code>$ chroot $HOME/test /bin/bash</code></pre><p>这时，你如果执行 “ls /“，就会看到，它返回的都是 $HOME/test 目录下面的内容，而不是宿主机的内容。</p><p>更重要的是，对于被 chroot 的进程来说，它并不会感受到自己的根目录已经被“修改”成 $HOME/test 了。<br>这种视图被修改的原理，是不是跟我之前介绍的 Linux Namespace 很类似呢？<br>没错！<br>实际上，Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。</p><h2 id="mount-namespace"><a href="#mount-namespace" class="headerlink" title="mount namespace"></a>mount namespace</h2><p>可以做到chroot的功能，而且比chroot更灵活。它属于内核名字空间的一部分。 mount namespace可以对系统真正根目录下的子目录做到共享、独享（也就是将拥有一个子目录的副本）等。 <a href="https://segmentfault.com/a/1190000006912742" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006912742</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mosn</title>
      <link href="/2019/03/01/mesh-mosn-01/"/>
      <url>/2019/03/01/mesh-mosn-01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> mosn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mosn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Namespace</title>
      <link href="/2019/03/01/docker-01-zi-yuan-ge-chi/"/>
      <url>/2019/03/01/docker-01-zi-yuan-ge-chi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-里面的-Namespace-机制"><a href="#Linux-里面的-Namespace-机制" class="headerlink" title="Linux 里面的 Namespace 机制"></a>Linux 里面的 Namespace 机制</h1><p>Namespace是对全局系统资源的一种封装隔离，使得处于不同namespace的进程拥有独立的全局系统资源，改变一个namespace中的系统资源只会影响当前namespace里的进程，对其他namespace中的进程没有影响。</p><p>目前，Linux内核里面实现了7种不同类型的namespace。</p><table><thead><tr><th align="left">名称</th><th align="left">宏定义</th><th align="left">隔离内容</th></tr></thead><tbody><tr><td align="left">Cgroup</td><td align="left">CLONE_NEWCGROUP</td><td align="left">Cgroup root directory (since Linux 4.6)</td></tr><tr><td align="left">IPC</td><td align="left">CLONE_NEWIPC</td><td align="left">System V IPC, POSIX message queues (since Linux 2.6.19)</td></tr><tr><td align="left">Network</td><td align="left">CLONE_NEWNET</td><td align="left">Network devices, stacks, ports, etc. (since Linux 2.6.24)</td></tr><tr><td align="left">Mount</td><td align="left">CLONE_NEWNS</td><td align="left">Mount points (since Linux 2.4.19)</td></tr><tr><td align="left">PID</td><td align="left">CLONE_NEWPID</td><td align="left">Process IDs (since Linux 2.6.24)</td></tr><tr><td align="left">User</td><td align="left">CLONE_NEWUSER</td><td align="left">User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)</td></tr><tr><td align="left">UTS</td><td align="left">CLONE_NEWUTS</td><td align="left">Hostname and NIS domain name (since Linux 2.6.19)</td></tr></tbody></table><h2 id="查看进程所属的namespaces"><a href="#查看进程所属的namespaces" class="headerlink" title="查看进程所属的namespaces"></a>查看进程所属的namespaces</h2><p>系统中的每个进程都有/proc/[pid]/ns/这样一个目录，里面包含了这个进程所属namespace的信息，里面每个文件的描述符都可以用来作为setns函数(后面会介绍)的参数。</p><pre><code>#查看当前bash进程所属的namespacedev@ubuntu:~$ ls -l /proc/$$/ns     total 0lrwxrwxrwx 1 dev dev 0 7月 7 17:24 cgroup -&gt; cgroup:[4026531835] #(since Linux 4.6)lrwxrwxrwx 1 dev dev 0 7月 7 17:24 ipc -&gt; ipc:[4026531839]       #(since Linux 3.0)lrwxrwxrwx 1 dev dev 0 7月 7 17:24 mnt -&gt; mnt:[4026531840]       #(since Linux 3.8)lrwxrwxrwx 1 dev dev 0 7月 7 17:24 net -&gt; net:[4026531957]       #(since Linux 3.0)lrwxrwxrwx 1 dev dev 0 7月 7 17:24 pid -&gt; pid:[4026531836]       #(since Linux 3.8)lrwxrwxrwx 1 dev dev 0 7月 7 17:24 user -&gt; user:[4026531837]     #(since Linux 3.8)lrwxrwxrwx 1 dev dev 0 7月 7 17:24 uts -&gt; uts:[4026531838]       #(since Linux 3.0)</code></pre><p><strong>注意： 由于Cgroup namespace在4.6的内核中才实现</strong></p><h2 id="namespace相关的API"><a href="#namespace相关的API" class="headerlink" title="namespace相关的API"></a>namespace相关的API</h2><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>创建一个新的进程并把他放到新的namespace中</p><pre><code>int clone(int (*child_func)(void *), void *child_stack            , int flags, void *arg);flags：     指定一个或者多个上面的CLONE_NEW*（当然也可以包含跟namespace无关的flags），     这样就会创建一个或多个新的不同类型的namespace，     并把新创建的子进程加入新创建的这些namespace中。</code></pre><h3 id="setns"><a href="#setns" class="headerlink" title="setns"></a>setns</h3><p>当前进程加入到已有的namespace中</p><pre><code>int setns(int fd, int nstype);fd：     指向/proc/[pid]/ns/目录里相应namespace对应的文件，    表示要加入哪个namespacenstype：    指定namespace的类型（上面的任意一个CLONE_NEW*）：    1. 如果当前进程不能根据fd得到它的类型，如fd由其他进程创建，    并通过UNIX domain socket传给当前进程，    那么就需要通过nstype来指定fd指向的namespace的类型    2. 如果进程能根据fd得到namespace类型，比如这个fd是由当前进程打开的，    那么nstype设置为0即可</code></pre><h3 id="unshare"><a href="#unshare" class="headerlink" title="unshare"></a>unshare</h3><p>使当前进程退出指定类型的namespace，并加入到新创建的namespace（相当于创建并加入新的namespace）</p><pre><code>int unshare(int flags);flags：    指定一个或者多个上面的CLONE_NEW*，    这样当前进程就退出了当前指定类型的namespace并加入到新创建的namespace</code></pre><p>clone和unshare的区别</p><ul><li>unshare是使当前进程加入新的namespace</li><li>clone是创建一个新的子进程，然后让子进程加入新的namespace，而当前进程保持不变</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>当一个namespace中的所有进程都退出时，该namespace将会被销毁。当然还有其他方法让namespace一直存在，假设我们有一个进程号为1000的进程，以ipc namespace为例：</p><ul><li><p>通过mount –bind命令。例如mount –bind /proc/1000/ns/ipc /other/file，就算属于这个ipc namespace的所有进程都退出了，只要/other/file还在，这个ipc namespace就一直存在，其他进程就可以利用/other/file，通过setns函数加入到这个namespace</p></li><li><p>在其他namespace的进程中打开/proc/1000/ns/ipc文件，并一直持有这个文件描述符不关闭，以后就可以用setns函数加入这个namespace。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s 如何选择存储</title>
      <link href="/2019/02/22/k8s-15-cun-chu-03/"/>
      <url>/2019/02/22/k8s-15-cun-chu-03/</url>
      
        <content type="html"><![CDATA[<h1 id="如何选择存储"><a href="#如何选择存储" class="headerlink" title="如何选择存储"></a>如何选择存储</h1><h2 id="持久化数据的多种方式"><a href="#持久化数据的多种方式" class="headerlink" title="持久化数据的多种方式"></a>持久化数据的多种方式</h2><h3 id="Volume方式"><a href="#Volume方式" class="headerlink" title="Volume方式"></a>Volume方式</h3><p>awsElasticBlockStore是一个Volume类型。<br>你可以创建一个Pod，定义一个awsElasticBlockStore类型的volume，设置好volumeID，接着使用pod中存在的EBS volume。<br>该EBS volume在直接和Volume使用前必须已经存在。</p><h3 id="PV方式"><a href="#PV方式" class="headerlink" title="PV方式"></a>PV方式</h3><p>AWSElasticBlockStore还是一个PV类型。<br>所以你可以创建一个PV，用它来表示EBS volume（假设你有这样的权限），然后创建一个和它绑定的PVC卷。最后，令PVC作为volume，然后就可以在pod中使用它了。<br>和Volume方法类似，EBS volume在创建PV之前就必须存在。</p><h3 id="Provisioner方式"><a href="#Provisioner方式" class="headerlink" title="Provisioner方式"></a>Provisioner方式</h3><p>kubernetes.io/aws-ebs是一个Kubernetes中用于EBS的内置Provisioner。<br>你可以用Provisioner kubernetes.io/aws-ebs来创建一个Storage Class，通过Storage Class创建PVC。Kubernetes会自动为你创建相对应的PV。接下来指定PVC为volume就可以在pod中使用了。</p><h3 id="第三方方式"><a href="#第三方方式" class="headerlink" title="第三方方式"></a>第三方方式</h3><p>上面列出的都是Kubernetes内置选项，如果你不太满意的话，其实还有一些使用Flexvolume driver格式的第三方EBS实现，它们可以帮助你和Kubernetes连接起来。</p><p>如果Flexvolume不适合你，还可以使用具备同样功能的CSI drivers（为什么这么说？稍后会对此进行详细介绍）</p><p>VolumeClaimTemplate方式</p><p>如果你在使用StatefulSet，那么恭喜你！你现在有额外多了一种使用工作负载中EBS的方式——VolumeClaimTemple。</p><p>VolumeClaimTemple是StatefulSet规范属性，它为StatefulSet所创建的Pod提供了创建匹配PV和PVC的方式。这些PVC将通过Storage Class创建，这样当StatefulSet扩展时就可以自动创建它们。当StatefulSet缩小时，多余的PV/PVCs会保留在系统中。因此，当StatefulSet再一次扩展时，它们会再次作用于Kubernetes创建的新pods中。稍后我们会详细讲StatefulSet。</p><p>举个例子说明，假设你用replica 3创建了一个名为www的StatefulSet，并用它创建了名为data的VolumeClaimTemplate。Kubernetes会创建3个pods，分别起名www-0、www-1、www-2。Kubernetes还会创建PVC，其中www-data-0用于pod www-0，www-data-1给www-1，www-data-2给www-2。如果你把StatefulSet扩展到5，Kubernetes就会分别创建www-3、www-data-3、www-4、www-data-4。如果接着将StatefulSet降为1，www-1到www-4全都会删除，而www-data-1到www-data-4会保留在系统中。因此当你决定再次扩展到5的时候，pod www-1到www-4又回被创建出来，而PVC www-data-1仍然会服务于Pod www-1，www-data-2对应www-2，以此类推。这是因为StatefulSet中pod的身份在是stable的。使用StatefulSet时，名称和关系都是可以预测的。</p><p>VolumeClaimTemple对于像EBS和Longhorn这样的块存储解决方案非常重要。因为这些解决方案本质上是ReadWriteOnce，你不能在Pod之间共享它们。如果你有不止一个运行了持久化数据的pod，那么就无法顺利地进行部署。因此，VolumeClaimTemplate的出现为块存储解决方案提供了一种水平扩展Kubernetes工作负载的方式。</p><h1 id="如何在Volume、Persistent-Volume和Provisioner之间做出选择"><a href="#如何在Volume、Persistent-Volume和Provisioner之间做出选择" class="headerlink" title="如何在Volume、Persistent Volume和Provisioner之间做出选择"></a>如何在Volume、Persistent Volume和Provisioner之间做出选择</h1><p>可以看到，Volume、Persistent Volume以及Provisioner在一些细微的地方还是不一样的。</p><ol><li><p>Volume支持大部分的volume插件。</p><p> A.它是连接PVC和pod的唯一方法</p><p> B.它也是唯一一个支持Config Map、Secret、Downward API以及Projected的。这些所有都与Kubernetes API服务器密切相关。</p><p> C.它还是唯一一个支持EmptyDir的，EmptyDir可以自动给pod分配和清理临时volume。（注：早在2015年，Clayton Coleman就提出了一个关于支持EmptyDir的问题。这对于需要持久化储存但只有本地卷可用的工作负载，这非常有用。可是这一观点并没有得到太多的关注。没有scheduler的支持，这一目标在当时很难做到。而现在，在2018年，Kubernetes v1.11版本的Local Volume已经加入scheduler和PV的节点亲和支持（node affinity support），但是仍然没有EmptyDir PV。而且Local Volume特性并不是我所期望的那样，因为它并不具备在节点上使用新目录创建新卷的能力。因此，我编写了Local Path Provisioner，它利用scheduler和PV节点亲和更改，为工作负载提供动态的Host Path type PV。）</p></li><li><p>PV支持的插件是Provisioner支持的超集，因为Provisioner需要在工作负载使用它之前创建PV。但是，还有一些PV支持而Provisioner不支持的插件，比如Local Volume（正在进行修改中）。</p></li><li><p>还有两种类型Volume是不支持的。他们是两个最新的特性：CSI和Local Volume，现在还有一些正在进行的工作，会在之后把它们用于Volume。</p></li></ol><h3 id="在Volume、Persistent-Volume和Provisioner之间选择的准则"><a href="#在Volume、Persistent-Volume和Provisioner之间选择的准则" class="headerlink" title="在Volume、Persistent Volume和Provisioner之间选择的准则"></a>在Volume、Persistent Volume和Provisioner之间选择的准则</h3><p>那么用户到底应该选择哪种方式呢？</p><p>在我看来，用户们应该坚持一个原则：</p><p>在条件允许的情况下，选择Provisioner而不是Persistent Volume，接着再是Volume。</p><p>详细来说：</p><ol><li><p>对于Config Map、Downward API、Secret或者Projected，请使用Volume，因为PV不支持它们。</p></li><li><p>对于EmptyDir，直接使用Volume，或者使用Host Path来代替。</p></li><li><p>对于Host Path，通常是直接使用Volume，因为它绑定到一个特定的节点，并且节点之间它是同构的。<br>如果你想用异构的Host Path Volume，它在Kubernetes v1.11版之后才能使用，因为之前缺少对PV的节点亲和知识，使用v1.11+版本，你可以使用我的Local Path Provisioner创建带有节点亲和的Host Path PV：</p></li><li><p>对于其他的情况，除非你需要和现有的卷挂钩（这种情况下你应该使用PV），否则就使用Provisioner代替。有些Provisioner并不是内置的选项，但是你应该能在此链接（<a href="https://github.com/kubernetes-incubator/external-storage）或者供应商的官方仓库中找到它们。" target="_blank" rel="noopener">https://github.com/kubernetes-incubator/external-storage）或者供应商的官方仓库中找到它们。</a></p></li></ol><p>这个准则背后的原理很简单。在Kubernetes内部进行操作时，对象（PV）比属性（Volume）更容易管理，而且和手动创建PV相比，自动创建PV容易得多（Provisioner）。</p><p>不过这里有一个例外：如果你喜欢在Kubernetes外面进行存储，那么最好使用Volume，尽管使用这种方式需要用到另一组API进行创建/删除。此外，由于缺少VolumeClaimTemplate，会失去使用StatefulSet自动伸缩的能力。我不认为这是多数Kubernetes用户会选择的方式。</p><h2 id="为什么做同样的事会有这么多选项？"><a href="#为什么做同样的事会有这么多选项？" class="headerlink" title="为什么做同样的事会有这么多选项？"></a>为什么做同样的事会有这么多选项？</h2><p>当我开始研究Kubernetes存储时，首先想到的就是这个问题。由于缺乏一致性和直观性，Kubernetes存储看起来就像是事后才想到的。于是我试图研究这些设计决策背后的历史缘由，可是在2016之前都毫无收获。</p><p>最后，我倾向于相信这些是由于一些早期的设计造成的，这可能是为获取供应商支持的迫切需求，导致安排给Volume比原本更多的责任。在我看来，所有复制了PV的内置volume插件都不应该存在。</p><p>在研究历史的过程中，我发现在2016初发布的Kubernetes v1.2中，dynamic provisioning就已经成为了alpha特性。它需要两个发布版周期变成beta，在两个周期实现稳定，这都是非常合理的。</p><p>SIG Storage（它推动了Kubernetes存储开发）还进行了大量的工作，使用Provisioner和CSI将Volume插件从tree中移出来。我认为这是朝着更加一致、更加精简的系统迈出了一大步。</p><p>可另一方面，我也不认为这一大堆Volume类型会消失。这像是和硅谷非官方的格言唱反调：快速行动，打破常规。有时候，快速迭代的项目所遗留下来的设计，修改它们实在是太难了。我们只能和它们共处，在它们身边小心工作，不要用错误的方式调用它们。</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s PV、PVC、StorageClass</title>
      <link href="/2019/02/15/k8s-15-cun-chu-01/"/>
      <url>/2019/02/15/k8s-15-cun-chu-01/</url>
      
        <content type="html"><![CDATA[<h1 id="PV、PVC、StorageClass"><a href="#PV、PVC、StorageClass" class="headerlink" title="PV、PVC、StorageClass"></a>PV、PVC、StorageClass</h1><h2 id="pv"><a href="#pv" class="headerlink" title="pv"></a>pv</h2><p>PV 描述的，是持久化存储数据卷。这个 API 对象主要定义的是一个持久化存储在宿主机上的目录，比如一个 NFS 的挂载目录。</p><p>通常情况下，PV 对象是由运维人员事先创建在 Kubernetes 集群里待用的。比如，运维人员可以定义这样一个 NFS 类型的 PV，如下所示：</p><pre><code>apiVersion: v1kind: PersistentVolumemetadata:  name: nfsspec:  storageClassName: manual  capacity:    storage: 1Gi  accessModes:    - ReadWriteMany  nfs:    server: 10.244.1.4    path: &quot;/&quot;</code></pre><h2 id="pvc"><a href="#pvc" class="headerlink" title="pvc"></a>pvc</h2><p>而PVC 描述的，则是 Pod 所希望使用的持久化存储的属性。比如，Volume 存储的大小、可读写权限等等。</p><p>PVC 对象通常由开发人员创建；或者以 PVC 模板的方式成为 StatefulSet 的一部分，然后由 StatefulSet 控制器负责创建带编号的 PVC。</p><p>比如，开发人员可以声明一个 1 GiB 大小的 PVC，如下所示：</p><pre><code>apiVersion: v1kind: PersistentVolumeClaimmetadata:  name: nfsspec:  accessModes:    - ReadWriteMany  storageClassName: manual  resources:    requests:      storage: 1Gi</code></pre><p>而用户创建的 PVC 要真正被容器使用起来，就必须先和某个符合条件的 PV 进行绑定。这里要检查的条件，包括两部分：</p><ol><li>第一个条件，当然是 PV 和 PVC 的 spec 字段。比如，PV 的存储（storage）大小，就必须满足 PVC 的要求。</li><li>第二个条件，则是 PV 和 PVC 的 storageClassName 字段必须一样。这个机制我会在本篇文章的最后一部分专门介绍。</li></ol><p>在成功地将 PVC 和 PV 进行绑定之后，Pod 就能够像使用 hostPath 等常规类型的 Volume 一样，在自己的 YAML 文件里声明使用这个 PVC 了，如下所示：</p><pre><code>apiVersion: v1kind: Podmetadata:  labels:    role: web-frontendspec:  containers:  - name: web    image: nginx    ports:      - name: web        containerPort: 80    volumeMounts:        - name: nfs          mountPath: &quot;/usr/share/nginx/html&quot;  volumes:  - name: nfs    persistentVolumeClaim:      claimName: nfs</code></pre><h2 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h2><p>StorageClass 的作用，则是充当 PV 的模板。并且，只有同属于一个 StorageClass 的 PV 和 PVC，才可以绑定在一起。</p><p>StorageClass 的另一个重要作用，是指定 PV 的 Provisioner（存储插件）。这时候，如果你的存储插件支持 Dynamic Provisioning 的话，Kubernetes 就可以自动为你创建 PV 了。</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s CSI</title>
      <link href="/2019/02/15/k8s-15-cun-chu-02/"/>
      <url>/2019/02/15/k8s-15-cun-chu-02/</url>
      
        <content type="html"><![CDATA[<h1 id="CSI开发"><a href="#CSI开发" class="headerlink" title="CSI开发"></a>CSI开发</h1><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="csi-01.png" alt=""></p><p>三个独立的外部组件（External Components），即：Driver Registrar、External Provisioner 和 External Attacher，对应的正是从 Kubernetes 项目里面剥离出来的那部分存储管理功能。</p><p>External Components 虽然是外部组件，但依然由 Kubernetes 社区来开发和维护。</p><h2 id="External-Components"><a href="#External-Components" class="headerlink" title="External Components"></a>External Components</h2><h3 id="Driver-Registrar"><a href="#Driver-Registrar" class="headerlink" title="Driver Registrar"></a>Driver Registrar</h3><p>负责将插件注册到 kubelet 里面（这可以类比为，将可执行文件放在插件目录下）。而在具体实现上，Driver Registrar 需要请求 CSI 插件的 Identity 服务来获取插件信息。</p><h3 id="External-Provisioner"><a href="#External-Provisioner" class="headerlink" title="External Provisioner"></a>External Provisioner</h3><p>负责的正是 Provision 阶段。在具体实现上，External Provisioner 监听（Watch）了 APIServer 里的 PVC 对象。当一个 PVC 被创建时，它就会调用 CSI Controller 的 CreateVolume 方法，为你创建对应 PV。</p><p>此外，如果你使用的存储是公有云提供的磁盘（或者块设备）的话，这一步就需要调用公有云（或者块设备服务）的 API 来创建这个 PV 所描述的磁盘（或者块设备）了。</p><p>不过，由于 CSI 插件是独立于 Kubernetes 之外的，所以在 CSI 的 API 里不会直接使用 Kubernetes 定义的 PV 类型，而是会自己定义一个单独的 Volume 类型。</p><h3 id="External-Attacher"><a href="#External-Attacher" class="headerlink" title="External Attacher"></a>External Attacher</h3><p>它监听了 APIServer 里 VolumeAttachment 对象的变化。VolumeAttachment 对象是 Kubernetes 确认一个 Volume 可以进入“Attach 阶段”的重要标志</p><p>一旦出现了 VolumeAttachment 对象，External Attacher 就会调用 CSI Controller 服务的 ControllerPublish 方法，完成它所对应的 Volume 的 Attach 阶段。</p><p><strong>注意</strong><br>Volume 的“Mount 阶段”，并不属于 External Components 的职责。当 kubelet 的 VolumeManagerReconciler 控制循环检查到它需要执行 Mount 操作的时候，会通过 pkg/volume/csi 包，直接调用 CSI Node 服务完成 Volume 的“Mount 阶段”。</p><p>在实际使用 CSI 插件的时候，我们会将这三个 External Components 作为 sidecar 容器和 CSI 插件放置在同一个 Pod 中。由于 External Components 对 CSI 插件的调用非常频繁，所以这种 sidecar 的部署方式非常高效。</p><h2 id="CSI-plugin"><a href="#CSI-plugin" class="headerlink" title="CSI plugin"></a>CSI plugin</h2><h3 id="CSI-Identity"><a href="#CSI-Identity" class="headerlink" title="CSI Identity"></a>CSI Identity</h3><p>负责对外暴露这个插件本身的信息</p><pre><code>service Identity {  // return the version and name of the plugin  rpc GetPluginInfo(GetPluginInfoRequest)    returns (GetPluginInfoResponse) {}  // reports whether the plugin has the ability of serving the Controller interface  rpc GetPluginCapabilities(GetPluginCapabilitiesRequest)    returns (GetPluginCapabilitiesResponse) {}  // called by the CO just to check whether the plugin is running or not  rpc Probe (ProbeRequest)    returns (ProbeResponse) {}}</code></pre><h3 id="CSI-Controller"><a href="#CSI-Controller" class="headerlink" title="CSI Controller"></a>CSI Controller</h3><p>定义的则是对 CSI Volume（对应 Kubernetes 里的 PV）的管理接口，比如：创建和删除 CSI Volume、对 CSI Volume 进行 Attach/Dettach（在 CSI 里，这个操作被叫作 Publish/Unpublish），以及对 CSI Volume 进行 Snapshot 等，它们的接口定义如下所示：</p><pre><code>service Controller {  // provisions a volume  rpc CreateVolume (CreateVolumeRequest)    returns (CreateVolumeResponse) {}  // deletes a previously provisioned volume  rpc DeleteVolume (DeleteVolumeRequest)    returns (DeleteVolumeResponse) {}  // make a volume available on some required node  rpc ControllerPublishVolume (ControllerPublishVolumeRequest)    returns (ControllerPublishVolumeResponse) {}  // make a volume un-available on some required node  rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest)    returns (ControllerUnpublishVolumeResponse) {}  ...  // make a snapshot  rpc CreateSnapshot (CreateSnapshotRequest)    returns (CreateSnapshotResponse) {}  // Delete a given snapshot  rpc DeleteSnapshot (DeleteSnapshotRequest)    returns (DeleteSnapshotResponse) {}  ...}</code></pre><p>CSI Controller 服务里定义的这些操作有个共同特点，那就是它们都无需在宿主机上进行，而是属于 Kubernetes 里 Volume Controller 的逻辑，也就是属于 Master 节点的一部分。</p><p>CSI Controller 服务的实际调用者，并不是 Kubernetes（即：通过 pkg/volume/csi 发起 CSI 请求），而是 External Provisioner 和 External Attacher。这两个 External Components，分别通过监听 PVC 和 VolumeAttachement 对象，来跟 Kubernetes 进行协作。</p><h3 id="CSI-Node"><a href="#CSI-Node" class="headerlink" title="CSI Node"></a>CSI Node</h3><p>CSI Volume 需要在宿主机上执行的操作，都定义在了 CSI Node 服务里面，如下所示</p><pre><code>service Node {  // temporarily mount the volume to a staging path  rpc NodeStageVolume (NodeStageVolumeRequest)    returns (NodeStageVolumeResponse) {}  // unmount the volume from staging path  rpc NodeUnstageVolume (NodeUnstageVolumeRequest)    returns (NodeUnstageVolumeResponse) {}  // mount the volume from staging to target path  rpc NodePublishVolume (NodePublishVolumeRequest)    returns (NodePublishVolumeResponse) {}  // unmount the volume from staging path  rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest)    returns (NodeUnpublishVolumeResponse) {}  // stats for the volume  rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest)    returns (NodeGetVolumeStatsResponse) {}  ...  // Similar to NodeGetId  rpc NodeGetInfo (NodeGetInfoRequest)    returns (NodeGetInfoResponse) {}}</code></pre><p><strong>注意</strong><br>“Mount 阶段”在 CSI Node 里的接口，是由 NodeStageVolume 和 NodePublishVolume 两个接口共同实现的</p><p>CSI 的设计思想，把插件的职责从“两阶段处理”，扩展成了 Provision、Attach 和 Mount 三个阶段。其中，Provision 等价于“创建磁盘”，Attach 等价于“挂载磁盘到虚拟机”，Mount 等价于“将该磁盘格式化后，挂载在 Volume 的宿主机目录上”。</p><ul><li>当 AttachDetachController 需要进行“Attach”操作时（“Attach 阶段”），它实际上会执行到 pkg/volume/csi 目录中，创建一个 VolumeAttachment 对象，从而触发 External Attacher 调用 CSI Controller 服务的 ControllerPublishVolume 方法。</li><li>当 VolumeManagerReconciler 需要进行“Mount”操作时（“Mount 阶段”），它实际上也会执行到 pkg/volume/csi 目录中，直接向 CSI Node 服务发起调用 NodePublishVolume 方法的请求。</li></ul><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>参考 <a href="https://github.com/AliyunContainerService/csi-plugin" target="_blank" rel="noopener">https://github.com/AliyunContainerService/csi-plugin</a></p><h3 id="定义-StorageClass"><a href="#定义-StorageClass" class="headerlink" title="定义 StorageClass"></a>定义 StorageClass</h3><pre><code>apiVersion: storage.k8s.io/v1kind: StorageClassmetadata:   name: csi-diskprovisioner: diskplugin.csi.alibabacloud.comparameters:    zoneId: cn-beijing-b    regionId: cn-beijing    fsType: ext4    type: cloud_ssd    readOnly: &quot;false&quot;reclaimPolicy: Delete</code></pre><p>有了这个 StorageClass，External Provisoner 就会为集群中新出现的 PVC 自动创建出 PV，然后调用 CSI 插件创建出这个 PV 对应的 Volume，这正是 CSI 体系中 Dynamic Provisioning 的实现方式。</p><p>这个 StorageClass 里唯一引人注意的，是 provisioner= diskplugin.csi.alibabacloud.com 这个字段。显然，这个字段告诉了 Kubernetes，请使用名叫  diskplugin.csi.alibabacloud.com 的 CSI 插件来为我处理这个 StorageClass 相关的所有操作。</p><p><img src="csi-02.jpg" alt=""></p><pre><code> else if drivername == TYPE_PLUGIN_DISK {        driver := disk.NewDriver(*nodeId, *endpoint)        driver.Run()    }.....func (disk *disk) Run() {    log.Infof(&quot;Starting csi-plugin Driver: %v version: %v&quot;, driverName, csiVersion)    s := csicommon.NewNonBlockingGRPCServer()    s.Start(disk.endpoint, disk.idServer, disk.controllerServer, disk.nodeServer)    s.Wait()}</code></pre><p>CSI Identity 服务中，最重要的接口是 GetPluginInfo，它返回的就是这个插件的名字和版本号，如下所示：<br><img src="csi-03.jpg" alt=""></p><pre><code>if ids.Driver.name == &quot;&quot; {        return nil, status.Error(codes.Unavailable, &quot;Driver name not configured&quot;)    }</code></pre><p>是由部署的时候配置的 –provisioner</p><pre><code> - name: csi-provisioner          image: registry.cn-hangzhou.aliyuncs.com/plugins/csi-provisioner:v1.0.0          args:            - &quot;--provisioner=diskplugin.csi.alibabacloud.com&quot;            - &quot;--csi-address=$(ADDRESS)&quot;            - &quot;--v=5&quot;</code></pre><p>GetPluginCapabilities 接口也很重要。这个接口返回的是这个 CSI 插件的“能力”</p><p>比如，当你编写的 CSI 插件不准备实现“Provision 阶段”和“Attach 阶段”（比如，一个最简单的 NFS 存储插件就不需要这两个阶段）时，你就可以通过这个接口返回：本插件不提供 CSI Controller 服务，即：没有 csi.PluginCapability_Service_CONTROLLER_SERVICE 这个“能力”。这样，Kubernetes 就知道这个信息了。</p><p>最后，CSI Identity 服务还提供了一个 Probe 接口。Kubernetes 会调用它来检查这个 CSI 插件是否正常工作。</p><p>一般情况下，我建议你在编写插件时给它设置一个 Ready 标志，当插件的 gRPC Server 停止的时候，把这个 Ready 标志设置为 false。或者，你可以在这里访问一下插件的端口，类似于健康检查的做法。</p><p>然后，我们要开始编写 CSI 插件的第二个服务，即 CSI Controller 服务了。它的代码实现，在 controller.go 文件里。</p><p>“Provision 阶段”对应的接口，是 CreateVolume 和 DeleteVolume，它们的调用者是 External Provisoner。以 CreateVolume 为例，它的主要逻辑如下所示</p><p><a href="https://github.com/AliyunContainerService/csi-plugin/blob/master/pkg/disk/controllerserver.go" target="_blank" rel="noopener">https://github.com/AliyunContainerService/csi-plugin/blob/master/pkg/disk/controllerserver.go</a></p><p>CreateVolume 需要做的操作，就是调用 Aliyun ECS 储服务的 API</p><p>而“Attach 阶段”对应的接口是 ControllerPublishVolume 和 ControllerUnpublishVolume，它们的调用者是 External Attacher。以 ControllerPublishVolume 为例，<br>是调用 ECS 的 API，将我们前面创建的存储卷，挂载到指定的ECS上</p><p>External Attacher 的工作原理，是监听（Watch）了一种名叫 VolumeAttachment 的 API 对象。这种 API 对象的主要字段如下所示：</p><pre><code>// VolumeAttachmentSpec is the specification of a VolumeAttachment request.type VolumeAttachmentSpec struct { // Attacher indicates the name of the volume driver that MUST handle this // request. This is the name returned by GetPluginName(). Attacher string // Source represents the volume that should be attached. Source VolumeAttachmentSource // The node that the volume should be attached to. NodeName string}</code></pre><p>而这个对象的生命周期，正是由 AttachDetachController 负责管理的</p><p>这个控制循环的职责，是不断检查 Pod 所对应的 PV，在它所绑定的宿主机上的挂载情况，从而决定是否需要对这个 PV 进行 Attach（或者 Dettach）操作。</p><p>而这个 Attach 操作，在 CSI 体系里，就是创建出上面这样一个 VolumeAttachment 对象。可以看到，Attach 操作所需的 PV 的名字（Source）、宿主机的名字（NodeName）、存储插件的名字（Attacher），都是这个 VolumeAttachment 对象的一部分。</p><p>而当 External Attacher 监听到这样的一个对象出现之后，就可以立即使用 VolumeAttachment 里的这些字段，封装成一个 gRPC 请求调用 CSI Controller 的 ControllerPublishVolume 方法。</p><p>CSI Node 服务对应的，是 Volume 管理流程里的“Mount 阶段”。它的代码实现，在 nodeserver.go文件里。</p><p><a href="https://sourcegraph.com/github.com/AliyunContainerService/csi-plugin@master/-/blob/pkg/disk/nodeserver.go" target="_blank" rel="noopener">https://sourcegraph.com/github.com/AliyunContainerService/csi-plugin@master/-/blob/pkg/disk/nodeserver.go</a></p><p>kubelet 的 VolumeManagerReconciler 控制循环会直接调用 CSI Node 服务来完成 Volume 的“Mount 阶段”。</p><p>不过，在具体的实现中，这个“Mount 阶段”的处理其实被细分成了 NodeStageVolume 和 NodePublishVolume 这两个接口</p><p>在 kubelet 的 VolumeManagerReconciler 控制循环中，这两步操作分别叫作MountDevice 和 SetUp。</p><ol><li>MountDevice 操作，就是直接调用了 CSI Node 服务里的 NodeStageVolume 接口。顾名思义，这个接口的作用，就是格式化 Volume 在宿主机上对应的存储设备，然后挂载到一个临时目录（Staging 目录）上。</li></ol><ol start="2"><li>SetUp 操作则会调用 CSI Node 服务的 NodePublishVolume 接口。有了上述对设备的预处理工作后，它的实现就非常简单了;<br>在这一步实现中，我们只需要做一步操作，即：将 Staging 目录，绑定挂载到 Volume 对应的宿主机目录上。</li></ol><p>对于文件系统类型的存储服务来说，比如 NFS 和 GlusterFS 等，它们并没有一个对应的磁盘“设备”存在于宿主机上，所以 kubelet 在 VolumeManagerReconciler 控制循环中，会跳过 MountDevice 操作而直接执行 SetUp 操作。所以对于它们来说，也就不需要实现 NodeStageVolume 接口了。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>不在赘述 可以直接参考</p><p><a href="https://github.com/AliyunContainerService/csi-plugin/tree/master/deploy/disk" target="_blank" rel="noopener">https://github.com/AliyunContainerService/csi-plugin/tree/master/deploy/disk</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s CNI</title>
      <link href="/2019/02/05/k8s-13-cni/"/>
      <url>/2019/02/05/k8s-13-cni/</url>
      
        <content type="html"><![CDATA[<h1 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h1><p>CNI(container network interface)的目的在于定义一个标准的接口规范，使得kubernetes在增删POD的时候，能够按照规范向CNI实例提供标准的输入并获取标准的输出，再将输出作为kubernetes管理这个POD的网络的参考。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><pre><code>$ kubeadm init --pod-network-cidr=10.244.0.0/16$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/a70459be0084506e4ec919aa1c114638878db11b/Documentation/kube-flannel.yml</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在安装完成后，你可以在宿主机的 /opt/cni/bin 目录下看到它们，如下所示：</p><pre><code>$ ls -al /opt/cni/bin/total 73088-rwxr-xr-x 1 root root  3890407 Aug 17  2017 bridge-rwxr-xr-x 1 root root  9921982 Aug 17  2017 dhcp-rwxr-xr-x 1 root root  2814104 Aug 17  2017 flannel-rwxr-xr-x 1 root root  2991965 Aug 17  2017 host-local-rwxr-xr-x 1 root root  3475802 Aug 17  2017 ipvlan-rwxr-xr-x 1 root root  3026388 Aug 17  2017 loopback-rwxr-xr-x 1 root root  3520724 Aug 17  2017 macvlan-rwxr-xr-x 1 root root  3470464 Aug 17  2017 portmap-rwxr-xr-x 1 root root  3877986 Aug 17  2017 ptp-rwxr-xr-x 1 root root  2605279 Aug 17  2017 sample-rwxr-xr-x 1 root root  2808402 Aug 17  2017 tuning-rwxr-xr-x 1 root root  3475750 Aug 17  2017 vlan</code></pre><p>这些 CNI 的基础可执行文件，按照功能可以分为三类:</p><ol><li><p>第一类，叫作 Main 插件，它是用来创建具体网络设备的二进制文件。比如，bridge（网桥设备）、ipvlan、loopback（lo 设备）、macvlan、ptp（Veth Pair 设备），以及 vlan。</p><p>Flannel、Weave 等项目，都属于“网桥”类型的 CNI 插件。所以在具体的实现中，它们往往会调用 bridge 这个二进制文件</p></li><li><p>第二类，叫作 IPAM（IP Address Management）插件，它是负责分配 IP 地址的二进制文件。比如，dhcp，这个文件会向 DHCP 服务器发起请求；host-local，则会使用预先配置的 IP 地址段来进行分配。</p></li><li><p>第三类，是由 CNI 社区维护的内置 CNI 插件。比如：flannel，就是专门为 Flannel 项目提供的 CNI 插件；tuning，是一个通过 sysctl 调整网络设备参数的二进制文件；portmap，是一个通过 iptables 配置端口映射的二进制文件；bandwidth，是一个使用 Token Bucket Filter (TBF) 来进行限流的二进制文件。</p></li></ol><p>从这些二进制文件中，我们可以看到，如果要实现一个给 Kubernetes 用的容器网络方案，其实需要做两部分工作，以 Flannel 项目为例：</p><p>首先，实现这个网络方案本身。这一部分需要编写的，其实就是 flanneld 进程里的主要逻辑。比如，创建和配置 flannel.1 设备、配置宿主机路由、配置 ARP 和 FDB 表里的信息等等。</p><p>然后，实现该网络方案对应的 CNI 插件。这一部分主要需要做的，就是配置 Infra 容器里面的网络栈，并把它连接在 CNI 网桥上。</p><p>CNI配置：</p><pre><code>$ cat /etc/cni/net.d/10-flannel.conflist {  &quot;name&quot;: &quot;cbr0&quot;,  &quot;plugins&quot;: [    {      &quot;type&quot;: &quot;flannel&quot;,      &quot;delegate&quot;: {        &quot;hairpinMode&quot;: true,        &quot;isDefaultGateway&quot;: true      }    },    {      &quot;type&quot;: &quot;portmap&quot;,      &quot;capabilities&quot;: {        &quot;portMappings&quot;: true      }    }  ]}</code></pre><p>在 Kubernetes 中，处理容器网络相关的逻辑并不会在 kubelet 主干代码里执行，而是会在具体的 CRI（Container Runtime Interface，容器运行时接口）实现里完成。对于 Docker 项目来说，它的 CRI 实现叫作 dockershim，你可以在 kubelet 的代码里找到它。</p><p>接下来 dockershim 会加载上述的 CNI 配置文件。</p><p>需要注意，Kubernetes 目前不支持多个 CNI 插件混用。如果你在 CNI 配置目录（/etc/cni/net.d）里放置了多个 CNI 配置文件的话，dockershim 只会加载按字母顺序排序的第一个插件。</p><p>但另一方面，CNI 允许你在一个 CNI 配置文件里，通过 plugins 字段，定义多个插件进行协作。</p><p>比如，在我们上面这个例子里，Flannel 项目就指定了 flannel 和 portmap 这两个插件。</p><p>dockershim 会把这个 CNI 配置文件加载起来，并且把列表里的第一个插件、也就是 flannel 插件，设置为默认插件。而在后面的执行过程中，flannel 和 portmap 插件会按照定义顺序被调用，从而依次完成“配置容器网络”和“配置端口映射”这两步操作。</p><p>当 kubelet 组件需要创建 Pod 的时候，它第一个创建的一定是 Infra 容器。所以在这一步，dockershim 就会先调用 Docker API 创建并启动 Infra 容器，紧接着执行一个叫作 SetUpPod 的方法。这个方法的作用就是：为 CNI 插件准备参数，然后调用 CNI 插件为 Infra 容器配置网络。</p><p>这里要调用的 CNI 插件，就是 /opt/cni/bin/flannel；而调用它所需要的参数，分为两部分。</p><p>第一部分，是由 dockershim 设置的一组 CNI 环境变量。</p><p>其中，最重要的环境变量参数叫作：CNI_COMMAND。它的取值只有两种：ADD 和 DEL。</p><p>这个 ADD 和 DEL 操作，就是 CNI 插件唯一需要实现的两个方法。</p><p>其中 ADD 操作的含义是：把容器添加到 CNI 网络里；DEL 操作的含义则是：把容器从 CNI 网络里移除掉。</p><p>而对于网桥类型的 CNI 插件来说，这两个操作意味着把容器以 Veth Pair 的方式“插”到 CNI 网桥上，或者从网桥上“拔”掉。</p><p>接下来，我以 ADD 操作为重点进行讲解。</p><p>CNI 的 ADD 操作需要的参数包括：容器里网卡的名字 eth0（CNI_IFNAME）、Pod 的 Network Namespace 文件的路径（CNI_NETNS）、容器的 ID（CNI_CONTAINERID）等。这些参数都属于上述环境变量里的内容。其中，Pod（Infra 容器）的 Network Namespace 文件的路径，即：/proc/&lt; 容器进程的 PID&gt;/ns/net</p><p>除此之外，在 CNI 环境变量里，还有一个叫作 CNI_ARGS 的参数。通过这个参数，CRI 实现（比如 dockershim）就可以以 Key-Value 的格式，传递自定义信息给网络插件。这是用户将来自定义 CNI 协议的一个重要方法。</p><p>第二部分，则是 dockershim 从 CNI 配置文件里加载到的、默认插件的配置信息。</p><p>这个配置信息在 CNI 中被叫作 Network Configuration，它的完整定义你可以参考这个文档。dockershim 会把 Network Configuration 以 JSON 数据的格式，通过标准输入（stdin）的方式传递给 Flannel CNI 插件。</p><p>而有了这两部分参数，Flannel CNI 插件实现 ADD 操作的过程就非常简单了。</p><p>不过，需要注意的是，Flannel 的 CNI 配置文件（ /etc/cni/net.d/10-flannel.conflist）里有这么一个字段，叫作 delegate：</p><pre><code>...     &quot;delegate&quot;: {        &quot;hairpinMode&quot;: true,        &quot;isDefaultGateway&quot;: true      }</code></pre><p>Delegate 字段的意思是，这个 CNI 插件并不会自己做事儿，而是会调用 Delegate 指定的某种 CNI 内置插件来完成。对于 Flannel 来说，它调用的 Delegate 插件，就是前面介绍到的 CNI bridge 插件。</p><p>所以说，dockershim 对 Flannel CNI 插件的调用，其实就是走了个过场。Flannel CNI 插件唯一需要做的，就是对 dockershim 传来的 Network Configuration 进行补充。比如，将 Delegate 的 Type 字段设置为 bridge，将 Delegate 的 IPAM 字段设置为 host-local 等。</p><p>经过 Flannel CNI 插件补充后的、完整的 Delegate 字段如下所示：</p><pre><code>{    &quot;hairpinMode&quot;:true,    &quot;ipMasq&quot;:false,    &quot;ipam&quot;:{        &quot;routes&quot;:[            {                &quot;dst&quot;:&quot;10.244.0.0/16&quot;            }        ],        &quot;subnet&quot;:&quot;10.244.1.0/24&quot;,        &quot;type&quot;:&quot;host-local&quot;    },    &quot;isDefaultGateway&quot;:true,    &quot;isGateway&quot;:true,    &quot;mtu&quot;:1410,    &quot;name&quot;:&quot;cbr0&quot;,    &quot;type&quot;:&quot;bridge&quot;}</code></pre><p>其中，ipam 字段里的信息，比如 10.244.1.0/24，读取自 Flannel 在宿主机上生成的 Flannel 配置文件，即：宿主机上的 /run/flannel/subnet.env 文件。</p><p>接下来，Flannel CNI 插件就会调用 CNI bridge 插件，也就是执行：/opt/cni/bin/bridge 二进制文件。</p><p>这一次，调用 CNI bridge 插件需要的两部分参数的第一部分、也就是 CNI 环境变量，并没有变化。所以，它里面的 CNI_COMMAND 参数的值还是“ADD”。</p><p>而第二部分 Network Configration，正是上面补充好的 Delegate 字段。Flannel CNI 插件会把 Delegate 字段的内容以标准输入（stdin）的方式传递给 CNI bridge 插件。</p><p>此外，Flannel CNI 插件还会把 Delegate 字段以 JSON 文件的方式，保存在 /var/lib/cni/flannel 目录下。这是为了给后面删除容器调用 DEL 操作时使用的。</p><p>有了这两部分参数，接下来 CNI bridge 插件就可以“代表”Flannel，进行“将容器加入到 CNI 网络里”这一步操作了。而这一部分内容，与容器 Network Namespace 密切相关，所以我要为你详细讲解一下。</p><p>首先，CNI bridge 插件会在宿主机上检查 CNI 网桥是否存在。如果没有的话，那就创建它。这相当于在宿主机上执行：</p><pre><code># 在宿主机上$ ip link add cni0 type bridge$ ip link set cni0 up</code></pre><p>接下来，CNI bridge 插件会通过 Infra 容器的 Network Namespace 文件，进入到这个 Network Namespace 里面，然后创建一对 Veth Pair 设备。</p><p>紧接着，它会把这个 Veth Pair 的其中一端，“移动”到宿主机上。这相当于在容器里执行如下所示的命令：</p><pre><code># 在容器里# 创建一对 Veth Pair 设备。其中一个叫作 eth0，另一个叫作 vethb4963f3$ ip link add eth0 type veth peer name vethb4963f3# 启动 eth0 设备$ ip link set eth0 up # 将 Veth Pair 设备的另一端（也就是 vethb4963f3 设备）放到宿主机（也就是 Host Namespace）里$ ip link set vethb4963f3 netns $HOST_NS# 通过 Host Namespace，启动宿主机上的 vethb4963f3 设备$ ip netns exec $HOST_NS ip link set vethb4963f3 up </code></pre><p>这样，vethb4963f3 就出现在了宿主机上，而且这个 Veth Pair 设备的另一端，就是容器里面的 eth0。</p><p>上述创建 Veth Pair 设备的操作，其实也可以先在宿主机上执行，然后再把该设备的一端放到容器的 Network Namespace 里，这个原理是一样的。</p><p>不过，CNI 插件之所以要“反着”来，是因为 CNI 里对 Namespace 操作函数的设计就是如此，如下所示：</p><pre><code>err := containerNS.Do(func(hostNS ns.NetNS) error {  ...  return nil})</code></pre><p>这个设计其实很容易理解。在编程时，容器的 Namespace 是可以直接通过 Namespace 文件拿到的；而 Host Namespace，则是一个隐含在上下文的参数。所以，像上面这样，先通过容器 Namespace 进入容器里面，然后再反向操作 Host Namespace，对于编程来说要更加方便。</p><p>接下来，CNI bridge 插件就可以把 vethb4963f3 设备连接在 CNI 网桥上。这相当于在宿主机上执行：</p><pre><code># 在宿主机上$ ip link set vethb4963f3 master cni0</code></pre><p>在将 vethb4963f3 设备连接在 CNI 网桥之后，CNI bridge 插件还会为它设置Hairpin Mode（发夹模式）。这是因为，在默认情况下，网桥设备是不允许一个数据包从一个端口进来后，再从这个端口发出去的。但是，它允许你为这个端口开启 Hairpin Mode，从而取消这个限制。</p><p>这个特性，主要用在容器需要通过NAT（即：端口映射）的方式，“自己访问自己”的场景下。</p><p>举个例子，比如我们执行 docker run -p 8080:80，就是在宿主机上通过 iptables 设置了一条DNAT（目的地址转换）转发规则。这条规则的作用是，当宿主机上的进程访问“&lt; 宿主机的 IP 地址 &gt;:8080”时，iptables 会把该请求直接转发到“&lt; 容器的 IP 地址 &gt;:80”上。也就是说，这个请求最终会经过 docker0 网桥进入容器里面。</p><p>但如果你是在容器里面访问宿主机的 8080 端口，那么这个容器里发出的 IP 包会经过 vethb4963f3 设备（端口）和 docker0 网桥，来到宿主机上。此时，根据上述 DNAT 规则，这个 IP 包又需要回到 docker0 网桥，并且还是通过 vethb4963f3 端口进入到容器里。所以，这种情况下，我们就需要开启 vethb4963f3 端口的 Hairpin Mode 了。</p><p>所以说，Flannel 插件要在 CNI 配置文件里声明 hairpinMode=true。这样，将来这个集群里的 Pod 才可以通过它自己的 Service 访问到自己。</p><p>接下来，CNI bridge 插件会调用 CNI ipam 插件，从 ipam.subnet 字段规定的网段里为容器分配一个可用的 IP 地址。然后，CNI bridge 插件就会把这个 IP 地址添加在容器的 eth0 网卡上，同时为容器设置默认路由。这相当于在容器里执行：</p><pre><code># 在容器里$ ip addr add 10.244.0.2/24 dev eth0$ ip route add default via 10.244.0.1 dev eth0</code></pre><p>最后，CNI bridge 插件会为 CNI 网桥添加 IP 地址。这相当于在宿主机上执行：</p><pre><code># 在宿主机上$ ip addr add 10.244.0.1/24 dev cni0</code></pre><p>在执行完上述操作之后，CNI 插件会把容器的 IP 地址等信息返回给 dockershim，然后被 kubelet 添加到 Pod 的 Status 字段。</p><p>至此，CNI 插件的 ADD 方法就宣告结束了。接下来的流程，就跟容器跨主机通信的过程完全一致了。</p><p>需要注意的是，对于非网桥类型的 CNI 插件，上述“将容器添加到 CNI 网络”的操作流程，以及网络方案本身的工作原理，就都不太一样了。</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s choosing-a-cni-provider</title>
      <link href="/2019/02/05/k8s-14-cni/"/>
      <url>/2019/02/05/k8s-14-cni/</url>
      
        <content type="html"><![CDATA[<h1 id="choosing-a-cni-provider"><a href="#choosing-a-cni-provider" class="headerlink" title="choosing-a-cni-provider"></a>choosing-a-cni-provider</h1><p>容器网络接口（CNI）是一个库定义，是Cloud Native Computing Foundation项目保护下的一组工具。有关更多信息，请访问他们的GitHub 项目。Kubernetes使用CNI作为网络提供商和Kubernetes网络之间的接口。</p><h2 id="Why-Use-CNI"><a href="#Why-Use-CNI" class="headerlink" title="Why Use CNI"></a>Why Use CNI</h2><p>Kubernetes默认网络提供商kubenet是一个简单的网络插件，可与各种云提供商合作。Kubenet是一个非常基本的网络提供商，基本是好的，但没有很多功能。此外，kubenet有许多局限性。例如，在AWS Cloud中运行kubenet时，您只能使用50个EC2实例。路由表用于配置Kubernetes节点之间的网络流量，每个VPC限制为50个条目。此外，无法在专用VPC中设置群集，因为该网络拓扑使用多个路由表。其他更高级的功能，如BGP，出口控制和网状网络，仅适用于不同的CNI提供商。</p><h2 id="Choosing-a-Provider"><a href="#Choosing-a-Provider" class="headerlink" title="Choosing a Provider"></a>Choosing a Provider</h2><p>Which CNI provider should I use?</p><h2 id="CNI-in-kops"><a href="#CNI-in-kops" class="headerlink" title="CNI in kops"></a>CNI in kops</h2><p>最后统计，除了kubenet之外，kops还支持七种不同的CNI提供商。有以下</p><ul><li>Calico</li><li>Canal (Flannel + Calico)</li><li>flannel</li><li>kopeio-vxlan</li><li>kube-router</li><li>romana</li><li>Weave Net</li></ul><p>任何这些CNI提供者都可以在没有kops的情况下使用。所有CNI提供程序都使用守护程序安装模型，其产品部署Kubernetes Daemonset。一旦K8s API服务器启动，只需使用kubectl在主服务器上安装提供程序。请参阅每个项目的具体文档。</p><h2 id="Summary-of-the-Providers"><a href="#Summary-of-the-Providers" class="headerlink" title="Summary of the Providers"></a>Summary of the Providers</h2><h3 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h3><p>Mike Stowe提供了Calico和Canal的摘要。</p><p>Calico使用纯L3方法提供简单，可扩展的网络。它支持在支持它的环境中的本机，未封装网络，包括AWS，AZ和其他在节点之间具有L2邻接的环境，或者在可以使用BGP与基础架构对等的部署中，例如内部部署。Calico还提供无状态IP-in-IP模式，如有必要，可在其他环境中使用。除了可扩展的网络，Project Calico还提供策略隔离，允许您使用高级入口和出口策略保护和管理您的微服务/容器基础架构。通过广泛的Kubernetes支持，您可以在Kubernetes 1.8+中管理您的策略。</p><h3 id="Canal"><a href="#Canal" class="headerlink" title="Canal"></a>Canal</h3><p>Canal是一家CNI提供商，为您提供最好的Flannel和Project Calico，提供简单，易用/开箱即用的VXLAN网络，同时还允许您利用Calico策略的策略隔离。</p><p>对于想要在利用他们可能已经使用的熟悉技术的同时启动和运行的任何人来说，此提供商都是一个解决方案</p><h3 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h3><p>flannel是一种简单易用的方法，可以配置为Kubernetes设计的layer3网络结构。没有外部数据库（使用Kubernetes API），简单的性能可以在VXLAN默认的任何地方工作，可以与Calico策略引擎（Canal）分层。哦，还有很多用户。</p><p>Coreco的商业Kubernetes产品Tectonic，使用flannel和来自Calico的Felix ，就像Canal一样。</p><h3 id="kopeio-networking"><a href="#kopeio-networking" class="headerlink" title="kopeio-networking"></a>kopeio-networking</h3><p>kopeio-networking提供Kubernetes第一个网络。它是专为Kubernetes而设计的，充分利用了Kubernetes API，因此比改装的替代品更简单，更可靠。VXLAN方法是最常用的模式（用于编织和法兰绒），但它也支持第2层（用于印花布），更多实验性支持GRE（替代IPIP）和IPSEC（用于安全）配置）。它通过非常简单的代码库完成所有这些工作</p><h3 id="kube-router"><a href="#kube-router" class="headerlink" title="kube-router"></a>kube-router</h3><p>Kube-router是专为Kubernetes打造的专用网络解决方案。它旨在提供操作简单性和性能。Kube-router提供pod网络解决方案，服务代理和网络策略实施器作为一体化解决方案，并设置了单个守护进程。Kuber-router使用Kubernetes本机功能，如注释，由kube-controller-manger分配pod CIDR。因此它不依赖于数据存储，也没有为节点的pod CIDR分配实现任何自定义解决方案。Kube-router也使用标准的CNI插件，因此需要任何额外的CNI插件。Kube-router建立在标准的Linux网络工具集和ipset，iptables，ipvs和lvs等技术之上。</p><h3 id="romana"><a href="#romana" class="headerlink" title="romana"></a>romana</h3><p>Romana为pod网络使用标准的第3层网络。Romana支持Kubernetes网络策略API，即使群集跨网络可用区域分割，也不需要覆盖。Romana支持各种网络拓扑，包括平面第2层和路由第3层网络。节点之间的路由在本地安装，必要时使用BGP或OSPF分发到网络设备。在AWS部署中，Romana将聚合路由安装到VPC路由表中以克服50节点限制。这使Romana可以跨HA集群的可用区域使用本机VPC网络。当前版本使用自己的etcd集群，但下一个版本可选择允许Kubernetes etcd集群用作数据存储。</p><h3 id="Weave-Net"><a href="#Weave-Net" class="headerlink" title="Weave Net"></a>Weave Net</h3><p>Weave Net支持覆盖网络，可以跨越不同的云网络配置，简化Kubernetes上运行的旧工作负载。例如，Weave支持多播，即使底层网络没有。Weave可以在AWS上运行时配置基础VPC网络并绕过覆盖。此提供程序形成可分区且最终一致的主机网状网络; 这意味着设置几乎为零配置，并且它不需要依赖Etcd。Weave支持加密和Kubernetes网络策略，确保网络级别具有安全性。</p><h2 id="GitHub-Stars"><a href="#GitHub-Stars" class="headerlink" title="GitHub Stars"></a>GitHub Stars</h2><p><img src="cni-github-03.png" alt=""></p><h2 id="GitHub-Contributors"><a href="#GitHub-Contributors" class="headerlink" title="GitHub Contributors"></a>GitHub Contributors</h2><p><img src="cni-github-01.png" alt=""></p><h2 id="GitHub-Forks"><a href="#GitHub-Forks" class="headerlink" title="GitHub Forks"></a>GitHub Forks</h2><p><img src="cni-github-02.png" alt=""></p><h2 id="Support-Matrix"><a href="#Support-Matrix" class="headerlink" title="Support Matrix"></a>Support Matrix</h2><p>|Provider    |Network Model|Route Distribution|Network Policies|Mesh|External Datastore|Encryption    Ingress/Egress Policies    |Commercial Support|<br>|———|———|———|———|———|———|———|———|———|<br>|Calico    |Layer 3    |Yes |    Yes |    Yes    |Etcd|    Yes|    Yes    |Yes|<br>|Canal    |Layer 2 vxlan| N/A|    Yes    |No|Etcd |No|    Yes|    No|<br>|flannel    |vxlan    |No    |No    |No|    None    |No    |No    |No|<br>|kopeio-networking    |Layer 2 vxlan |    N/A |    No|    No|    None|    Yes|    No|    No|<br>|kube-router    |Layer 3    |BGP    |Yes|    No|    No|    No|    No|    No|<br>|romana    |Layer 3    |OSPF    |Yes|    No    |Etcd    |No    |Yes    |Yes|<br>|Weave Net    |Layer 2 vxlan|    N/A    |Yes|    Yes    |No|    Yes    |Yes|    Yes|</p><ol><li>Calico和Canal包含一个直接连接到Kubernetes的功能，而不是使用Etcd。</li><li>kopeio CNI提供商有三种不同的组网方式：vlan，layer2，GRE和IPSEC。</li><li>kopie-network在IPSEC模式下提供加密，而不是默认的vxlan模式。</li><li>Weave Net可以在没有vxlan的AWS-VPC模式下运行，但在EC2中仅限于50个节点。</li><li>Weave Net没有开箱即用的出口规则。</li></ol><h3 id="Table-Details"><a href="#Table-Details" class="headerlink" title="Table Details"></a>Table Details</h3><ol><li>Network Model</li></ol><p>具有提供商的网络模型是封装网络（如VXLAN）或未封装的第2层网络。封装网络流量需要计算才能处理，因此理论上要慢一些。在我看来，大多数用例不会受到开销的影响。有关维基百科上的 VXLAN的更多信息 。</p><ol start="2"><li>Route Distribution</li></ol><p>对于第3层CNI提供商，路由分发是必要的。路由分配通常通过BGP进行。如果您计划构建跨网段分割的群集，则路由分发很适合使用CNI功能。它是一种外部网关协议，旨在在互联网上交换路由和可达性信息。BGP可以协助群集之间的pod到pod联网。</p><ol start="3"><li>Network Policies</li></ol><p><a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/services-networking/network-policies/</a></p><ol start="4"><li>Mesh Networking</li></ol><p>此功能允许Kubernetes集群之间的“Pod to Pod”网络。这项技术不是Kubernetes联合会，而是Pods之间的纯粹网络。</p><ol start="5"><li>Encyption</li></ol><p>加密网络控制平面，以便加密所有TCP和UDP流量。</p><ol start="6"><li>Ingress / Egress Policies</li></ol><p>网络策略是Kubernetes和Non-Kubernetes路由控制。例如，许多提供商将允许管理员阻止与169.254.169.254上的EC2实例元数据服务进行通信的pod。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://chrislovecnm.com/kubernetes/cni/choosing-a-cni-provider/" target="_blank" rel="noopener">https://chrislovecnm.com/kubernetes/cni/choosing-a-cni-provider/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s Flannel</title>
      <link href="/2019/02/04/k8s-12-flannel/"/>
      <url>/2019/02/04/k8s-12-flannel/</url>
      
        <content type="html"><![CDATA[<h1 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h1><p>Flannel 项目是 CoreOS 公司主推的容器网络方案。事实上，Flannel 项目本身只是一个框架，提供容器网络功能的，是 Flannel 的后端实现。目前，Flannel 支持三种后端实现，分别是：</p><ul><li>VXLAN</li><li>host-gw</li><li>UDP</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>在这个例子中，有两台宿主机。</p><ul><li>宿主机 Node 1 上有一个容器 container-1，它的 IP 地址是 100.96.1.2，对应的 docker0 网桥的地址是：100.96.1.1/24。</li><li>宿主机 Node 2 上有一个容器 container-2，它的 IP 地址是 100.96.2.3，对应的 docker0 网桥的地址是：100.96.2.1/24。</li></ul><p>让 container-1 访问 container-2。<br>这种情况下，container-1 容器里的进程发起的 IP 包，其源地址就是 100.96.1.2，目的地址就是 100.96.2.3。由于目的地址 100.96.2.3 并不在 Node 1 的 docker0 网桥的网段里，所以这个 IP 包会被交给默认路由规则，通过容器的网关进入 docker0 网桥（如果是同一台宿主机上的容器间通信，走的是直连规则），从而出现在宿主机上。<br>这时候，这个 IP 包的下一个目的地，就取决于宿主机上的路由规则了。此时，Flannel 已经在宿主机上创建出了一系列的路由规则，以 Node 1 为例，如下所示：</p><pre><code># 在 Node 1 上$ ip routedefault via 10.168.0.1 dev eth0100.96.0.0/16 dev flannel0  proto kernel  scope link src 100.96.1.0100.96.1.0/24 dev docker0  proto kernel  scope link  src 100.96.1.110.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.2</code></pre><p>可以看到，由于 IP 包的目的地址是 100.96.2.3，它匹配不到本机 docker0 网桥对应的 100.96.1.0/24 网段，只能匹配到第二条、也就是 100.96.0.0/16 对应的这条路由规则，从而进入到一个叫作 flannel0 的设备中。</p><p>而这个 flannel0 设备的类型就比较有意思了：它是一个 TUN 设备（Tunnel 设备）。</p><p>在 Linux 中，TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备。TUN 设备的功能非常简单，即：在操作系统内核和用户应用程序之间传递 IP 包。</p><p>以 flannel0 设备为例：</p><p>像上面提到的情况，当操作系统将一个 IP 包发送给 flannel0 设备之后，flannel0 就会把这个 IP 包，交给创建这个设备的应用程序，也就是 Flannel 进程。这是一个从内核态（Linux 操作系统）向用户态（Flannel 进程）的流动方向。</p><p>反之，如果 Flannel 进程向 flannel0 设备发送了一个 IP 包，那么这个 IP 包就会出现在宿主机网络栈中，然后根据宿主机的路由表进行下一步处理。这是一个从用户态向内核态的流动方向。</p><p>所以，当 IP 包从容器经过 docker0 出现在宿主机，然后又根据路由表进入 flannel0 设备后，宿主机上的 flanneld 进程（Flannel 项目在每个宿主机上的主进程），就会收到这个 IP 包。然后，flanneld 看到了这个 IP 包的目的地址，是 100.96.2.3，就把它发送给了 Node 2 宿主机。</p><p>等一下，flanneld 又是如何知道这个 IP 地址对应的容器，是运行在 Node 2 上的呢？</p><p>这里，就用到了 Flannel 项目里一个非常重要的概念：子网（Subnet）。</p><p>事实上，在由 Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网”。在例子中，Node 1 的子网是 100.96.1.0/24，container-1 的 IP 地址是 100.96.1.2。Node 2 的子网是 100.96.2.0/24，container-2 的 IP 地址是 100.96.2.3。</p><p>而这些子网与宿主机的对应关系，正是保存在 Etcd 当中，如下所示：</p><pre><code>$ etcdctl ls /coreos.com/network/subnets/coreos.com/network/subnets/100.96.1.0-24/coreos.com/network/subnets/100.96.2.0-24/coreos.com/network/subnets/100.96.3.0-24</code></pre><p>所以，flanneld 进程在处理由 flannel0 传入的 IP 包时，就可以根据目的 IP 的地址（比如 100.96.2.3），匹配到对应的子网（比如 100.96.2.0/24），从 Etcd 中找到这个子网对应的宿主机的 IP 地址是 10.168.0.3，如下所示：</p><pre><code>$ etcdctl get /coreos.com/network/subnets/100.96.2.0-24{&quot;PublicIP&quot;:&quot;10.168.0.3&quot;}</code></pre><p>而对于 flanneld 来说，只要 Node 1 和 Node 2 是互通的，那么 flanneld 作为 Node 1 上的一个普通进程，就一定可以通过上述 IP 地址（10.168.0.3）访问到 Node 2，这没有任何问题。</p><p>所以说，flanneld 在收到 container-1 发给 container-2 的 IP 包之后，就会把这个 IP 包直接封装在一个 UDP 包里，然后发送给 Node 2。不难理解，这个 UDP 包的源地址，就是 flanneld 所在的 Node 1 的地址，而目的地址，则是 container-2 所在的宿主机 Node 2 的地址。</p><p>当然，这个请求得以完成的原因是，每台宿主机上的 flanneld，都监听着一个 8285 端口，所以 flanneld 只要把 UDP 包发往 Node 2 的 8285 端口即可。</p><p>通过这样一个普通的、宿主机之间的 UDP 通信，一个 UDP 包就从 Node 1 到达了 Node 2。而 Node 2 上监听 8285 端口的进程也是 flanneld，所以这时候，flanneld 就可以从这个 UDP 包里解析出封装在里面的、container-1 发来的原 IP 包。</p><p>而接下来 flanneld 的工作就非常简单了：flanneld 会直接把这个 IP 包发送给它所管理的 TUN 设备，即 flannel0 设备。</p><p>根据前面讲解的 TUN 设备的原理，这正是一个从用户态向内核态的流动方向（Flannel 进程向 TUN 设备发送数据包），所以 Linux 内核网络栈就会负责处理这个 IP 包，具体的处理方法，就是通过本机的路由表来寻找这个 IP 包的下一步流向。</p><p>而 Node 2 上的路由表，跟 Node 1 非常类似，如下所示：</p><pre><code># 在 Node 2 上$ ip routedefault via 10.168.0.1 dev eth0100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.2.0100.96.2.0/24 dev docker0  proto kernel  scope link  src 100.96.2.110.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.3</code></pre><p>docker0 网桥会扮演二层交换机的角色，将数据包发送给正确的端口，进而通过 Veth Pair 设备进入到 container-2 的 Network Namespace 里。</p><p>而 container-2 返回给 container-1 的数据包，则会经过与上述过程完全相反的路径回到 container-1 中。</p><p>需要注意的是，上述流程要正确工作还有一个重要的前提，那就是 docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网。这个很容易实现，以 Node 1 为例，你只需要给它上面的 Docker Daemon 启动时配置如下所示的 bip 参数即可：</p><pre><code>$ FLANNEL_SUBNET=100.96.1.1/24$ dockerd --bip=$FLANNEL_SUBNET ...</code></pre><p><img src="flannel-01.png" alt=""></p><p>Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p><p>上述 UDP 模式有严重的性能问题，所以已经被废弃了</p><p>实际上，相比于两台宿主机之间的直接通信，基于 Flannel UDP 模式的容器通信多了一个额外的步骤，即 flanneld 的处理过程。而这个过程，由于使用到了 flannel0 这个 TUN 设备，仅在发出 IP 包的过程中，就需要经过三次用户态与内核态之间的数据拷贝，如下所示：<br><img src="flannel-02.png" alt=""></p><p>第一次：用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；</p><p>第二次：IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；</p><p>第三次：flanneld 进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的 eth0 发出去。</p><p>此外，Flannel 进行 UDP 封装（Encapsulation）和解封装（Decapsulation）的过程，也都是在用户态完成的。在 Linux 操作系统中，上述这些上下文切换和用户态操作的代价其实是比较高的，这也正是造成 Flannel UDP 模式性能不好的主要原因。</p><p>所以说，在进行系统级编程的时候，有一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行。这也是为什么，Flannel 后来支持的VXLAN 模式，逐渐成为了主流的容器网络方案的原因。</p><h1 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h1><p>VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。所以说，VXLAN 可以完全在内核态实现上述封装和解封装的工作，从而通过与前面相似的“隧道”机制，构建出覆盖网络（Overlay Network）。</p><p>VXLAN 的覆盖网络的设计思想是：在现有的三层网络之上，“覆盖”一层虚拟的、由内核 VXLAN 模块负责维护的二层网络，使得连接在这个 VXLAN 二层网络上的“主机”（虚拟机或者容器都可以）之间，可以像在同一个局域网（LAN）里那样自由通信。当然，实际上，这些“主机”可能分布在不同的宿主机上，甚至是分布在不同的物理机房里。</p><p>而为了能够在二层网络上打通“隧道”，VXLAN 会在宿主机上设置一个特殊的网络设备作为“隧道”的两端。这个设备就叫作 VTEP，即：VXLAN Tunnel End Point（虚拟隧道端点）。</p><p>而 VTEP 设备的作用，其实跟前面的 flanneld 进程非常相似。只不过，它进行封装和解封装的对象，是二层数据帧（Ethernet frame）；而且这个工作的执行流程，全部是在内核里完成的（因为 VXLAN 本身就是 Linux 内核中的一个模块）。</p><p>上述基于 VTEP 设备进行“隧道”通信的流程，如下所示：<br><img src="flannel-03.png" alt=""></p><h1 id="host-gw"><a href="#host-gw" class="headerlink" title="host-gw"></a>host-gw</h1><p><img src="flannel-04.png" alt=""><br>host-gw 的性能损失大约在 10% 左右，而其他所有基于 VXLAN“隧道”机制的网络方案，性能损失都在 20%~30% 左右。</p><p>host-gw 模式能够正常工作的核心，就在于 IP 包在封装成帧发送出去的时候，会使用路由表里的“下一跳”来设置目的 MAC 地址。这样，它就会经过二层网络到达目的宿主机。</p><p>所以说，Flannel host-gw 模式必须要求集群宿主机之间是二层连通的。</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETCD Operator</title>
      <link href="/2019/02/02/k8s-11-operator-02/"/>
      <url>/2019/02/02/k8s-11-operator-02/</url>
      
        <content type="html"><![CDATA[<h1 id="ETCD-Operator"><a href="#ETCD-Operator" class="headerlink" title="ETCD Operator"></a>ETCD Operator</h1><p> 在 Kuernetes 生态中，Operator可以更加灵活和编程友好的管理“有状态应用”的 比如 数据库</p><h1 id="快速试用"><a href="#快速试用" class="headerlink" title="快速试用"></a>快速试用</h1><p><a href="https://github.com/coreos/etcd-operator" target="_blank" rel="noopener">https://github.com/coreos/etcd-operator</a></p><pre><code>$ git clone https://github.com/coreos/etcd-operator$ example/rbac/create_role.sh</code></pre><p>这个脚本的作用，就是为 Etcd Operator 创建 RBAC 规则。这是因为，Etcd Operator 需要访问 Kubernetes 的 APIServer 来创建对象</p><ol><li>对 Pod、Service、PVC、Deployment、Secret 等 API 对象，有所有权限；</li><li>对 CRD 对象，有所有权限；</li><li>对属于 etcd.database.coreos.com 这个 API Group 的 CR（Custom Resource）对象，有所有权限。</li></ol><p>而 Etcd Operator 本身，其实就是一个 Deployment，它的 YAML 文件如下所示：</p><pre><code>apiVersion: extensions/v1beta1kind: Deploymentmetadata:  name: etcd-operatorspec:  replicas: 1  template:    metadata:      labels:        name: etcd-operator    spec:      containers:      - name: etcd-operator        image: quay.io/coreos/etcd-operator:v0.9.4        command:        - etcd-operator        # Uncomment to act for resources in all namespaces. More information in doc/user/clusterwide.md        #- -cluster-wide        env:        - name: MY_POD_NAMESPACE          valueFrom:            fieldRef:              fieldPath: metadata.namespace        - name: MY_POD_NAME          valueFrom:            fieldRef:              fieldPath: metadata.name</code></pre><pre><code>$ kubectl get podsNAME                              READY     STATUS      RESTARTS   AGEetcd-operator-649dbdb5cb-bzfzp    1/1       Running     0          20s$ kubectl get crdNAME                                    CREATED ATetcdclusters.etcd.database.coreos.com   2019-03-01T18:42:55Z</code></pre><p>这个 CRD 名叫etcdclusters.etcd.database.coreos.com 。你可以通过 kubectl describe 命令看到它的细节，如下所示：</p><pre><code>$ kubectl describe crd  etcdclusters.etcd.database.coreos.com...Group:   etcd.database.coreos.com  Names:    Kind:       EtcdCluster    List Kind:  EtcdClusterList    Plural:     etcdclusters    Short Names:      etcd    Singular:  etcdcluster  Scope:       Namespaced  Version:     v1beta2...</code></pre><p>通过上述步骤创建 etcd.database.coreos.com API 组（Group）<br>如果有API 资源类型（Kind）是“EtcdCluster”的 YAML 文件被提交上来 K8s将会识别</p><p>提交 EtcdCluster</p><pre><code>$ kubectl apply -f example/example-etcd-cluster.yaml$ kubectl get podsNAME                            READY     STATUS    RESTARTS   AGEexample-etcd-cluster-dp8nqtjznc   1/1       Running     0          1mexample-etcd-cluster-mbzlg6sd56   1/1       Running     0          2mexample-etcd-cluster-v6v6s6stxd   1/1       Running     0          2m</code></pre><h2 id="example-etcd-如果被创建出来"><a href="#example-etcd-如果被创建出来" class="headerlink" title="example-etcd 如果被创建出来"></a>example-etcd 如果被创建出来</h2><p>Operator 的工作原理，实际上是利用了 Kubernetes 的自定义 API 资源（CRD），来描述想要部署的“有状态应用”；然后在自定义控制器里，根据自定义 API 对象的变化，来完成具体的部署和运维工作。</p><p>Etcd Operator 部署 Etcd 集群，采用的是静态集群（Static）的方式。</p><p>静态集群的好处是，它不必依赖于一个额外的服务发现机制来组建集群，非常适合本地容器化部署。而它的难点，则在于你必须在部署的时候，就规划好这个集群的拓扑结构，并且能够知道这些节点固定的 IP 地址。比如下面这个例子：</p><pre><code>$ etcd --name infra0 --initial-advertise-peer-urls http://10.0.1.10:2380 \  --listen-peer-urls http://10.0.1.10:2380 \...  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state new$ etcd --name infra1 --initial-advertise-peer-urls http://10.0.1.11:2380 \  --listen-peer-urls http://10.0.1.11:2380 \...  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state new$ etcd --name infra2 --initial-advertise-peer-urls http://10.0.1.12:2380 \  --listen-peer-urls http://10.0.1.12:2380 \...  --initial-cluster-token etcd-cluster-1 \  --initial-cluster infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380,infra2=http://10.0.1.12:2380 \  --initial-cluster-state new</code></pre><p>在这个例子中，启动了三个 Etcd 进程，组成了一个三节点的 Etcd 集群。</p><p>其中，这些节点启动参数里的–initial-cluster 参数，非常值得你关注。它的含义，正是当前节点启动时集群的拓扑结构。说得更详细一点，就是当前这个节点启动时，需要跟哪些节点通信来组成集群。</p><h1 id="Etcd-集群创建分析"><a href="#Etcd-集群创建分析" class="headerlink" title="Etcd 集群创建分析"></a>Etcd 集群创建分析</h1><p>EtcdCluster 这个 CRD 的定义，它对应的 types.go 文件的主要内容，如下所示：</p><pre><code>// +genclient// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Objecttype EtcdCluster struct {  metav1.TypeMeta   `json:&quot;,inline&quot;`  metav1.ObjectMeta `json:&quot;metadata,omitempty&quot;`  Spec              ClusterSpec   `json:&quot;spec&quot;`  Status            ClusterStatus `json:&quot;status&quot;`}type ClusterSpec struct { // Size is the expected size of the etcd cluster. // The etcd-operator will eventually make the size of the running // cluster equal to the expected size. // The vaild range of the size is from 1 to 7. Size int `json:&quot;size&quot;` ... }</code></pre><p>可以看到，EtcdCluster 是一个有 Status 字段的 CRD。在这里，可以不必关心 ClusterSpec 里的其他字段，只关注 Size（即：Etcd 集群的大小）字段即可。</p><p>Size 字段的存在，就意味着将来如果想要调整集群大小的话，应该直接修改 YAML 文件里 size 的值，并执行 kubectl apply -f。</p><p>这样，Operator 就会完成 Etcd 节点的增删操作。这种“scale”能力，也是 Etcd Operator 自动化运维 Etcd 集群需要实现的主要功能。</p><p>而为了能够支持这个功能，不再像前面那样在–initial-cluster 参数里把拓扑结构固定死。</p><p>所以，Etcd Operator 的实现，虽然选择的也是静态集群，但这个集群具体的组建过程，是逐个节点动态添加的方式，即：<br>首先，Etcd Operator 会创建一个“种子节点”；<br>然后，Etcd Operator 会不断创建新的 Etcd 节点，然后将它们逐一加入到这个集群当中，直到集群的节点数等于 size。</p><p>ETCDOperator创建集群可以分为俩个步骤</p><ol><li><p>Bootstrap<br>infra0 节点为例，它的 IP 地址是 10.0.1.10，那么 Etcd Operator 生成的种子节点的启动命令，如下所示：</p><pre><code>$ etcd--data-dir=/var/etcd/data--name=infra0--initial-advertise-peer-urls=http://10.0.1.10:2380--listen-peer-urls=http://0.0.0.0:2380--listen-client-urls=http://0.0.0.0:2379--advertise-client-urls=http://10.0.1.10:2379--initial-cluster=infra0=http://10.0.1.10:2380--initial-cluster-state=new--initial-cluster-token=4b5215fa-5401-4a95-a8c6-892317c9bef8  </code></pre><p>，这个种子节点的 initial-cluster-state 是 new，并且指定了唯一的 initial-cluster-token 参数。</p><ol start="2"><li>AddNode</li></ol></li></ol><pre><code> etcdctl member add infra1 http://10.0.1.11:2380$ etcd    --data-dir=/var/etcd/data    --name=infra1    --initial-advertise-peer-urls=http://10.0.1.11:2380    --listen-peer-urls=http://0.0.0.0:2380    --listen-client-urls=http://0.0.0.0:2379    --advertise-client-urls=http://10.0.1.11:2379    --initial-cluster=infra0=http://10.0.1.10:2380,infra1=http://10.0.1.11:2380    --initial-cluster-state=existing</code></pre><p>对于这个 infra1 成员节点来说，它的 initial-cluster-state 是 existing，也就是要加入已有集群。而它的 initial-cluster 的值，则变成了 infra0 和 infra1 两个节点的 IP 地址。</p><p>所以，以此类推，不断地将 infra2 等后续成员添加到集群中，直到整个集群的节点数目等于用户指定的 size 之后，部署就完成了。</p><h1 id="ETCDOperator源码分析"><a href="#ETCDOperator源码分析" class="headerlink" title="ETCDOperator源码分析"></a>ETCDOperator源码分析</h1><p>Etcd Operator 的启动流程也是围绕着 Informer 展开的，如下所示：</p><pre><code>func (c *Controller) Start() error { for {  err := c.initResource()  ...  time.Sleep(initRetryWaitTime) } c.run()}func (c *Controller) run() { ... _, informer := cache.NewIndexerInformer(source, &amp;api.EtcdCluster{}, 0, cache.ResourceEventHandlerFuncs{  AddFunc:    c.onAddEtcdClus,  UpdateFunc: c.onUpdateEtcdClus,  DeleteFunc: c.onDeleteEtcdClus, }, cache.Indexers{}) ctx := context.TODO() // TODO: use workqueue to avoid blocking informer.Run(ctx.Done())}</code></pre><p>可以看到，Etcd Operator 启动要做的第一件事（ c.initResource），是创建 EtcdCluster 对象所需要的 CRD，即：前面提到的etcdclusters.etcd.database.coreos.com。这样 Kubernetes 就能够“认识”EtcdCluster 这个自定义 API 资源了。</p><p>而接下来，Etcd Operator 会定义一个 EtcdCluster 对象的 Informer。</p><p>不过，需要注意的是，由于 Etcd Operator 的完成时间相对较早，所以它里面有些代码的编写方式会跟之前讲解的最新的编写方式不太一样。在具体实践的时候，你还是应该以我讲解的模板为主。</p><p>比如，在上面的代码最后，你会看到有这样一句注释：</p><pre><code>// TODO: use workqueue to avoid blocking</code></pre><p>Etcd Operator 并没有用工作队列来协调 Informer 和控制循环<br>不过KuberBuilder 创建的Operator实现了该功能</p><p>在控制循环里执行的业务逻辑，往往是比较耗时间的。比如，创建一个真实的 Etcd 集群。而 Informer 的 WATCH 机制对 API 对象变化的响应，则非常迅速。所以，控制器里的业务逻辑就很可能会拖慢 Informer 的执行周期，甚至可能 Block 它。而要协调这样两个快、慢任务的一个典型解决方法，就是引入一个工作队列</p><p>由于 Etcd Operator 里没有工作队列，那么在它的 EventHandler 部分，就不会有什么入队操作，而直接就是每种事件对应的具体的业务逻辑了。</p><p><img src="etcd-operator.jpg" alt=""></p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>CRD 并不是万能的，它有很多场景不适用，还有性能瓶颈。你能列举出一些不适用 CRD 的场景么？你知道造成 CRD 性能瓶颈的原因主要在哪里么？</p><p>CRD 目前不支持 protobuf，当 API Object 数量 &gt;1K，或者单个对象 &gt;1KB，或者高频请求时，CRD 的响应都会有问题。 所以，CRD 千万不能也不应该被当作数据库使用。</p><p>其实像 Kubernetes ，或者说 Etcd 本身，最佳的使用场景就是作为配置管理的依赖。此外，如果业务需求不能用 CRD 进行建模的时候，比如，需要等待 API 最终返回，或者需要检查 API 的返回值，也是不能用 CRD 的。同时，当你需要完整的 APIServer 而不是只关心 API 对象的时候，使用 API Aggregator</p><h2 id="API-Aggregator"><a href="#API-Aggregator" class="headerlink" title="API Aggregator"></a>API Aggregator</h2><p><img src="aggregator.png" alt=""></p><h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p><a href="https://github.com/kubernetes-incubator/metrics-server" target="_blank" rel="noopener">https://github.com/kubernetes-incubator/metrics-server</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s Operator</title>
      <link href="/2019/02/01/k8s-11-operator-01/"/>
      <url>/2019/02/01/k8s-11-operator-01/</url>
      
        <content type="html"><![CDATA[<h1 id="What-is-Operator？"><a href="#What-is-Operator？" class="headerlink" title="What is Operator？"></a>What is Operator？</h1><p>Operator是管理特定应用程序的控制器，通过扩展kubernetes api以软件的方式帮助kubernetes用户创建，配置和管理复杂有状态的应用程序实例(etcd,redis,mysql,prometheus等等)。它建立在基本的Kubernetes资源和控制器概念的基础上，它包含管理特定应用程序的操作以及实现常见任务的自动化。</p><h1 id="Stateless-is-Easy-Stateful-is-Hard"><a href="#Stateless-is-Easy-Stateful-is-Hard" class="headerlink" title="Stateless is Easy, Stateful is Hard"></a>Stateless is Easy, Stateful is Hard</h1><p>有了kubernetes，管理和扩展web应用，移动后端和api服务就变得相对容易了。<br>why？因为这些应用程序通常是无状态的，可以通过基本的Kubernetes APIs就能run起来，例如通过Deployments资源，可以在没有额外的知识的情况下扩展我们的应用程序并可以从故障中恢复。<br>一个更大的挑战是管理有状态的应用程序，如数据库，缓存和监控系统。<br>这些系统需要学习相关的知识来正确扩展，升级和重新加载配置，同时防止数据丢失或不可用。我们希望将这种特定于应用程序的操作知识通过编码解决，利用强大的kubernetes抽象的软件实现，以正确运行和管理应用程序。</p><h1 id="Lifecycle-of-an-Operator"><a href="#Lifecycle-of-an-Operator" class="headerlink" title="Lifecycle of an Operator"></a>Lifecycle of an Operator</h1><p><img src="run-only.png" alt=""><br>构建后，需要在Kubernetes集群上部署operator。Operator Lifecycle Manager是便于管理Kubernetes集群上operator的背板。有了它，管理员可以控制operator在哪些命名空间中可用，以及谁可以与正在运行的操作员交互。他们还可以管理运营商及其资源的整个生命周期，例如触发对运营商及其资源的更新。</p><h1 id="Why-Kubernetes-Operators-are-a-game-changer"><a href="#Why-Kubernetes-Operators-are-a-game-changer" class="headerlink" title="Why Kubernetes Operators are a game changer"></a>Why Kubernetes Operators are a game changer</h1><p>控制器能够直接访问Kubernetes API，这意味着它们可以监控集群，改变Pod/服务，扩容/缩容，以及调用运行着的应用程序的endpoint，所有这些都根据编写在这些控制器里的自定义规则来实现。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://coreos.com/operators/" target="_blank" rel="noopener">https://coreos.com/operators/</a></li><li><a href="https://blog.couchbase.com/kubernetes-operators-game-changer/" target="_blank" rel="noopener">https://blog.couchbase.com/kubernetes-operators-game-changer/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s apiserver 权限</title>
      <link href="/2019/01/26/k8s-9-apiserver-quan-xian/"/>
      <url>/2019/01/26/k8s-9-apiserver-quan-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="认证类型"><a href="#认证类型" class="headerlink" title="认证类型"></a>认证类型</h1><p>kubernetes 提供了三种级别的客户端认证方式：</p><ul><li>HTTPS证书认证，是基于CA根证书签名的双向数字证书认证方 式，是最严格的认证</li><li>HTTP Token认证，通过Token识别每个合法的用户</li><li>HTTP Basic认证</li></ul><p>HTTP Token认证和Http Basic认证是相对简单的认证方式，Kubernetes的各组件与Api Server的通信方式仍然是HTTPS，但不再使用CA数字证书。</p><p>基于CA证书的双向认证</p><p>我们注意到有如下三个启动参数：</p><ul><li>–client-ca-file: 指定CA根证书文件为/etc/kubernetes/pki/ca.pem，内置CA公钥用于验证某证书是否是CA签发的证书</li><li>–tls-private-key-file: 指定ApiServer私钥文件为/etc/kubernetes/pki/apiserver-key.pem</li><li>–tls-cert-file：指定ApiServer证书文件为/etc/kubernetes/pki/apiserver.pem</li></ul><p>说明Api Server已经启动了HTTPS证书认证，此时如果在集群外部使用浏览器访问https://:6443/api会提示Unauthorized。</p><a id="more"></a><p>生成客户端私钥和证书<br>客户端要通过https证书双向认证的形式访问apiserver需要生成客户端的私钥和证书。在最新版本的kubernetes中，已经不再需要手动为客户端生成证书。直接由Master端签发即可。</p><p>master端允许其证书申请：</p><pre><code># 查看 csr➜  kubectl get csrNAME        AGE       REQUESTOR           CONDITIONcsr-l9d25   2m        kubelet-bootstrap   Pending# 签发证书➜  kubectl certificate approve csr-l9d25certificatesigningrequest &quot;csr-l9d25&quot; approved</code></pre><p>master核心组件与apiserver的认证方式<br>/etc/kubernetes/manifests下的kube-controller-manager.json和kube-scheduler.json说明Controller Manager和Scheduler都是以静态Pod的形式运行在Master Node上，注意到这两个文件里的启动参数–master=127.0.0.1:8080，说明它们直接通过insecure-port 8080和ApiServer通信。 而前面ApiServer的–insecure-bind-address=127.0.0.1，因此他们之间无需走secure-port。</p><h2 id="HTTP-Token认证"><a href="#HTTP-Token认证" class="headerlink" title="HTTP Token认证"></a>HTTP Token认证</h2><p>在上面master node的apiserver的启动命令里面，除了证书的双向认证，还同时启动了token认证。</p><p>–token-auth-file=/etc/kubernetes/pki/token.csv 指定了静态token文件，这个文件的格式如下：</p><pre><code>token,user,uid,&quot;group1,group2,group3&quot;</code></pre><p>生成token方式如下：</p><pre><code>export BOOTSTRAP_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d &#39; &#39;)cat &gt; token.csv &lt;&lt;EOF${BOOTSTRAP_TOKEN},kubelet-bootstrap,10001,&quot;system:kubelet-bootstrap&quot;EOF</code></pre><p>请求Api时只要在Authorization头中加入Bearer Token即可：</p><pre><code>curl -k --header &quot;Authorization: Bearer fe0b40f90ac632c26d79c39673f3dd80&quot; https://10.1.61.129:6443/api{  &quot;kind&quot;: &quot;APIVersions&quot;,  &quot;versions&quot;: [    &quot;v1&quot;  ],  &quot;serverAddressByClientCIDRs&quot;: [    {      &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;,      &quot;serverAddress&quot;: &quot;10.1.61.129:6443&quot;    }  ]}</code></pre><p>kubectl使用Bearer访问apiserver：</p><pre><code>kubectl --server=https://10.1.61.129:6443 \--token=fe0b40f90ac632c26d79c39673f3dd80 \--insecure-skip-tls-verify=true \cluster-info</code></pre><h2 id="HTTP-Basic认证"><a href="#HTTP-Basic认证" class="headerlink" title="HTTP Basic认证"></a>HTTP Basic认证</h2><p>kubeadm在初始化集群时并没有开启http basic认证，官方也不建议在实践中使用。但是，在前面的两种认证方式中，如果我们要在外部通过https的方式访问dashboard，则无法办到，除非对外开启apiserver非安全认证的8080端口，这显然不是我们想看到的。在这种情况 下，我们就可以开启http basic认证，既可以通过https的方式 在外部打开dashboard，同时还能提供基本的安全认证。在这里也简单的列一下http basic认证的配置。</p><ol><li><p>在master上创建/etc/kubernetes/basic_auth文件，文件中每行的格式如下：<br>password,user,uid,”group1,group2,group3”<br>示例如下：<br>1234,admin,1</p></li><li><p>在启动apiserver的时候，启动项添加如下参数即可：</p></li></ol><p>–basic_auth_file=/etc/kubernetes/basic_auth</p><p>使用请求头Authorization Basic BASE64ENCODED(USER:PASSWORD)访问方式如下：</p><pre><code>echo admin:1234|base64YWRtaW46MTIzNAo=curl -k --header &quot;Authorization:Basic YWRtaW46MTIzNAo=&quot; https://10.1.61.129:6443/api{  &quot;kind&quot;: &quot;APIVersions&quot;,  &quot;versions&quot;: [    &quot;v1&quot;  ],  &quot;serverAddressByClientCIDRs&quot;: [    {      &quot;clientCIDR&quot;: &quot;0.0.0.0/0&quot;,      &quot;serverAddress&quot;: &quot;10.1.61.129:6443&quot;    }  ]}</code></pre><p>使用kubectl访问如下：<br>kubectl –server=<a href="https://10.1.61.129:6443" target="_blank" rel="noopener">https://10.1.61.129:6443</a> <br>–username=admin <br>–password=1234 <br>–insecure-skip-tls-verify=true <br>cluster-info</p><h1 id="kubectl-config简要说明"><a href="#kubectl-config简要说明" class="headerlink" title="kubectl config简要说明"></a>kubectl config简要说明</h1><pre><code># kubectl config viewapiVersion: v1clusters:- cluster:    certificate-authority-data: REDACTED    server: https://172.16.66.101:6443  name: kubernetescontexts:- context:    cluster: kubernetes    user: kubernetes-admin  name: kubernetes-admin@kubernetescurrent-context: kubernetes-admin@kuberneteskind: Configpreferences: {}users:- name: kubernetes-admin  user:    client-certificate-data: REDACTED    client-key-data: REDACTED</code></pre><p>首先我们将 /etc/kubernetes/admin.conf中client-certificate-data的数据内容保存到一个临时文件admin-client-certificate.txt中：</p><p>然后针对该文件数据做base64解码，得到client certificate文件：</p><pre><code>cat admin-client-certificate.txt | base64 -d &gt; admin-client.crt# cat admin-client.crt-----BEGIN CERTIFICATE-----MIIC8jCCAdqgAwIBAgIIf2dVRjm8ELQwDQYJKoZIhvcNAQELBQAwFTETMBEGA1UEAxMKa3ViZXJuZXRlczAeFw0xODA1MTQwODE3MTNaFw0xOTA1MTQwODE3MTdaMDQxFzAVBgNVBAoTDnN5c3RlbTptYXN0ZXJzMRkwFwYDVQQDExBrdWJlcm5ldGVzLWFkbWluMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxBn3jdw80b1Gfb6sw2NrqpLotMT4nyAf2HhqMrXjnO+wnaK1AITOw/22mDj0rwIuJwdQIj5/BaF63pPEpU0vhIPVK4n6JI4dmMzo/lR3jZpGeZW1zdXaCovw9c7clbiHo/mFG4xqytVLfX4/S8mFp2A9QcieJGIo5S0BR3FZlU1PM7DRbLDVVq1PdyNY2GfsbGrHlGgXvWAKCd/H79gAqVoTXjSIWCVYuYcoLvdvVXQSIiYlpXFP1jBQLvcU7vrqtb12RmrxnpkW4pldGEOX2sLmfYZ5TiFpkRwz2GxsmWyRbt6OuISJFI6RZ0r+Rn4yMDKPrYlEngDVc5KPZ5zmwIDAQABoycwJTAOBgNVHQ8BAf8EBAMCBaAwEwYDVR0lBAwwCgYIKwYBBQUHAwIwDQYJKoZIhvcNAQELBQADggEBAEZNTvTz2OgzCUdvMFbrhPsp+mD2vPjMRCxiBkA10vICOSfdymMn8aw0IbKYz2gQbXqUfqzQmQfa3if+QYBkB+77zfsv9am4EP/e6Tg52tqV2P7s2eF7tNAe20GyV6yFlQ1QUW5/M4M+JMlV+BUbl9yEyQlENucKf+uTPyKKTUtzvUYr5E3EJkt84EQINvw2nR2jNveZ1XWOliUrKfjHHtfvO/n56USuI4wu2LTlICRcj4g+ZWlIjeMFkGyPbJyJAQ65P2sGrZm1klGGH3mzwO5CP1yZWvoUjjPjzSjMCIaK/fR8eRAJ6q1tT6bG26L+njkKCQDWKpjAWOapuROcbk=-----END CERTIFICATE-----</code></pre><p>查看证书内容：</p><pre><code># openssl x509 -in ./admin-client.crt -textCertificate:    Data:        Version: 3 (0x2)        Serial Number: 9180400125522743476 (0x7f67554639bc10b4)    Signature Algorithm: sha256WithRSAEncryption        Issuer: CN=kubernetes        Validity            Not Before: May 14 08:17:13 2018 GMT            Not After : May 14 08:17:17 2019 GMT        Subject: O=system:masters, CN=kubernetes-admin        Subject Public Key Info:            Public Key Algorithm: rsaEncryption                Public-Key: (2048 bit)   ... ...</code></pre><p>从证书输出的信息中，我们看到了下面这行：</p><pre><code>Subject: O=system:masters, CN=kubernetes-admin</code></pre><p>k8s apiserver对kubectl的请求进行client certificate验证(通过ca证书–client-ca-file=/etc/kubernetes/pki/ca.crt对其进行校验)，验证通过后kube-apiserver会得到： group = system:masters 的http上下文信息，并传给后续的authorizers。</p><h3 id="在授权-authorization-时根据Group确定所绑定的角色-Role"><a href="#在授权-authorization-时根据Group确定所绑定的角色-Role" class="headerlink" title="在授权(authorization)时根据Group确定所绑定的角色(Role)"></a>在授权(authorization)时根据Group确定所绑定的角色(Role)</h3><p>kubeadm在init初始引导集群启动过程中，创建了许多default的role、clusterrole、rolebinding和clusterrolebinding，  </p><p><a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a></p><table><thead><tr><th align="left">Default ClusterRole</th><th align="center">Default ClusterRoleBinding</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">cluster-admin</td><td align="center">system:masters group</td><td align="left">Allows super-user access to perform any action on any resource. When used in a ClusterRoleBinding, it gives full control over every resource in the cluster and in all namespaces. When used in a RoleBinding, it gives full control over every resource in the rolebinding’s namespace, including the namespace itself.</td></tr><tr><td align="left">admin</td><td align="center">None</td><td align="left">Allows admin access, intended to be granted within a namespace using a RoleBinding. If used in a RoleBinding, allows read/write access to most resources in a namespace, including the ability to create roles and rolebindings within the namespace. It does not allow write access to resource quota or to the namespace itself.</td></tr><tr><td align="left">edit</td><td align="center">None</td><td align="left">Allows read/write access to most objects in a namespace. It does not allow viewing or modifying roles or rolebindings.</td></tr><tr><td align="left">view</td><td align="center">None</td><td align="left">Allows read-only access to see most objects in a namespace. It does not allow viewing roles or rolebindings. It does not allow viewing secrets, since those are escalating.</td></tr><tr><td align="left"></td><td align="center"></td><td align="left"></td></tr></tbody></table><p>其中第一个 cluster-admin 这个cluster role binding绑定了 system:masters group，这和authentication环节传递过来的身份信息不谋而合。沿着 system:masters group对应的cluster-admin clusterrolebinding“追查”下去，真相就会浮出水面。</p><p>我们查看一下这一binding：</p><pre><code># kubectl get clusterrolebinding/cluster-admin -n kube-system -o yamlapiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  annotations:    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;  creationTimestamp: 2018-06-07T06:14:55Z  labels:    kubernetes.io/bootstrapping: rbac-defaults  name: cluster-admin  resourceVersion: &quot;103&quot;  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/cluster-admin  uid: 18c89690-6a1a-11e8-a0e8-00163e0cd764roleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: cluster-adminsubjects:- apiGroup: rbac.authorization.k8s.io  kind: Group  name: system:masters</code></pre><p>我们看到在kube-system名字空间中，一个名为cluster-admin的clusterrolebinding将cluster-admin cluster role与system:masters Group绑定到了一起，赋予了所有归属于system:masters Group中用户cluster-admin角色所拥有的权限。</p><p>我们再来查看一下cluster-admin这个role的具体权限信息：</p><pre><code># kubectl get clusterrole/cluster-admin -n kube-system -o yamlapiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata:  annotations:    rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;  creationTimestamp: 2018-06-07T06:14:55Z  labels:    kubernetes.io/bootstrapping: rbac-defaults  name: cluster-admin  resourceVersion: &quot;52&quot;  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterroles/cluster-admin  uid: 18abe535-6a1a-11e8-a0e8-00163e0cd764rules:- apiGroups:  - &#39;*&#39;  resources:  - &#39;*&#39;  verbs:  - &#39;*&#39;- nonResourceURLs:  - &#39;*&#39;  verbs:  - &#39;*&#39;</code></pre><p>从rules列表中来看，cluster-admin这个角色对所有resources、verbs、apiGroups均有无限制的操作权限，即整个集群的root权限。于是kubectl的请求就可以操控和管理整个集群了。</p><p>至此，我们应该明确了为什么采用了admin.conf kubeconfig的kubectrl拥有root权限了。下面是一幅示意图，简要总结了对kubectl访问请求的身份验证和授权过程：</p><p><img src="how-kubectl-be-authorized.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s job</title>
      <link href="/2019/01/25/k8s-8/"/>
      <url>/2019/01/25/k8s-8/</url>
      
        <content type="html"><![CDATA[<h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><p>Job负责批处理任务，即仅执行一次的任务，它保证批处理任务的一个或多个Pod成功结束。</p><h2 id="Job-Spec格式"><a href="#Job-Spec格式" class="headerlink" title="Job Spec格式"></a>Job Spec格式</h2><ul><li>spec.template格式同Pod</li><li>RestartPolicy仅支持Never或OnFailure</li><li>单个Pod时，默认Pod成功运行后Job即结束</li><li>.spec.completions标志Job结束需要成功运行的Pod个数，默认为1</li><li>.spec.parallelism标志并行运行的Pod的个数，默认为1</li><li>spec.activeDeadlineSeconds标志失败Pod的重试最大时间，超过这个时间不会继续重试</li></ul><h1 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h1><p>Cron Job 管理基于时间的 Job，即：</p><ul><li>在给定时间点只运行一次</li><li>周期性地在给定时间点运行</li></ul><p>一个 CronJob 对象类似于 crontab （cron table）文件中的一行。它根据指定的预定计划周期性地运行一个 Job，格式可以参考 Cron </p><pre><code>apiVersion: batch/v1beta1kind: CronJobmetadata:  name: hellospec:  schedule: &quot;*/1 * * * *&quot;  jobTemplate:    spec:      template:        spec:          containers:          - name: hello            image: alpine            args:            - /bin/sh            - -c          # - date; echo Hello from the Kubernetes cluster; sleep 120;            - date; echo Hello from the Kubernetes cluster;          restartPolicy: OnFailure</code></pre><h1 id="CronJob-Spec"><a href="#CronJob-Spec" class="headerlink" title="CronJob Spec"></a>CronJob Spec</h1><ul><li><p>.spec.schedule：调度，必需字段，指定任务运行周期，格式同 Cron</p></li><li><p>.spec.jobTemplate：Job 模板，必需字段，指定需要运行的任务，格式同 Job</p></li><li><p>.spec.startingDeadlineSeconds ：启动 Job 的期限（秒级别），该字段是可选的。如果因为任何原因而错过了被调度的时间，那么错过执行时间的 Job 将被认为是失败的。如果没有指定，则没有期限</p></li><li><p>.spec.concurrencyPolicy：并发策略，该字段也是可选的。它指定了如何处理被 Cron Job 创建的 Job 的并发执行。只允许指定下面策略中的一种：</p><ul><li>Allow（默认）：允许并发运行 Job</li><li>Forbid：禁止并发运行，如果前一个还没有完成，则直接跳过下一个</li><li>Replace：取消当前正在运行的 Job，用一个新的来替换</li><li>注意，当前策略只能应用于同一个 Cron Job 创建的 Job。如果存在多个 Cron Job，它们创建的   Job 之间总是允许并发运行。</li></ul></li><li><p>.spec.suspend ：挂起，该字段也是可选的。如果设置为 true，后续所有执行都会被挂起。它对已经开始执行的 Job 不起作用。默认值为 false。</p></li><li><p>.spec.successfulJobsHistoryLimit 和 .spec.failedJobsHistoryLimit ：历史限制，是可选的字段。它们指定了可以保留多少完成和失败的 Job。<br>默认情况下，它们分别设置为 3 和 1。设置限制的值为 0，相关类型的 Job 完成后将不会被保留。</p></li></ul><p>命令：</p><ul><li>获取所有cronjob<br>kubectl get cronjob</li><li>查看hello cronjob<br>kubectl get cronjob hello</li><li>移除cronjob<br>kubectl delete cronjob hello<br>job running 强制kill 清空所有 hello job container</li></ul><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li>每次都是创建一个新的容器</li><li>任务周期内未执行完,会重新启动一个容器</li><li>Unsupported value: “Always”: supported values: “OnFailure”, “Never”<br>注意Job的RestartPolicy仅支持Never和OnFailure两种，不支持Always，我们知道Job就相当于来执行一个批处理任务，执行完就结束了，如果支持Always的话是不是就陷入了死循环了？<ul><li>OnFailure: 失败重启容器</li><li>Never:失败 Failed</li></ul></li></ul><p><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/#pod-%E7%9A%84%E7%94%9F%E5%91%BD" target="_blank" rel="noopener">pod生命周期</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s Ingress</title>
      <link href="/2019/01/20/k8s-6-ingress/"/>
      <url>/2019/01/20/k8s-6-ingress/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Ingress"><a href="#什么是Ingress" class="headerlink" title="什么是Ingress"></a>什么是Ingress</h1><pre class="line-numbers language-java"><code class="language-java">     internet        <span class="token operator">|</span>   <span class="token punctuation">[</span> Ingress <span class="token punctuation">]</span>   <span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">|</span><span class="token operator">--</span>   <span class="token punctuation">[</span> Services <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Ingress可以配置为提供服务外部可访问的URL，负载平衡流量，SSL，并提供基于名称的虚拟主机。一个入口控制器负责履行入口，通常与负载均衡器，虽然它也可以配置您的边缘路由器或额外的前端，以帮助处理业务。</p><pre class="line-numbers language-java"><code class="language-java">foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>com <span class="token operator">--</span><span class="token operator">|</span>                 <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">></span> foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>com s1<span class="token operator">:</span><span class="token number">80</span>              <span class="token operator">|</span> <span class="token number">178.91</span><span class="token punctuation">.</span><span class="token number">123.132</span>  <span class="token operator">|</span>bar<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>com <span class="token operator">--</span><span class="token operator">|</span>                 <span class="token operator">|</span><span class="token operator">-</span><span class="token operator">></span> bar<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>com s2<span class="token operator">:</span><span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><a id="more"></a><h1 id="Nginx-Ingress-Controller"><a href="#Nginx-Ingress-Controller" class="headerlink" title="Nginx Ingress Controller"></a>Nginx Ingress Controller</h1><p>官方文档参考：<a href="https://kubernetes.github.io/ingress-nginx/deploy/" target="_blank" rel="noopener">https://kubernetes.github.io/ingress-nginx/deploy/</a></p><p>首先部署命名空间，默认后端（处理 404等），配置等，与官方一致。</p><pre class="line-numbers language-部署"><code class="language-部署">curl https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/namespace.yaml| kubectl apply -f -curl https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/default-backend.yaml | kubectl apply -f -curl https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/configmap.yaml| kubectl apply -f -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>接着需要为 RBAC 配置角色和权限：</p><pre><code>curl https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/rbac.yaml| kubectl apply -f -</code></pre><p>Nginx 部署在 master 机器上，使用 master 的入口 ip 提供服务<br>官方文档部署完后仍然需要使用 Service 做转发，在没有 ELB 的情况下仍需使用 NodePort 方式暴露在高端口上</p><pre><code>apiVersion: extensions/v1beta1kind: Ingressmetadata:  name: submodule-checker-ingressspec:  rules:  - host: YOUR.HOST.NAME    http:      paths:      - backend:          serviceName: submodule-checker-service          servicePort: 7777</code></pre><p>配置完成后将域名解析到 k8s 集群的主节点上，即可访问服务内的 pod。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>自动生成nginx config文件； 通过nginx 反向代理到各个service<br>对外出口还是有master机器转发，需要NodePort或者LoadBalancer（NodePort + VIP）</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s CCM</title>
      <link href="/2019/01/20/k8s-7/"/>
      <url>/2019/01/20/k8s-7/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes-Cloud-Controller-Manager"><a href="#Kubernetes-Cloud-Controller-Manager" class="headerlink" title="Kubernetes Cloud Controller Manager"></a>Kubernetes Cloud Controller Manager</h1><p>ccm经历了很大的版本改动，之前版本ccm 开发需要改动K8s源码，版本管理非常麻烦<br>现在的版本中ccm被独立出来只需要实现K8s中的接口，就可以完成功能 这样对升级K8s 就非常轻松了</p><h2 id="service-controller"><a href="#service-controller" class="headerlink" title="service controller"></a>service controller</h2><p>开发service controller 对外提供LoadBalancer</p><h3 id="k8s中service主要有三种："><a href="#k8s中service主要有三种：" class="headerlink" title="k8s中service主要有三种："></a>k8s中service主要有三种：</h3><h5 id="ClusterIP"><a href="#ClusterIP" class="headerlink" title="ClusterIP"></a>ClusterIP</h5><p>use a cluster-internal IP only - this is the default and is discussed above. Choosing this value means that you want this service to be reachable only from inside of the cluster.</p><h5 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h5><p>on top of having a cluster-internal IP, expose the service on a port on each node of the cluster (the same port on each node). You’ll be able to contact the service on any :NodePort address.</p><h5 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h5><p>on top of having a cluster-internal IP and exposing service on a NodePort also, ask the cloud provider for a load balancer which forwards to the Service exposed as a :NodePort for each Node.</p><h3 id="LoadBalancer-调研"><a href="#LoadBalancer-调研" class="headerlink" title="LoadBalancer 调研"></a>LoadBalancer 调研</h3><pre><code>kubectl run nginx --image=registry.aliyuncs.com/acs/netdia:latestkubectl expose deployment nginx --port=80 --target-port=80 --type=LoadBalancer</code></pre><p>k8s已经将svc expose到node上了，可以借助aliyun slb/dns 给所有pod所在机器上bind vip/dns</p><p><strong><em>注意</em></strong>：<br>NodePort LoadBalancer 都需要kube-proxy进行转发</p><p>最优的解决方案：<br>直接借助CNI 网络插件，将pod网络与aliyun vpc打通 <a href="https://github.com/coreos/flannel/blob/master/Documentation/alicloud-vpc-backend-cn.md" target="_blank" rel="noopener">https://github.com/coreos/flannel/blob/master/Documentation/alicloud-vpc-backend-cn.md</a> 在bind vip/dns<br>局限：需要借助vpc网络；bls环境所以经典网络，还是需要借助kube-proxy进行转发</p><h4 id="Aliyun-ccm-实现"><a href="#Aliyun-ccm-实现" class="headerlink" title="Aliyun ccm 实现"></a>Aliyun ccm 实现</h4><p>参考：<br><a href="https://github.com/AliyunContainerService/alicloud-controller-manager" target="_blank" rel="noopener">https://github.com/AliyunContainerService/alicloud-controller-manager</a></p><p>vip 通过kubectl get svc 可以展现<br>dns建议通过annotation扩展例如：</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1<span class="token key atrule">kind</span><span class="token punctuation">:</span> Service<span class="token key atrule">metadata</span><span class="token punctuation">:</span>  <span class="token key atrule">annotations</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 自定义扩展bind DNS功能</span>    <span class="token key atrule">service.beta.kubernetes.io/bind-dns</span><span class="token punctuation">:</span> <span class="token string">"nginx.${REGION}.bls.${INTRANET_DOMAIN}"</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">namespace</span><span class="token punctuation">:</span> default<span class="token key atrule">spec</span><span class="token punctuation">:</span>  <span class="token key atrule">ports</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> TCP    <span class="token key atrule">targetPort</span><span class="token punctuation">:</span> <span class="token number">80</span>  <span class="token key atrule">selector</span><span class="token punctuation">:</span>    <span class="token key atrule">run</span><span class="token punctuation">:</span> nginx  <span class="token key atrule">type</span><span class="token punctuation">:</span> LoadBalancer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开发-amp-部署"><a href="#开发-amp-部署" class="headerlink" title="开发&amp;部署"></a>开发&amp;部署</h2><p>###<br>实现以下接口</p><p><a href="https://github.com/kubernetes/cloud-provider/blob/master/cloud.go" target="_blank" rel="noopener">https://github.com/kubernetes/cloud-provider/blob/master/cloud.go</a></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ol start="2"><li>kubelet 启动 –cloud-provider=external<br>这个会在节点加上污点 node.cloudprovider.kubernetes.io/uninitialized 不可调度<br>直到ccm启动成功会移除这个污点</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/</a><br><a href="https://kubernetes.io/docs/concepts/services-networking/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/services-networking/</a><br><a href="https://jimmysong.io/kubernetes-handbook/practice/service-discovery-and-loadbalancing.html" target="_blank" rel="noopener">https://jimmysong.io/kubernetes-handbook/practice/service-discovery-and-loadbalancing.html</a><br><a href="https://kubernetes.io/docs/concepts/architecture/cloud-controller/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/architecture/cloud-controller/</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s LimitRange</title>
      <link href="/2019/01/19/k8s-5/"/>
      <url>/2019/01/19/k8s-5/</url>
      
        <content type="html"><![CDATA[<p>官方原文：<br><a href="https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/</a></p><p>参考译文：<br><a href="https://yq.aliyun.com/articles/608931" target="_blank" rel="noopener">https://yq.aliyun.com/articles/608931</a></p><pre><code>apiVersion: v1kind: LimitRangemetadata:  name: mylimitsspec:  limits:  - max:      cpu: &quot;4&quot;      memory: 2Gi    min:      cpu: 200m      memory: 6Mi    maxLimitRequestRatio:      cpu: 3      memory: 2    type: Pod  - default:      cpu: 300m      memory: 200Mi    defaultRequest:      cpu: 200m      memory: 100Mi    max:      cpu: &quot;2&quot;      memory: 1Gi    min:      cpu: 100m      memory: 3Mi    maxLimitRequestRatio:      cpu: 5      memory: 4    type: Containe</code></pre><h3 id="pod部分"><a href="#pod部分" class="headerlink" title="pod部分"></a>pod部分</h3><h4 id="max"><a href="#max" class="headerlink" title="max"></a>max</h4><p>表示pod中所有容器资源的Limit值和的上限，也就是整个pod资源的最大Limit，如果pod定义中的Limit值大于LimitRange中的值，则pod无法成功创建。</p><h4 id="min"><a href="#min" class="headerlink" title="min"></a>min</h4><p>表示pod中所有容器资源请求总和的下限，也就是所有容器request的资源总和不能小于min中的值，否则pod无法成功创建。</p><h4 id="maxLimitRequestRatio"><a href="#maxLimitRequestRatio" class="headerlink" title="maxLimitRequestRatio"></a>maxLimitRequestRatio</h4><p>表示pod中所有容器资源请求的Limit值和request值比值的上限，例如该pod中cpu的Limit值为3，而request为0.5，此时比值为6，创建pod将会失败。</p><h3 id="container部分"><a href="#container部分" class="headerlink" title="container部分"></a>container部分</h3><p>max、min和maxLimitRequestRatio的含义和pod中的类似，只不过是针对单个的容器而言。<br>下面说明几个情况：</p><ol><li>如果container设置了max， pod中的容器必须设置limit，如果未设置，则使用defaultlimt的值，如果defaultlimit也没有设置，则无法成功创建</li><li>如果设置了container的min，创建容器的时候必须设置request的值，如果没有设置，则使用defaultrequest，如果没有defaultrequest，则默认等于容器的limit值，如果limit也没有，启动就会报错</li><li>defaultrequest和defaultlimit则是默认值，注意：pod级别没有这两项设置</li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>将limitrange应用于namespace就生效了，例如：</p><pre><code>kubectl create -f limitrange-example.yaml --namespace=namespace-example</code></pre><h2 id="资源”超卖”"><a href="#资源”超卖”" class="headerlink" title="资源”超卖”"></a>资源”超卖”</h2><p>为了提高资源利用率，k8s调度时根据pod 的request值计算调度策略，从而实现节点资源超卖。</p><p>配置一定比例的limit和request达到“超卖”的目的。request用于k8s调度</p><pre><code>  - default:      cpu: 300m      memory: 200Mi    defaultRequest:      cpu: 200m      memory: 100Mi    maxLimitRequestRatio:      cpu: 3      memory: 2</code></pre><p>#参考</p><p>注意的是当节点资源不足k8s会回收资源，回收的先后顺序参考上述链接讲解<a href="https://yq.aliyun.com/articles/608931" target="_blank" rel="noopener">https://yq.aliyun.com/articles/608931</a></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8s 常用命令</title>
      <link href="/2019/01/18/k8s-4/"/>
      <url>/2019/01/18/k8s-4/</url>
      
        <content type="html"><![CDATA[<h1 id="K8s-常用命令"><a href="#K8s-常用命令" class="headerlink" title="K8s 常用命令"></a>K8s 常用命令</h1><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>export version=v1.13.2curl -LO https://storage.googleapis.com/kubernetes-release/release/${version}/bin/linux/amd64/kubectl</code></pre><h1 id="配置本地kubeconfig"><a href="#配置本地kubeconfig" class="headerlink" title="配置本地kubeconfig"></a>配置本地kubeconfig</h1><p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/" target="_blank" rel="noopener">k8s原文 Configure Access to Multiple Clusters</a></p><p>如果有环境部署了可以下载使用</p><pre class="line-numbers language-shell"><code class="language-shell">export KUBECONFIG=$HOME/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>建议设置namespace 不用每次命令后面 -n=test 选择对应的n</strong></p><pre class="line-numbers language-shell"><code class="language-shell">kubectl config set-context test-contex --namespace=testkubectl config use-context test-contex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="终端下kubectl命令自动补全"><a href="#终端下kubectl命令自动补全" class="headerlink" title="终端下kubectl命令自动补全"></a>终端下kubectl命令自动补全</h1><p><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/#using-zsh" target="_blank" rel="noopener">using-zsh</a></p><pre><code>编辑~/.zshrc新增plugins=(kubectl)source &lt;(kubectl completion zsh)</code></pre><p><strong>设置default namespace=bls-db-replica</strong><br><strong>以下命令的所有仅当前namesapce下，node命令除外</strong></p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre class="line-numbers language-shell"><code class="language-shell">#查看所有nodekubectl get node#查看所有deploykubectl get deploy#查看所有podkubectl get po#查看所有pod并显示详细信息kubectl get pods -o wide #使用详细输出来描述命令pods,deployment,replicasets等#kubectl describe <pods> k8s-0004qbmaofgxi5qb0119jc1jm3wl#例如：kubectl describe po k8s-0004qbmaofgxi5qb0119jc1jm3wl#获取某个pod详细信息  json,yaml格式 jsonpathkubectl get po <podId> -o=yaml #bls相关命令#查看pods容器对应的annotations,labelskubectl get po <podId> -o=json|jq .metadata.annotationskubectl get po <podId> -o=json|jq .metadata.labels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h1><p>下表列出的是 kubernetes 中所有支持的类型和缩写的别名</p><table><thead><tr><th>资源类型</th><th>缩写别名</th></tr></thead><tbody><tr><td>clusters</td><td></td></tr><tr><td>componentstatuses</td><td>cs</td></tr><tr><td>configmaps</td><td>cm</td></tr><tr><td>daemonsets</td><td>ds</td></tr><tr><td>deployments</td><td>deploy</td></tr><tr><td>endpoints</td><td>ep</td></tr><tr><td>event</td><td>ev</td></tr><tr><td>horizontalpodautoscalers</td><td>hpa</td></tr><tr><td>ingresses</td><td>ing</td></tr><tr><td>jobs</td><td></td></tr><tr><td>limitranges</td><td>limits</td></tr><tr><td>namespaces</td><td>ns</td></tr><tr><td>networkpolicies</td><td></td></tr><tr><td>nodes</td><td>no</td></tr><tr><td>statefulsets</td><td></td></tr><tr><td>persistentvolumeclaims</td><td>pvc</td></tr><tr><td>persistentvolumes</td><td>pv</td></tr><tr><td>pods</td><td>po</td></tr><tr><td>podsecuritypolicies</td><td>psp</td></tr><tr><td>podtemplates</td><td></td></tr><tr><td>replicasets</td><td>rs</td></tr><tr><td>replicationcontrollers</td><td>rc</td></tr><tr><td>resourcequotas</td><td>quota</td></tr><tr><td>cronjob</td><td></td></tr><tr><td>secrets</td><td></td></tr><tr><td>serviceaccount</td><td>sa</td></tr><tr><td>services</td><td>svc</td></tr><tr><td>storageclasses</td><td></td></tr><tr><td>thirdpartyresources</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm 容器化启动</title>
      <link href="/2019/01/06/k8s-install-part4/"/>
      <url>/2019/01/06/k8s-install-part4/</url>
      
        <content type="html"><![CDATA[<h1 id="kubeadm-容器化启动"><a href="#kubeadm-容器化启动" class="headerlink" title="kubeadm 容器化启动"></a>kubeadm 容器化启动</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我们已经容器化Kubelet 接下来修改kubeadm 代码</p><h1 id="修改核心代码"><a href="#修改核心代码" class="headerlink" title="修改核心代码"></a>修改核心代码</h1><h2 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h2><h3 id="cmd-kubeadm-app-cmd-phases-preflight-go"><a href="#cmd-kubeadm-app-cmd-phases-preflight-go" class="headerlink" title="cmd/kubeadm/app/cmd/phases/preflight.go"></a>cmd/kubeadm/app/cmd/phases/preflight.go</h3><a id="more"></a><pre><code>-    if !data.DryRun() {-        fmt.Println(&quot;[preflight] Pulling images required for setting up a Kubernetes cluster&quot;)-        fmt.Println(&quot;[preflight] This might take a minute or two, depending on the speed of your internet connection&quot;)-        fmt.Println(&quot;[preflight] You can also perform this action in beforehand using &#39;kubeadm config images pull&#39;&quot;)-        if err := preflight.RunPullImagesCheck(utilsexec.New(), data.Cfg(), data.IgnorePreflightErrors()); err != nil {-            return err-        }-    } else {-        fmt.Println(&quot;[preflight] Would pull the required images (like &#39;kubeadm config images pull&#39;)&quot;)-    }+    //if !data.DryRun() {+    //    fmt.Println(&quot;[preflight] Pulling images required for setting up a Kubernetes cluster&quot;)+    //    fmt.Println(&quot;[preflight] This might take a minute or two, depending on the speed of your internet connection&quot;)+    //    fmt.Println(&quot;[preflight] You can also perform this action in beforehand using &#39;kubeadm config images pull&#39;&quot;)+    //    if err := preflight.RunPullImagesCheck(utilsexec.New(), data.Cfg(), data.IgnorePreflightErrors()); err != nil {+    //        return err+    //    }+    //} else {+    //    fmt.Println(&quot;[preflight] Would pull the required images (like &#39;kubeadm config images pull&#39;)&quot;)+    //}</code></pre><h3 id="cmd-kubeadm-app-phases-kubelet-kubelet-go"><a href="#cmd-kubeadm-app-phases-kubelet-kubelet-go" class="headerlink" title="cmd/kubeadm/app/phases/kubelet/kubelet.go"></a>cmd/kubeadm/app/phases/kubelet/kubelet.go</h3><pre><code>// TryStartKubelet attempts to bring up kubelet service func TryStartKubelet() {     // If we notice that the kubelet service is inactive, try to start it-    initSystem, err := initsystem.GetInitSystem()+    //initSystem, err := initsystem.GetInitSystem()+    //if err != nil {+    //    fmt.Println(&quot;[kubelet-start] no supported init system detected, won&#39;t make sure the kubelet is running properly.&quot;)+    //    return+    //}+    //+    //if !initSystem.ServiceExists(&quot;kubelet&quot;) {+    //    fmt.Println(&quot;[kubelet-start] couldn&#39;t detect a kubelet service, can&#39;t make sure the kubelet is running properly.&quot;)+    //}+    //+    //fmt.Println(&quot;[kubelet-start] Activating the kubelet service&quot;)+    //// This runs &quot;systemctl daemon-reload &amp;&amp; systemctl restart kubelet&quot;+    //if err := initSystem.ServiceRestart(&quot;kubelet&quot;); err != nil {+    //    fmt.Printf(&quot;[kubelet-start] WARNING: unable to start the kubelet service: [%v]\n&quot;, err)+    //    fmt.Printf(&quot;[kubelet-start] please ensure kubelet is reloaded and running manually.\n&quot;)+    //}++    fmt.Println(&quot;[init] TryStartKubelet init&quot;)+    ctx := context.Background()+    cli, err := client.NewEnvClient()     if err != nil {-        fmt.Println(&quot;[kubelet-start] no supported init system detected, won&#39;t make sure the kubelet is running properly.&quot;)-        return+        panic(err)     }+    info, err := cli.Info(ctx)+    if err != nil {+        panic(err)+    }+    dockerGraph := info.DockerRootDir+    fmt.Println(&quot;[init] dockerGraph: &quot; + dockerGraph)-    if !initSystem.ServiceExists(&quot;kubelet&quot;) {-        fmt.Println(&quot;[kubelet-start] couldn&#39;t detect a kubelet service, can&#39;t make sure the kubelet is running properly.&quot;)+    var (+        imageHyperkube string+        imagePause     string+    )+    /*if dockerGraph = os.Getenv(&quot;DOCKER_GRAPH&quot;); dockerGraph == &quot;&quot; {+        dockerGraph = &quot;/disk1/docker&quot;+    }*/+    if imageHyperkube = os.Getenv(&quot;IMAGE_K8S_HYPERKUBE&quot;); imageHyperkube == &quot;&quot; {+        imageHyperkube = &quot;bamboo/k8s-gcr-io/kubelet:v1.13.2&quot;+    }+    if imagePause = os.Getenv(&quot;IMAGE_K8S_PAUSE&quot;); imagePause == &quot;&quot; {+        imagePause = &quot;bamboo/k8s-gcr-io/pause:3.1&quot;     }-    fmt.Println(&quot;[kubelet-start] Activating the kubelet service&quot;)-    // This runs &quot;systemctl daemon-reload &amp;&amp; systemctl restart kubelet&quot;-    if err := initSystem.ServiceRestart(&quot;kubelet&quot;); err != nil {-        fmt.Printf(&quot;[kubelet-start] WARNING: unable to start the kubelet service: [%v]\n&quot;, err)-        fmt.Printf(&quot;[kubelet-start] please ensure kubelet is reloaded and running manually.\n&quot;)+    labels := make(map[string]string)+    labels[&quot;k8s.master.role&quot;] = &quot;kubelet&quot;+    for _, env := range os.Environ() {+        envArr := strings.Split(env, &quot;=&quot;)+        if strings.HasPrefix(envArr[0], &quot;KUBELET_LABEL_&quot;) {+            labels[strings.Replace(envArr[0], &quot;KUBELET_LABEL_&quot;, &quot;&quot;, 1)] = envArr[1]+        }+    }+    //kubelets specifying --cloud-provider=external will add a taint node.cloudprovider.kubernetes.io/uninitialized with an effect NoSchedule during initialization. This marks the node as needing a second initialization from an external controller before it can be scheduled work. Note that in the event that cloud controller manager is not available, new nodes in the cluster will be left unschedulable. The taint is important since the scheduler may require cloud specific information about nodes such as their region or type (high cpu, gpu, high memory, spot instance, etc).+    //default+    kubeletCmd := []string{+        &quot;--config=/var/lib/kubelet/config.yaml&quot;,+        &quot;--bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf&quot;,+        &quot;--kubeconfig=/etc/kubernetes/kubelet.conf&quot;,+        &quot;--pod-infra-container-image=&quot; + imagePause,+        &quot;--fail-swap-on=false&quot;,+        &quot;--cni-bin-dir=/opt/cni/bin&quot;,+        &quot;--cni-conf-dir=/etc/cni/net.d&quot;,+        &quot;--network-plugin=cni&quot;,+        &quot;--v=5&quot;,     }-}-// TryStopKubelet attempts to bring down the kubelet service momentarily-func TryStopKubelet() {-    // If we notice that the kubelet service is inactive, try to start it-    initSystem, err := initsystem.GetInitSystem()-    if err != nil {-        fmt.Println(&quot;[kubelet-start] no supported init system detected, won&#39;t make sure the kubelet not running for a short period of time while setting up configuration for it.&quot;)+    enableCCM := os.Getenv(&quot;ENABLE_CCM&quot;)+    if strings.ToUpper(enableCCM) == &quot;TRUE&quot; {+        kubeletCmd = append(kubeletCmd, &quot;--cloud-provider=external&quot;)+    }++    kubeletCmdEnv := os.Getenv(&quot;KUBELET_CMD&quot;)+    if kubeletCmdEnv != &quot;&quot; {+        kubeletCmd = strings.Split(kubeletCmdEnv, &quot; &quot;)+    }++    //+    filters := filters.NewArgs()+    filters.Add(&quot;name&quot;, &quot;kubelet&quot;)+    filters.Add(&quot;label&quot;, &quot;k8s_master_role=kubelet&quot;)+    containers, e := cli.ContainerList(ctx, types.ContainerListOptions{Filters: filters,})+    if e != nil {+        panic(err)+    }++    if len(containers) &gt; 0 {+        timeout := 100 * time.Second+        // force update+        forceUpdate := os.Getenv(&quot;FORCE_UPDATE&quot;)+        if strings.ToUpper(forceUpdate) == &quot;TRUE&quot; {+            fmt.Printf(&quot;[init] force update remove containers: %s \n&quot;, containers[0].ID)+            cli.ContainerRemove(ctx, containers[0].ID, types.ContainerRemoveOptions{+                //RemoveVolumes: true,+                Force: true,+            })+        } else {+            fmt.Printf(&quot;[init] Restart containers: %s \n&quot;, containers[0].ID)+            cli.ContainerRestart(ctx, containers[0].ID, &amp;timeout)+        }         return+    }else{+        fmt.Printf(&quot;[init] not found kubelet after create it. \n&quot;)+    }++    out, err := cli.ImagePull(ctx, imageHyperkube, types.ImagePullOptions{})+    if err != nil {+        panic(err)     }+    fmt.Printf(&quot;[init] pull imageName: %s \n&quot;, imageHyperkube)+    io.Copy(os.Stdout, out)-    if !initSystem.ServiceExists(&quot;kubelet&quot;) {-        fmt.Println(&quot;[kubelet-start] couldn&#39;t detect a kubelet service, can&#39;t make sure the kubelet not running for a short period of time while setting up configuration for it.&quot;)+    resp, err := cli.ContainerCreate(ctx, &amp;container.Config{+        Image:  imageHyperkube,+        Cmd:    kubeletCmd,+        Labels: labels,+        Env: []string{+            &quot;DOCKER_GRAPH=&quot; + dockerGraph,+        },+    }, &amp;container.HostConfig{+        NetworkMode: &quot;host&quot;,+        PidMode:     &quot;host&quot;,+        IpcMode:     &quot;host&quot;,+        Privileged:  true,+        RestartPolicy: container.RestartPolicy{+            Name: &quot;always&quot;,+        },+        Binds: []string{+            &quot;/var/log:/var/log:shared&quot;,+            dockerGraph + &quot;:&quot; + dockerGraph + &quot;:rw&quot;,+            &quot;/etc/kubernetes:/etc/kubernetes&quot;,+            &quot;/var/lib/calico:/var/lib/calico&quot;,+            &quot;/etc/cni:/etc/cni&quot;,+            &quot;/opt/cni:/opt/cni&quot;,+            &quot;/etc/ssl:/etc/ssl&quot;,+            &quot;/var/lib/kubelet:/var/lib/kubelet:shared&quot;,+            &quot;/var/lib/cni:/var/lib/cni&quot;,+            &quot;/var/run:/var/run&quot;,+            &quot;/etc/pki/tls:/etc/pki/tls&quot;,+            &quot;/etc/resolv.conf:/etc/resolv.conf&quot;,+            &quot;/etc/machine-id:/etc/machine-id&quot;,+        },+    }, nil, &quot;kubelet&quot;)+    if err != nil {+        panic(err)     }-    // This runs &quot;systemctl daemon-reload &amp;&amp; systemctl stop kubelet&quot;-    if err := initSystem.ServiceStop(&quot;kubelet&quot;); err != nil {-        fmt.Printf(&quot;[kubelet-start] WARNING: unable to stop the kubelet service momentarily: [%v]\n&quot;, err)+    if err := cli.ContainerStart(ctx, resp.ID, types.ContainerStartOptions{}); err != nil {+        panic(err)     }++    fmt.Printf(&quot;[init] TryStartKubelet: %s \n&quot;, resp.ID)+}++// TryStopKubelet attempts to bring down the kubelet service momentarily+func TryStopKubelet() {+    // If we notice that the kubelet service is inactive, try to start it+    //initSystem, err := initsystem.GetInitSystem()+    //if err != nil {+    //    fmt.Println(&quot;[kubelet-start] no supported init system detected, won&#39;t make sure the kubelet not running for a short period of time while setting up configuration for it.&quot;)+    //    return+    //}+    //+    //if !initSystem.ServiceExists(&quot;kubelet&quot;) {+    //    fmt.Println(&quot;[kubelet-start] couldn&#39;t detect a kubelet service, can&#39;t make sure the kubelet not running for a short period of time while setting up configuration for it.&quot;)+    //}+    //+    //// This runs &quot;systemctl daemon-reload &amp;&amp; systemctl stop kubelet&quot;+    //if err := initSystem.ServiceStop(&quot;kubelet&quot;); err != nil {+    //    fmt.Printf(&quot;[kubelet-start] WARNING: unable to stop the kubelet service momentarily: [%v]\n&quot;, err)+    //} }</code></pre><h2 id="kubeadm-join"><a href="#kubeadm-join" class="headerlink" title="kubeadm join"></a>kubeadm join</h2><h3 id="cmd-kubeadm-app-cmd-join-go"><a href="#cmd-kubeadm-app-cmd-join-go" class="headerlink" title="cmd/kubeadm/app/cmd/join.go"></a>cmd/kubeadm/app/cmd/join.go</h3><pre><code>-    kubeletVersion, err := preflight.GetKubeletVersion(utilsexec.New())+    //kubeletVersion, err := preflight.GetKubeletVersion(utilsexec.New())+    kubeletVersion, err := version.ParseSemantic(&quot;v1.13.2&quot;)-    kubeletphase.TryStopKubelet()+    //kubeletphase.TryStopKubelet()</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>至此kubeadm就可以和之前一样使用了，容器化部署</p><p>然后将kubeadm 制作成 k8s-bootstrap image<br>就可以任意部署K8s node</p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubelet 容器化</title>
      <link href="/2019/01/05/k8s-install-part3/"/>
      <url>/2019/01/05/k8s-install-part3/</url>
      
        <content type="html"><![CDATA[<h1 id="kubelet-容器化"><a href="#kubelet-容器化" class="headerlink" title="kubelet 容器化"></a>kubelet 容器化</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>K8s 所有组件中唯一没有容器化的就是Kubelet</p><h2 id="问题-为什么Kubelet没有容器化，能不能容器化"><a href="#问题-为什么Kubelet没有容器化，能不能容器化" class="headerlink" title="问题 为什么Kubelet没有容器化，能不能容器化"></a>问题 为什么Kubelet没有容器化，能不能容器化</h2><ol><li>Kubelet 需要与宿主很多交互，储存，网络，主机性能数据等</li><li>Kubelet 是K8s核心组件，apiserver ,controller-manager,schedule,  都是static pod 由kubelet启动</li></ol><p>当是这些并不能阻碍容器化 –net=host  –pid=host  –privileged=true 可以解决<br>然后是存储 –v /:/ 挂载宿主机所有目录进去 （此处有点小坑后面会提到）</p><p>可能考虑到K8s整体设计 不需要关系是哪种runtime ,无论是docker，Pouch，kata 他都是支持的<br>如果kubelet没有run on host 更换runtime kubelete都需要改动</p><p>因为我们目前只会跑到docker上所有我们尝试去容器化它，build docker image</p><h3 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h3><p>Container Runtime实现了CRI gRPC Server，包括RuntimeService和ImageService。该gRPC Server需要监听本地的Unix socket，而kubelet则作为gRPC Client运行。</p><p><img src="cri-architecture.png" alt=""></p><p>除非集成了rktnetes，否则CRI都是被默认启用了，从Kubernetes1.7版本开始，旧的预集成的docker CRI已经被移除。</p><p>要想启用CRI只需要在kubelet的启动参数重传入此参数：–container-runtime-endpoint远程运行时服务的端点。当前Linux上支持unix socket，windows上支持tcp。例如：unix:///var/run/dockershim.sock、 tcp://localhost:373，默认是unix:///var/run/dockershim.sock，即默认使用本地的docker作为容器运行时。</p><h1 id="尝试容器化"><a href="#尝试容器化" class="headerlink" title="尝试容器化"></a>尝试容器化</h1><a id="more"></a><h2 id="构建image"><a href="#构建image" class="headerlink" title="构建image"></a>构建image</h2><pre><code>FROM k8s.gcr.io/debian-base-amd64:0.4.1STOPSIGNAL SIGRTMIN+3LABEL mirantis.kubeadm_dind_cluster=1ENV ARCH amd64ENV CRICTL_VERSION=v1.12.0ENV CRICTL_SHA256=e7d913bcce40bf54e37ab1d4b75013c823d0551e6bc088b217bc1893207b4844ENV CNI_VERSION=v0.7.1ENV CNI_ARCHIVE=cni-plugins-&quot;${ARCH}&quot;-&quot;${CNI_VERSION}&quot;.tgzENV CNI_SHA1=fb29e20401d3e9598a1d8e8d7992970a36de5e05# Specify CONTAINERD_VERSION if containerd which ships with Docker needs to be# replaced. Note that containerd version must be specified w/o &quot;v&quot; prefix,# e.g. v1.2.1ENV CONTAINERD_VERSION=1.2.1ENV CONTAINERD_SHA256=9818e3af4f9aac8d55fc3f66114346db1d1acd48d45f88b2cefd3d3bafb380e0# make systemd behave correctly in Docker container# (e.g. accept systemd.setenv args, etc.)ENV container dockerARG DEBIAN_FRONTEND=noninteractiveRUN clean-install \    apt-transport-https \    bash \    bridge-utils \    ca-certificates \    curl \    e2fsprogs \    ebtables \    ethtool \    gnupg2 \    ipcalc \    iptables \    iproute2 \    iputils-ping \    ipset \    ipvsadm \    jq \    kmod \    lsb-core \    less \    lzma \    liblz4-tool \    mount \    net-tools \    procps \    socat \    software-properties-common \    util-linux \    vim \    systemd \    systemd-sysv \    sysvinit-utilsHEALTHCHECK --interval=10s --timeout=3s --start-period=15s \    CMD curl -f http://127.0.0.1:10256/healthz 2&gt;/dev/null || exit 1# Install docker.RUN curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add - &amp;&amp; apt-key fingerprint 0EBFCD88 &amp;&amp; add-apt-repository \    &quot;deb [arch=amd64] https://download.docker.com/linux/debian \    $(lsb_release -cs) \    stable&quot;RUN clean-install docker-ce=17.03.2~ce-0~debian-stretchARG full_kubectl_version=v1.13.1ARG kubectl_os=linuxENV path=/k8sCOPY kubelet.service /lib/systemd/system/COPY docker.service /lib/systemd/system/docker.serviceCOPY rundocker /usr/local/binRUN mkdir -p ${path} &amp;&amp; curl -sSLo &quot;${path}/kubelet&quot; &quot;https://storage.googleapis.com/kubernetes-release/release/${full_kubectl_version}/bin/${kubectl_os}/amd64/kubelet&quot; &amp;&amp; chmod +x ${path}/kubeletCOPY /run.sh /ENTRYPOINT [&quot;/run.sh&quot;]</code></pre><pre><code>https://github.com/kubernetes-sigs/kubeadm-dind-cluster/blob/master/image/kubelet.service</code></pre><pre><code>https://github.com/kubernetes-sigs/kubeadm-dind-cluster/blob/master/image/docker.service</code></pre><pre class="line-numbers language-docker"><code class="language-docker">docker build <span class="token punctuation">-</span>t bamboo/kubelet .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><ol><li>当我们删除某些容器，有时候会报出device or resource busy错误：</li></ol><pre><code>Error response from daemon:Unable to remove filesystem fora9a1c11e8210d60ddba09f95ea93ae21f32327c4e5877c218862c752d1088533: remove /var/lib/docker/containers/a9a1c11e8210d60ddba09f95ea93ae21f32327c4e5877c218862c752d1088533/shm:device or resource busy</code></pre><p>原因分析<br>通常我们看到device or resource busy首先想到的是，这个设备被其他程序占用导致。 在容器中，其实理论是一样的，每个容器生成都会有一个containers//shm设备产生， 恰巧这个设备被其他程序mount了，就会被占用无法卸载，也就是device or resource busy。</p><p>那么什么情况下会占用containers//shm设备呢？其最大的可能原因就是容器启动时挂载了/var/lib/docker目录， 此时恰巧docker出现了bug，顺带mount了containers//shm设备。 为证实猜想，我们启动一个挂载/var/lib/docker目录的容器，然后到容器中查看/proc/mounts，如下：</p><p><img src="busy_01.jpg" alt=""></p><p>修复方式</p><pre class="line-numbers language-run.sh"><code class="language-run.sh">#!/bin/bashecho $DOCKER_GRAPHfor i in $DOCKER_GRAPH; do    for m in $(tac /proc/mounts | awk '{print $2}' | grep ^${i}/); do        umount $m || true    donedoneecho $@/k8s/kubelet $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>Unable to handle cpuacct.stat when there are 6 fields</li></ol><p>打开K8s源码定位到报错function</p><p>vendor/github.com/opencontainers/runc/libcontainer/cgroups/fs/cpuacct.go:72</p><p>排查问题</p><pre><code>#cat /sys/fs/cgroup/cpuacct/cpuacct.statuser 8634978system 11319890nr_migrations 258883801</code></pre><p>opencontainers/runc issues：</p><p><a href="https://github.com/opencontainers/runc/issues/1844" target="_blank" rel="noopener">https://github.com/opencontainers/runc/issues/1844</a></p><p>修改代码：</p><pre><code>if len(fields) &lt; 4 {        return 0, 0, fmt.Errorf(&quot;failure - %s is expected to have 4 fields&quot;, filepath.Join(path, cgroupCpuacctStat))    }</code></pre><p>重新编译K8s 源码</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>build/run.sh make all or make kubelet</p><p>修改 build/common.sh<br>#kube::version::save_version_vars “${KUBE_ROOT}/.dockerized-kube-version-defs”<br>修改 .dockerized-kube-version-defs</p><p>KUBE_GIT_COMMIT=’151be6d1c8c8d3d0854474311320ec90c76cdb25’<br>KUBE_GIT_TREE_STATE=’dirty’<br>KUBE_GIT_VERSION=’v1.13.0-x’<br>KUBE_GIT_MAJOR=’1’<br>KUBE_GIT_MINOR=’13’</p><p>output:<br>_output/dockerized/bin/linux/amd64</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre><code>docker run -d \    --net=host \    --pid=host \    --privileged \    --name kube-master \    -l mirantis.kubeadm_dind_cluster   \    -v /var/lib/kubelet:/var/lib/kubelet:shared \    -v /var/run:/var/run:rw \    -v /etc/kubernetes:/etc/kubernetes:ro \    -v /etc/pki:/etc/pki:ro \    bamboo/kubelet  \    /k8s/kubelet --config=/var/lib/kubelet/config.yaml \                 --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf \                 --kubeconfig=/etc/kubernetes/kubelet.conf  \                 --pod-infra-container-image=bamboo/k8s-gcr-io/pause:3.1 \                 --fail-swap-on=false \                 --cni-bin-dir=/opt/cni/bin \                 --cni-conf-dir=/etc/cni/net.d \                 --network-plugin=cni \                 --v=5 \                 --node-ip=11.239.162.215 \                 --cloud-provider=external \</code></pre><p>–cloud-provider=external  这个参数可以去掉 ccm时需要用到</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/kubernetes-sigs/kubeadm-dind-cluster" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/kubeadm-dind-cluster</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s bootstrap by kubeadm</title>
      <link href="/2019/01/03/k8s-install-part2/"/>
      <url>/2019/01/03/k8s-install-part2/</url>
      
        <content type="html"><![CDATA[<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://kubernetes.io/docs/setup/independent/ha-topology" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/independent/ha-topology</a></li><li><a href="https://kubernetes.io/docs/setup/independent/setup-ha-etcd-with-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/independent/setup-ha-etcd-with-kubeadm/</a></li></ul><h1 id="部署高可用集群"><a href="#部署高可用集群" class="headerlink" title="部署高可用集群"></a>部署高可用集群</h1><p>kubeadm init  # 创建一个Master节点<br>kubeadm join  # 创建一个Node节点</p><p>K8s 需要Etcd存储数据</p><h1 id="Stacked-etcd-topology"><a href="#Stacked-etcd-topology" class="headerlink" title="Stacked etcd topology"></a>Stacked etcd topology</h1><p><img src="https://d33wubrfki0l68.cloudfront.net/d1411cded83856552f37911eb4522d9887ca4e83/b94b2/images/kubeadm/kubeadm-ha-topology-stacked-etcd.svg" alt=""></p><p>多个Master绑定VIP,需要借助外部的LB<br>Node节点链接VIP</p><p><strong>注意: kubernetes 1.13 支持</strong><br><strong>kubeadm join –experimental-control-plane</strong><br><strong>新增的Master节点的etcd自动加入已有的Master节点上的集群中</strong></p><a id="more"></a><h1 id="External-etcd-topology"><a href="#External-etcd-topology" class="headerlink" title="External etcd topology"></a>External etcd topology</h1><p><img src="https://d33wubrfki0l68.cloudfront.net/ad49fffce42d5a35ae0d0cc1186b97209d86b99c/5a6ae/images/kubeadm/kubeadm-ha-topology-external-etcd.svg" alt=""></p><h1 id="kubeadm"><a href="#kubeadm" class="headerlink" title="kubeadm"></a>kubeadm</h1><ul><li>kubeadm init # to bootstrap a Kubernetes control-plane node</li><li>kubeadm join # to bootstrap a Kubernetes worker node and join it to the cluster</li><li>kubeadm upgrade # to upgrade a Kubernetes cluster to a newer version</li><li>kubeadm config # if you initialized your cluster using kubeadm v1.7.x or lower, to configure your cluster for kubeadm upgrade</li><li>kubeadm token # to manage tokens for kubeadm join</li><li>kubeadm reset # to revert any changes made to this host by kubeadm init or kubeadm join</li><li>kubeadm version # to print the kubeadm version</li><li>kubeadm alpha # to preview a set of features made available for gathering feedback from the community</li></ul><h2 id="kubeadm-configure"><a href="#kubeadm-configure" class="headerlink" title="kubeadm configure"></a>kubeadm configure</h2><p>It’s possible to configure kubeadm init with a configuration file instead of command line flags, and some more advanced features may only be available as configuration file options. This file is passed in the –config option.</p><pre><code>apiVersion: kubeadm.k8s.io/v1alpha1kind: MasterConfigurationapi:  advertiseAddress: &lt;address|string&gt;  controlPlaneEndpoint: &lt;string&gt;  bindPort: &lt;int&gt;etcd:  endpoints:  - &lt;endpoint1|string&gt;  - &lt;endpoint2|string&gt;  caFile: &lt;path|string&gt;  certFile: &lt;path|string&gt;  keyFile: &lt;path|string&gt;  dataDir: &lt;path|string&gt;  extraArgs:    &lt;argument&gt;: &lt;value|string&gt;    &lt;argument&gt;: &lt;value|string&gt;  image: &lt;string&gt;  serverCertSANs:  - &lt;name1|string&gt;  - &lt;name2|string&gt;  peerCertSANs:  - &lt;name1|string&gt;  - &lt;name2|string&gt;kubeProxy:  config:    mode: &lt;value|string&gt;    bindAddress: &lt;address|string&gt;    clusterCIDR: &lt;cidr&gt;networking:  dnsDomain: &lt;string&gt;  serviceSubnet: &lt;cidr&gt;  podSubnet: &lt;cidr&gt;kubernetesVersion: &lt;string&gt;cloudProvider: &lt;string&gt;nodeName: &lt;string&gt;authorizationModes:- &lt;authorizationMode1|string&gt;- &lt;authorizationMode2|string&gt;token: &lt;string&gt;tokenTTL: &lt;time duration&gt;selfHosted: &lt;bool&gt;apiServerExtraArgs:  &lt;argument&gt;: &lt;value|string&gt;  &lt;argument&gt;: &lt;value|string&gt;controllerManagerExtraArgs:  &lt;argument&gt;: &lt;value|string&gt;  &lt;argument&gt;: &lt;value|string&gt;schedulerExtraArgs:  &lt;argument&gt;: &lt;value|string&gt;  &lt;argument&gt;: &lt;value|string&gt;apiServerExtraVolumes:- name: &lt;value|string&gt;  hostPath: &lt;value|string&gt;  mountPath: &lt;value|string&gt;controllerManagerExtraVolumes:- name: &lt;value|string&gt;  hostPath: &lt;value|string&gt;  mountPath: &lt;value|string&gt;schedulerExtraVolumes:- name: &lt;value|string&gt;  hostPath: &lt;value|string&gt;  mountPath: &lt;value|string&gt;apiServerCertSANs:- &lt;name1|string&gt;- &lt;name2|string&gt;certificatesDir: &lt;string&gt;imageRepository: &lt;string&gt;unifiedControlPlaneImage: &lt;string&gt;featureGates:  &lt;feature&gt;: &lt;bool&gt;  &lt;feature&gt;: &lt;bool&gt;</code></pre><p><strong>注意v1.13有改动</strong><br><strong>使用kubeadm config migrate迁移升级 **<br>**<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-config/#cmd-config-migrate" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-config/#cmd-config-migrate</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s bootstrap by kind</title>
      <link href="/2019/01/01/k8s-install-part1/"/>
      <url>/2019/01/01/k8s-install-part1/</url>
      
        <content type="html"><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>kind is a tool for running local Kubernetes clusters using Docker container “nodes”.</p><h2 id="kind-k-ubernetes-in-d-ocker"><a href="#kind-k-ubernetes-in-d-ocker" class="headerlink" title="kind (k ubernetes in d ocker)"></a>kind (k ubernetes in d ocker)</h2><p><a href="https://github.com/kubernetes-sigs/" target="_blank" rel="noopener">https://github.com/kubernetes-sigs/</a></p><p>依赖: go docker</p><a id="more"></a><h3 id="安装kind"><a href="#安装kind" class="headerlink" title="安装kind"></a>安装kind</h3><pre><code>go get -u sigs.k8s.io/kind</code></pre><h3 id="创建local-cluster"><a href="#创建local-cluster" class="headerlink" title="创建local cluster"></a>创建local cluster</h3><pre><code>kind create clusterCreating cluster &quot;kind&quot; ... ✓ Ensuring node image (kindest/node:v1.13.3) 🖼  ✓ Preparing nodes 📦  ✓ Creating kubeadm config 📜  ✓ Starting control-plane 🕹️ Cluster creation complete. You can now use the cluster with:</code></pre><h3 id="链接K8s"><a href="#链接K8s" class="headerlink" title="链接K8s"></a>链接K8s</h3><pre><code>export KUBECONFIG=&quot;$(kind get kubeconfig-path --name=&quot;kind&quot;)&quot;kubectl cluster-info</code></pre><p>一个简单的K8s 环境就启动了</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://kind.sigs.k8s.io/docs/user/quick-start/" target="_blank" rel="noopener">https://kind.sigs.k8s.io/docs/user/quick-start/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之Fabric模块</title>
      <link href="/2018/04/21/python-fab/"/>
      <url>/2018/04/21/python-fab/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Fabric是基于Python实现的SSH命令行工具，简化了SSH的应用程序部署及系统管理任务，它提供了系统基础的操作组件，可以实现本地或远程shell命令，包括：命令执行、文件上传、下载及完整执行日志输出等功能。Fabric在Paramiko的基础上做了更高一层的封装，操作起来会更加简单。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>fab [options] <command>[:arg1,arg2=val2,host=foo,hosts=’h1;h2’,…] …</p><pre><code>-l     #显示定义好的任务函数名-f     #指定fab入口文件，默认入口文件名为fabfile.py-f     #指定网关（中转）设备，比如堡垒机环境，填写堡垒机IP即可-H     #指定目标主机，多台主机用‘,’号分隔-p     #远程账号的密码，fab执行时默认使用root账户-P     #以异步并行方式运行多主机任务，默认为串行运行-R     #指定role（角色），以角色名区分不同业务组设备-t     #设置设备连接超时时间（秒）-T     #设置远程主机命令执行超时时间（秒）-w     #当命令执行失败，发出警告，而非默认中止任务。</code></pre><a id="more"></a><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>编写一个fabfile.py文件<br>vim fabfile.py</p><pre><code>#!/usr/bin/env python# -*- coding:utf-8 -*-from fabric.api import run#定义一个任务函数，通过run方法实现远程执行‘uname -s’命令def host_type():           run(&#39;uname -s&#39;)</code></pre><p>fab命令操作：</p><pre><code>fab -H localhost host_type #结果：[localhost] Executing task &#39;host_type&#39;[localhost] run: uname -s[localhost] Login password for &#39;root&#39;: [localhost] out: Linux[localhost] out: Done.Disconnecting from localhost... done.</code></pre><p>上面实例也可以写成一行代码：</p><pre><code>fab -p 123456 -H localhost  --  &#39;uname -s&#39;   #--后面要加空格</code></pre><h3 id="fabfile文件的编写"><a href="#fabfile文件的编写" class="headerlink" title="fabfile文件的编写"></a>fabfile文件的编写</h3><p>fab命令是结合fabfile.py文件（其他文件通过-f filename 参数来引用）来搭配使用的。fab的部分命令行参数还能通过相应的方法来代替</p><pre><code>fab -H 192.168.1.21,192.168.1.22 ... ...#可以在fabfile.py文件中用env.hosts来实现，命令行中就可以不用写了#可以在fabfile中这么写：env.hosts = [&#39;192.168.1.21&#39;,&#39;192.168.1.22&#39;]</code></pre><h3 id="fabfile之env对象"><a href="#fabfile之env对象" class="headerlink" title="fabfile之env对象"></a>fabfile之env对象</h3><p>env对象的作用是定义fabfile的全局设定，就像上面的举例。下面对各属性进行说明：</p><pre><code>env.hosts   #定义目标主机，可以用IP或主机名表示，以python的列表形式定义。如env.hosts=[&#39;192.168.1.21&#39;,&#39;192.168.1.22&#39;]env.exclude_hosts   #排除指定主机，如env.exclude_hosts=[&#39;192.168.1.21&#39;]env.user   #定义用户名，如env.user=&#39;root&#39;env.port   #定义端口，默认为22，如env.port=&#39;22&#39;env.password   #定义密码，如env.password=&#39;123456&#39;env.passwords  #定义多个密码，不同主机对应不同密码，如：env.passwords = {&#39;root@192.168.1.21:22&#39;:&#39;123456&#39;,&#39;root@192.168.1.22:22&#39;:&#39;654321&#39;}env.gateway   #定义网关（中转、堡垒机）IP，如env.gateway=&#39;192.168.1.23env.roledefs   #定义角色分组，比如web组合db组主机区分开来：env.roledefs = {&#39;webserver&#39;:[&#39;192.168.1.21&#39;,&#39;192.168.1.22&#39;],&#39;dbserver&#39;:[&#39;192.168.1.25&#39;,&#39;192.168.1.26&#39;]}env.deploy_release_dir   #自定义全局变量，格式：env. + &#39;变量名称&#39;，如env.age,env.sex等</code></pre><h3 id="env-roledefs的使用方法实例"><a href="#env-roledefs的使用方法实例" class="headerlink" title="env.roledefs的使用方法实例"></a>env.roledefs的使用方法实例</h3><pre><code>env.roledefs = {&#39;webserver&#39;:[&#39;192.168.1.21&#39;,&#39;192.168.1.22&#39;],&#39;dbserver&#39;:[&#39;192.168.1.25&#39;,&#39;192.168.1.26&#39;]}#引用分组时使用python装饰器方式来进行,如：@roles(&#39;webserver&#39;)def webtask():    run(&#39;/usr/local/nginx/sbin/nginx&#39;)@roles(&#39;webserver&#39;,&#39;dbserver&#39;)def publictask():    run(&#39;uptime&#39;)</code></pre><h2 id="Fabric常用API"><a href="#Fabric常用API" class="headerlink" title="Fabric常用API"></a>Fabric常用API</h2><pre><code>local    #执行本地命令，如local(&#39;uname -s&#39;)lcd      #切换本地目录，如lcd(&#39;/home&#39;)cd       #切换远程目录run     #执行远程命令sudo   #sudo方式执行远程命令，如sudo(&#39;/etc/init.d/httpd start&#39;)put     #上次本地文件导远程主机，如put(&#39;/home/user.info&#39;,&#39;/data/user.info&#39;)get     #从远程主机下载文件到本地，如：get(&#39;/data/user.info&#39;,&#39;/home/user.info&#39;)prompt  #获得用户输入信息，如：prompt(&#39;please input user password:&#39;)confirm  #获得提示信息确认，如：confirm(&#39;Test failed,Continue[Y/N]?&#39;)reboot   #重启远程主机，如：reboot()@task   #函数修饰符，标识的函数为fab可调用的，非标记对fab不可见，纯业务逻辑@runs_once   #函数修饰符，标识的函数只会执行一次，不受多台主机影响</code></pre><h2 id="Fabric应用示例说明"><a href="#Fabric应用示例说明" class="headerlink" title="Fabric应用示例说明"></a>Fabric应用示例说明</h2><h3 id="查看本地与远程主机信息"><a href="#查看本地与远程主机信息" class="headerlink" title="查看本地与远程主机信息"></a>查看本地与远程主机信息</h3><p>本示例调用local方法执行本地命令，添加@runs_once修饰符保证任务函数只执行一次，调用run方法执行远程命令。</p><pre><code>#!/usr/bin/env python# -*- encoding: utf-8 -*-from fabric.api import *env.user = &#39;root&#39;env.hosts = [&#39;192.168.1.22&#39;]env.password = &#39;123456&#39;@runs_once   #查看本地系统信息，当有多台主机时只运行一次def local_task():   #本地任务函数    local(&#39;uname -a&#39;)def remote_task():    with cd(&#39;/var/logs&#39;):   #with的作用是让后面的表达式语句继承当前状态，实现：cd /var/logs  &amp;&amp; ls -l的效果        run(&#39;ls -l&#39;)simple1.py</code></pre><p>执行：</p><pre><code>fab -f simple1.py local_taskfab -f simple1.py remote_task</code></pre><h3 id="动态获取远程目录列表"><a href="#动态获取远程目录列表" class="headerlink" title="动态获取远程目录列表"></a>动态获取远程目录列表</h3><p>本例调用@task修饰符标志入口函数go()对外部可见，配合@runs_once修饰符接收用户输入，最后调用worktask()函数实现远程命令执行。</p><pre><code>#!/usr/bin/env python# -*- encoding: utf-8 -*-from fabric.api import *env.user = &#39;root&#39;env.hosts = [&#39;192.168.1.22&#39;]env.password = &#39;123456&#39;@runs_once   #主机遍历过程中，只有第一台触发此函数def input_raw():    return prompt(&#39;please input directoryname:&#39;,default=&#39;/root&#39;)def worktask(dirname):    run(&#39;ls -l&#39;+dirname)@task    #限定只有go函数对fab命令可见,其他没有使用@task标记的函数fab命令不可用def go():    getdirname = input_raw()    worktask(getdirname)simple2.py</code></pre><p>执行：</p><pre><code>fab -f simple2.py go</code></pre><h3 id="网关模式文件上传与执行"><a href="#网关模式文件上传与执行" class="headerlink" title="网关模式文件上传与执行"></a>网关模式文件上传与执行</h3><p>本例通过定义env.gateway网关模式，即俗称的中转、堡垒机环境。通过网关对其他主机进行文件上传和执行。</p><pre><code>#!/usr/bin/env python# -*- encoding: utf-8 -*-from fabric.api import *from fabric.context_managers import *from fabric.contrib.console import confirmenv.user = &#39;root&#39;env.gateway = &#39;192.168.1.23&#39;   #定义堡垒机IP，作为文件上传、执行的中转设置env.hosts = [&#39;192.168.1.21&#39;,&#39;192.168.1.22&#39;]env.passwords = {    &#39;root@192.168.1.21:22&#39;:&#39;123456&#39;,    &#39;root@192.168.1.22:22&#39;:&#39;abcdef&#39;,    &#39;root@192.168.1.23:22&#39;:&#39;123abc&#39;,  #堡垒机账号信息}lpackpath = &#39;/home/install/lnmp.tar.gz&#39;   #本地安装包路径rpackpath = &#39;/tmp/install&#39;    #远程安装包路径@taskdef put_task():  #上传文件    run(&#39;mkdir -p /tmp/install&#39;)    #默认情况下，当命令执行失败时，Fabric会停止执行后续命令。有时，我们允许忽略失败的命令继续执行，比如run(‘rm /tmp/abc&#39;)在文件不存在的时候有可能失败，这时可以用with settings(warn_only=True):执行命令，这样Fabric只会打出警告信息而不会中断执行。    with settings(warn_only=True):        result = put(lpackpath,rpackpath)   #上传    if result.failed and not confirm(&#39;put file failed,Continue[Y/N]?&#39;):        abort(&#39;Aborting file put task!&#39;)@taskdef run_task():   #安装    with cd(&#39;/tmp/install&#39;):        run(&#39;tar -zxvf lnmp.tar.gz&#39;)        with cd(&#39;lnmp/&#39;):    #使用with继承/tmp/install目录位置状态            run(&#39;./centos.sh&#39;)@taskdef go():   #上传、安装组合命令    put_task()    run_task()simple3.pysimple3.py</code></pre><p>执行：</p><pre><code>#上传文件fab simple3.py put_task#执行文件fab simple3.py run_task#上传并执行fab simple3.py go</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang中context包解读</title>
      <link href="/2018/04/21/grpclog-03/"/>
      <url>/2018/04/21/grpclog-03/</url>
      
        <content type="html"><![CDATA[<h1 id="context简单概述"><a href="#context简单概述" class="headerlink" title="context简单概述"></a>context简单概述</h1><p>Go服务器的每个请求都有自己的goroutine,而有的请求为了提高性能，会经常启动额外的goroutine处理请求,当该请求被取消或超时，该请求上的所有goroutines应该退出，防止资源泄露。那么context来了，它对该请求上的所有goroutines进行约束，然后进行取消信号，超时等操作。<br>而context优点就是简洁的管理goroutines的生命周期。</p><a id="more"></a><h2 id="context简单使用"><a href="#context简单使用" class="headerlink" title="context简单使用"></a>context简单使用</h2><p><code>注意: 使用时遵循context规则</code></p><ul><li>不要将 Context放入结构体，Context应该作为第一个参数传入，命名为ctx。</li><li>即使函数允许，也不要传入nil的 Context。如果不知道用哪种Context，可以使用context.TODO()</li><li>使用context的Value相关方法,只应该用于在程序和接口中传递和请求相关数据，不能用它来传递一些可选的参数</li><li>相同的 Context 可以传递给在不同的goroutine；Context 是并发安全的。</li></ul><h3 id="使用net-http-pprof对goroutines进行查看"><a href="#使用net-http-pprof对goroutines进行查看" class="headerlink" title="使用net/http/pprof对goroutines进行查看:"></a>使用net/http/pprof对goroutines进行查看:</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"context"</span>    <span class="token string">"fmt"</span>    <span class="token string">"net/http"</span>    <span class="token boolean">_</span> <span class="token string">"net/http/pprof"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">go</span> http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>    ctx<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">testA</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">testA</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ctxA<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">)</span>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token function">testB</span><span class="token punctuation">(</span>ctxA<span class="token punctuation">,</span> ch<span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"testA Done"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">case</span> i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">testB</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> ch <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//模拟读取数据</span>    sumCh <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>sumCh <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">:=</span> <span class="token number">10</span>        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        sumCh <span class="token operator">&lt;-</span> sum    <span class="token punctuation">}</span><span class="token punctuation">(</span>sumCh<span class="token punctuation">)</span>    <span class="token keyword">select</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"testB Done"</span><span class="token punctuation">)</span>        <span class="token operator">&lt;-</span>sumCh        <span class="token keyword">return</span>    <span class="token comment" spellcheck="true">//case ch  &lt;- &lt;-sumCh: 注意这样会导致资源泄露</span>    <span class="token keyword">case</span> i <span class="token operator">:=</span> <span class="token operator">&lt;-</span>sumCh<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"send"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>        ch <span class="token operator">&lt;-</span> i    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>模拟数据库读取效率慢<br>从执行中和执行后的结果来看，我们完美的关闭了不需要的goroutine，<br>超时<br>概述中提到:<br>当应用场景是由一个请求衍生出多个goroutine完成需求，那它们之间就需要满足一定的约束关系，才能中止routine树，超时等操作。<br>那么是如何到达约束关系？<br>简单理解,Context 的调用以链式存在，通过WithXxx方法派生出新的 Context与当前父Context 关联，当父 Context 被取消时，其派生的所有 Context 都将取消。<br>WithCancel派生约束关系图<br>上图WithCancel派生简单分析图，接下里我们进行源码分析，进一步了解Context的约束关系（WithXxx方法派生大概与WithCancel相同）。</p><h2 id="Context源码分析"><a href="#Context源码分析" class="headerlink" title="Context源码分析"></a>Context源码分析</h2><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> Context <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>    <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Deadline() 返回的time.Time 它为Context 的结束的时间，ok 表示是否有 deadline<br>Done() 返回一个信道，当对Context进行撤销或过期时，该信道就会关闭的，可以简单认为它是关闭信号。<br>Err() 当Done信道关闭后，Err会返回关闭的原因（如超时,手动关闭）<br>Value(key interface{}) 一个 K-V 存储的方法</p><h3 id="canceler提供了cancal函数，同时要求数据结构实现Context"><a href="#canceler提供了cancal函数，同时要求数据结构实现Context" class="headerlink" title="canceler提供了cancal函数，同时要求数据结构实现Context"></a>canceler提供了cancal函数，同时要求数据结构实现Context</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> canceler <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>    <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">//默认错误</span><span class="token keyword">var</span> Canceled <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"context canceled"</span><span class="token punctuation">)</span><span class="token keyword">var</span> DeadlineExceeded <span class="token operator">=</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"context deadline exceeded"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="实现Context的数据结构"><a href="#实现Context的数据结构" class="headerlink" title="实现Context的数据结构"></a>实现Context的数据结构</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> emptyCtx <span class="token builtin">int</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>emptyCtx<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">switch</span> e <span class="token punctuation">{</span>    <span class="token keyword">case</span> background<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"context.Background"</span>    <span class="token keyword">case</span> todo<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"context.TODO"</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token string">"unknown empty Context"</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两个实现Context的空结构。"><a href="#两个实现Context的空结构。" class="headerlink" title="两个实现Context的空结构。"></a>两个实现Context的空结构。</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> <span class="token punctuation">(</span>    background <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span>    todo       <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span>emptyCtx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">return</span> background<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">return</span> todo<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cancelCtx结构体继承了Context，同时实现了canceler接口："><a href="#cancelCtx结构体继承了Context，同时实现了canceler接口：" class="headerlink" title="cancelCtx结构体继承了Context，同时实现了canceler接口："></a>cancelCtx结构体继承了Context，同时实现了canceler接口：</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> cancelCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    done <span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// closed by the first cancel call.</span>    mu       sync<span class="token punctuation">.</span>Mutex    children <span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token builtin">bool</span> <span class="token comment" spellcheck="true">// set to nil by the first cancel call</span>    err      <span class="token builtin">error</span>             <span class="token comment" spellcheck="true">// 当被cancel时将会把err设置为非nil</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>done<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>err<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%v.WithCancel"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>cancelCtx<span class="token punctuation">)</span> <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"context: internal error: missing cancel error"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//timerCtx会频繁使用这块代码，因为派生出来    </span>    <span class="token comment" spellcheck="true">//timerCtx全部指向同一个cancelCtx.</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// already canceled</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>err <span class="token operator">=</span> err    <span class="token comment" spellcheck="true">//关闭c.done</span>    <span class="token function">close</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>done<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//依次遍历c.children，每个child分别cancel</span>    <span class="token keyword">for</span> child <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>children <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// NOTE: acquiring the child's lock while holding parent's lock.</span>        child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token boolean">nil</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果removeFromParent为true，则将c从其parent的children中删除</span>    <span class="token keyword">if</span> removeFromParent <span class="token punctuation">{</span>        <span class="token function">removeChild</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c<span class="token punctuation">)</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果parent为valueCtx类型，将循环找最近parent</span><span class="token comment" spellcheck="true">//为CancelCtx类型的，找到就从父对象的children </span><span class="token comment" spellcheck="true">//map 中删除这个child,否则返回nil（context.Background或者 context.TODO）</span><span class="token keyword">func</span> <span class="token function">removeChild</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> child canceler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    p<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">parentCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> p<span class="token punctuation">.</span>children <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">delete</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>children<span class="token punctuation">,</span> child<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接下来分析Cancel相关代码"><a href="#接下来分析Cancel相关代码" class="headerlink" title="接下来分析Cancel相关代码"></a>接下来分析Cancel相关代码</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> CancelFunc <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//WithCancel方法返回一个继承parent的Context对</span><span class="token comment" spellcheck="true">//象，同时返回的cancel方法可以用来关闭当前</span><span class="token comment" spellcheck="true">//Context中的Done channel</span><span class="token keyword">func</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>ctx Context<span class="token punctuation">,</span> cancel CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    c <span class="token operator">:=</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> cancelCtx <span class="token punctuation">{</span>    <span class="token keyword">return</span> cancelCtx<span class="token punctuation">{</span>        Context<span class="token punctuation">:</span> parent<span class="token punctuation">,</span>        done<span class="token punctuation">:</span>    <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> child canceler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> parent<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token comment" spellcheck="true">// parent is never canceled</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> p<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token function">parentCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> p<span class="token punctuation">.</span>err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果找到的parent已经被cancel，</span>            <span class="token comment" spellcheck="true">//则将方才传入的child树给cancel掉</span>            child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//否则, 将child节点直接添加到parent的children中</span>           <span class="token comment" spellcheck="true">//（这样就有了约束关系，向上的父亲指针不变</span>           <span class="token comment" spellcheck="true">//，向下的孩子指针可以直接使用 ）</span>            <span class="token keyword">if</span> p<span class="token punctuation">.</span>children <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>                p<span class="token punctuation">.</span>children <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span>canceler<span class="token punctuation">]</span><span class="token builtin">bool</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span>           p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span>        p<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//如果没有找到最近的可以被cancel的parent，</span>      <span class="token comment" spellcheck="true">//则启动一个goroutine,等待传入的parent终止，</span>      <span class="token comment" spellcheck="true">//并cancel传入的child树,或者等待传入的child终结。</span>      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">select</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>parent<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                child<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> parent<span class="token punctuation">.</span><span class="token function">Err</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">case</span> <span class="token operator">&lt;-</span>child<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//判断parent是否为cancelCtx类型</span><span class="token keyword">func</span> <span class="token function">parentCancelCtx</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>cancelCtx<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> c <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token operator">*</span>cancelCtx<span class="token punctuation">:</span>            <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token boolean">true</span>        <span class="token keyword">case</span> <span class="token operator">*</span>timerCtx<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">&amp;</span>c<span class="token punctuation">.</span>cancelCtx<span class="token punctuation">,</span> <span class="token boolean">true</span>        <span class="token keyword">case</span> <span class="token operator">*</span>valueCtx<span class="token punctuation">:</span>            parent <span class="token operator">=</span> c<span class="token punctuation">.</span>Context        <span class="token keyword">default</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timerCtx-继承cancelCtx的结构体-这种设计就可以避免写重复代码，提高复用"><a href="#timerCtx-继承cancelCtx的结构体-这种设计就可以避免写重复代码，提高复用" class="headerlink" title="timerCtx 继承cancelCtx的结构体,这种设计就可以避免写重复代码，提高复用"></a>timerCtx 继承cancelCtx的结构体,这种设计就可以避免写重复代码，提高复用</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">type</span> timerCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    cancelCtx     timer <span class="token operator">*</span>time<span class="token punctuation">.</span>Timer  <span class="token comment" spellcheck="true">// Under cancelCtx.mu.  计时器</span>    deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>timerCtx<span class="token punctuation">)</span> <span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>deadline<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>timerCtx<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%v.WithDeadline(%s [%s])"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>cancelCtx<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c<span class="token punctuation">.</span>deadline<span class="token punctuation">,</span> c<span class="token punctuation">.</span>deadline<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 与cencelCtx有所不同，除了处理cancelCtx.cancel，</span><span class="token comment" spellcheck="true">// 还回对c.timer进行Stop()，并将c.timer=nil</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>timerCtx<span class="token punctuation">)</span> <span class="token function">cancel</span><span class="token punctuation">(</span>removeFromParent <span class="token builtin">bool</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    c<span class="token punctuation">.</span>cancelCtx<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token keyword">if</span> removeFromParent <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Remove this timerCtx from its parent cancelCtx's children.</span>        <span class="token function">removeChild</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>cancelCtx<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>timer <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        c<span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token boolean">nil</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="timerCtx具体的两个方法"><a href="#timerCtx具体的两个方法" class="headerlink" title="timerCtx具体的两个方法:"></a>timerCtx具体的两个方法:</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> deadline time<span class="token punctuation">.</span>Time<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//如果parent的deadline比新传入的deadline早，则直接</span>   <span class="token comment" spellcheck="true">//返回WithCancel,因为parent的deadline会先失效，而新的</span>   <span class="token comment" spellcheck="true">//deadline根据不需要</span>    <span class="token keyword">if</span> cur<span class="token punctuation">,</span> ok <span class="token operator">:=</span> parent<span class="token punctuation">.</span><span class="token function">Deadline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token operator">&amp;&amp;</span> cur<span class="token punctuation">.</span><span class="token function">Before</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// The current deadline is already sooner than the new one.</span>        <span class="token keyword">return</span> <span class="token function">WithCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    c <span class="token operator">:=</span> <span class="token operator">&amp;</span>timerCtx<span class="token punctuation">{</span>        cancelCtx<span class="token punctuation">:</span> <span class="token function">newCancelCtx</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span>        deadline<span class="token punctuation">:</span>  deadline<span class="token punctuation">,</span>    <span class="token punctuation">}</span>    <span class="token function">propagateCancel</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> c<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//检查如果已经过期，则cancel新child树</span>    d <span class="token operator">:=</span> deadline<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> d <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// deadline has already passed</span>        <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">defer</span> c<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//没有被cancel的话，就设置deadline之后cancel的计时器</span>        c<span class="token punctuation">.</span>timer <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">AfterFunc</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> DeadlineExceeded<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> c<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> Canceled<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// WithTimeout简单暴力，直接把WithTimeout返回</span><span class="token keyword">func</span> <span class="token function">WithTimeout</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> timeout time<span class="token punctuation">.</span>Duration<span class="token punctuation">)</span> <span class="token punctuation">(</span>Context<span class="token punctuation">,</span> CancelFunc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">WithDeadline</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="valueCtx主要用来传递一些可比较操作的数据"><a href="#valueCtx主要用来传递一些可比较操作的数据" class="headerlink" title="valueCtx主要用来传递一些可比较操作的数据"></a>valueCtx主要用来传递一些可比较操作的数据</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">WithValue</span><span class="token punctuation">(</span>parent Context<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> Context <span class="token punctuation">{</span>    <span class="token keyword">if</span> key <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"nil key"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token operator">!</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"key is not comparable"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>valueCtx<span class="token punctuation">{</span>parent<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">}</span><span class="token keyword">type</span> valueCtx <span class="token keyword">struct</span> <span class="token punctuation">{</span>    Context    key<span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>valueCtx<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%v.WithValue(%#v, %#v)"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> c<span class="token punctuation">.</span>key<span class="token punctuation">,</span> c<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>valueCtx<span class="token punctuation">)</span> <span class="token function">Value</span><span class="token punctuation">(</span>key <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> c<span class="token punctuation">.</span>key <span class="token operator">==</span> key <span class="token punctuation">{</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span>val    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">.</span>Context<span class="token punctuation">.</span><span class="token function">Value</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang sync WaitGroup</title>
      <link href="/2018/04/20/grpclog-02/"/>
      <url>/2018/04/20/grpclog-02/</url>
      
        <content type="html"><![CDATA[<h2 id="golang-sync-WaitGroup"><a href="#golang-sync-WaitGroup" class="headerlink" title="golang sync WaitGroup"></a>golang sync WaitGroup</h2><p>WaitGroup:它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成。<br>WaitGroup总共有三个方法：Add(delta int),Done(),Wait()。简单的说一下这三个方法的作用。<br>Add:添加或者减少等待goroutine的数量<br>Done:相当于Add(-1)<br>Wait:执行阻塞，直到所有的WaitGroup数量变成0</p><a id="more"></a><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"sync"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">{</span>        wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// defer wg.Done()</span>            <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            <span class="token function">EchoNumber</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">EchoNumber</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3e9</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果： </p><pre class="line-numbers language-shell"><code class="language-shell">34102<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：输出结果是无序的</strong> 程序很简单，只是将每次循环的数量过3秒钟输出。那么，这个程序如果不用WaitGroup，那么将看不见输出结果。因为goroutine还没执行完，主线程已经执行完毕。注释的defer wg.Done()和defer wg.Add(-1)作用一样。这个很好，原来执行脚本，都是使用time.Sleep，用一个估计的时间等到子线程执行完。WaitGroup很好。虽然chanel也能实现，但是觉得如果涉及不到子线程与主线程数据同步，这个感觉不错。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> sync </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grpclog日志不打印</title>
      <link href="/2018/01/06/grpclog-01/"/>
      <url>/2018/01/06/grpclog-01/</url>
      
        <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><pre class="line-numbers language-go"><code class="language-go">grpclog<span class="token punctuation">.</span><span class="token function">Infoln</span><span class="token punctuation">(</span><span class="token string">"Infoln"</span><span class="token punctuation">)</span>grpclog<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Println"</span><span class="token punctuation">)</span>grpclog<span class="token punctuation">.</span><span class="token function">Warningln</span><span class="token punctuation">(</span><span class="token string">"Warningln"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>控制台不输出任何日志</code><br>grpc这么高端的开源框架怎么会有这个bug,应该是使用方式不对<br>决定查看源代码 </p><h2 id="grpclog源码"><a href="#grpclog源码" class="headerlink" title="grpclog源码"></a>grpclog源码</h2><p><a href="https://github.com/grpc/grpc-go/blob/master/grpclog/grpclog.go" target="_blank" rel="noopener">grpclog源码位置</a></p><a id="more"></a><h2 id="grpclog源码分析"><a href="#grpclog源码分析" class="headerlink" title="grpclog源码分析"></a>grpclog源码分析</h2><pre class="line-numbers language-go"><code class="language-go"><span class="token keyword">var</span> logger <span class="token operator">=</span> <span class="token function">newLoggerV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用的是新的v2</p><p>继续往下看</p><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// newLoggerV2 creates a loggerV2 to be used as default logger.</span><span class="token comment" spellcheck="true">// All logs are written to stderr.</span><span class="token keyword">func</span> <span class="token function">newLoggerV2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> LoggerV2 <span class="token punctuation">{</span>    errorW <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span>Discard    warningW <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span>Discard    infoW <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span>Discard    logLevel <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"GRPC_GO_LOG_SEVERITY_LEVEL"</span><span class="token punctuation">)</span>    <span class="token keyword">switch</span> logLevel <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">"ERROR"</span><span class="token punctuation">,</span> <span class="token string">"error"</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">// If env is unset, set level to ERROR.</span>        errorW <span class="token operator">=</span> os<span class="token punctuation">.</span>Stderr    <span class="token keyword">case</span> <span class="token string">"WARNING"</span><span class="token punctuation">,</span> <span class="token string">"warning"</span><span class="token punctuation">:</span>        warningW <span class="token operator">=</span> os<span class="token punctuation">.</span>Stderr    <span class="token keyword">case</span> <span class="token string">"INFO"</span><span class="token punctuation">,</span> <span class="token string">"info"</span><span class="token punctuation">:</span>        infoW <span class="token operator">=</span> os<span class="token punctuation">.</span>Stderr    <span class="token punctuation">}</span>    <span class="token keyword">var</span> v <span class="token builtin">int</span>    vLevel <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Getenv</span><span class="token punctuation">(</span><span class="token string">"GRPC_GO_LOG_VERBOSITY_LEVEL"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> vl<span class="token punctuation">,</span> err <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span>vLevel<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        v <span class="token operator">=</span> vl    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">NewLoggerV2WithVerbosity</span><span class="token punctuation">(</span>infoW<span class="token punctuation">,</span> warningW<span class="token punctuation">,</span> errorW<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>果然有猫腻</p><ul><li>logLevel := os.Getenv(“GRPC_GO_LOG_SEVERITY_LEVEL”)</li><li>vLevel := os.Getenv(“GRPC_GO_LOG_VERBOSITY_LEVEL”)</li></ul><p>GRPC_GO_LOG_SEVERITY_LEVEL 默认为ERROR级别 </p><pre class="line-numbers language-Bash"><code class="language-Bash">export GRPC_GO_LOG_SEVERITY_LEVEL=INFOgo run main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>GRPC_GO_LOG_VERBOSITY_LEVEL默认0</p><p>设置env即可或者修改源代码,建议设置env</p><h3 id="既然打开源码我们在多看一看，grpclog-具体怎么实现的"><a href="#既然打开源码我们在多看一看，grpclog-具体怎么实现的" class="headerlink" title="既然打开源码我们在多看一看，grpclog 具体怎么实现的"></a>既然打开源码我们在多看一看，grpclog 具体怎么实现的</h3><pre class="line-numbers language-go"><code class="language-go"><span class="token comment" spellcheck="true">// NewLoggerV2WithVerbosity creates a loggerV2 with the provided writers and</span><span class="token comment" spellcheck="true">// verbosity level.</span><span class="token keyword">func</span> <span class="token function">NewLoggerV2WithVerbosity</span><span class="token punctuation">(</span>infoW<span class="token punctuation">,</span> warningW<span class="token punctuation">,</span> errorW io<span class="token punctuation">.</span>Writer<span class="token punctuation">,</span> v <span class="token builtin">int</span><span class="token punctuation">)</span> LoggerV2 <span class="token punctuation">{</span>    <span class="token keyword">var</span> m <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>log<span class="token punctuation">.</span>Logger    m <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>infoW<span class="token punctuation">,</span> severityName<span class="token punctuation">[</span>infoLog<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">": "</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span><span class="token punctuation">)</span>    m <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span><span class="token function">MultiWriter</span><span class="token punctuation">(</span>infoW<span class="token punctuation">,</span> warningW<span class="token punctuation">)</span><span class="token punctuation">,</span> severityName<span class="token punctuation">[</span>warningLog<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">": "</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span><span class="token punctuation">)</span>    ew <span class="token operator">:=</span> io<span class="token punctuation">.</span><span class="token function">MultiWriter</span><span class="token punctuation">(</span>infoW<span class="token punctuation">,</span> warningW<span class="token punctuation">,</span> errorW<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// ew will be used for error and fatal.</span>    m <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>ew<span class="token punctuation">,</span> severityName<span class="token punctuation">[</span>errorLog<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">": "</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span><span class="token punctuation">)</span>    m <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> log<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>ew<span class="token punctuation">,</span> severityName<span class="token punctuation">[</span>fatalLog<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">": "</span><span class="token punctuation">,</span> log<span class="token punctuation">.</span>LstdFlags<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>loggerT<span class="token punctuation">{</span>m<span class="token punctuation">:</span> m<span class="token punctuation">,</span> v<span class="token punctuation">:</span> v<span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还是使用的”log”库,时间格式<em>log.LstdFlags</em></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> grpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java编程中使用二进制进行权限或状态控制</title>
      <link href="/2018/01/04/java-01/"/>
      <url>/2018/01/04/java-01/</url>
      
        <content type="html"><![CDATA[<h2 id="编程中使用二进制进行权限或状态控制"><a href="#编程中使用二进制进行权限或状态控制" class="headerlink" title="编程中使用二进制进行权限或状态控制"></a>编程中使用二进制进行权限或状态控制</h2><h2 id="与或非运算符"><a href="#与或非运算符" class="headerlink" title="与或非运算符"></a>与或非运算符</h2><ul><li>&amp;是按位与(双目运算符,需要2个操作数) </li><li>|是按位或(双目运算符) </li><li>～是按位非(单目运算符) </li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>1&amp;0=0, 0&amp;1=0, 0&amp;0=0, 1&amp;1=1 </li><li>1|0=1, 0|1=1, 0|0=0, 1|1=1 </li><li><del>1=0,</del>0=1 </li><li>a|=b等价于a=a|b; 同理a&amp;=b等价于a=a&amp;b </li></ul><a id="more"></a><h3 id="java例子"><a href="#java例子" class="headerlink" title="java例子"></a>java例子</h3><pre><code>package test;  public class Rights {      public static void main(String[] args) {          int a=1; // 001 状态a          int b=2; // 010 状态b          int c=4; // 100 状态c          int ab = a | b; // 001 | 010 = 011 初始状态          System.out.println(ab | c); // 011 | 100 = 111 添加c的状态          System.out.println(ab &amp; (~b)); // 011 &amp; (~010) = 011 &amp; 101 = 001 去除b的状态          System.out.println((ab &amp; b) == b); // 011 &amp; 010 = 010 判断是否有b的权限：(ab &amp; b)==b          System.out.println((ab &amp; c) == c); // 011 &amp; 100 = 000       }  }  </code></pre><h2 id="使用二进制进行权限或状态控制"><a href="#使用二进制进行权限或状态控制" class="headerlink" title="使用二进制进行权限或状态控制"></a>使用二进制进行权限或状态控制</h2><pre><code>package test;  public class Test {  public static void main(String[] args) {          /**          * 四种权限 ，当前定义为int，以下二进制表示只取后四位作说明          */          // 添加          int c = 1;// ...0001=2^0          // 查询          int r = 2;// ...0010=2^1          // 修改          int u = 4;// ...0100=2^3          // 删除          int d = 8;// ...1000=2^4          /**          *           * 大家可以观察四种权限的二进制表示的规律 ，都是2的N次方，          * 就表示本身，添加权限有最后一位为其它为0,查询倒数第二位为1其它都为0，修改倒数第三个为1其它都为0，删除倒数第四个为1其它都为0          *           */          /**          * 这样表示有哪种权限时可以用 |(按位或) 操作          *           */          // 用户A有添加和修改权限          int usera = c | r | u;          // 用户B有添加和删除权限          int userb = c | d;          /**          * 判断用户是否有某种权限用用户权限和要判断的权限进行 &amp;(按位与) 操作，结果为要判断的权限值时表示用户有此权限，否则没有此权限          */          System.out.println();          if ((usera &amp; u) == u) {              System.out.println(&quot;用户a有更新权限&quot;);          } else {              System.out.println(&quot;用户a没有有更新权限&quot;);          }          /**          * 给用户添加权限用用户权限和要添加的权限|(按位或) 操作再覆盖之前权限值          */          System.out.println();          if ((userb &amp; u) == u) {              System.out.println(&quot;用户b有更新权限&quot;);          } else {              System.out.println(&quot;用户b没有更新权限&quot;);          }          System.out.println(&quot;==&gt;给用户b添加更新权限&quot;);          userb = userb | u;          if ((userb &amp; u) == u) {              System.out.println(&quot;用户b有更新权限&quot;);          } else {              System.out.println(&quot;用户b没有更新权限&quot;);          }          /**          * 取消用户某种权限,用用户权限和要取消的权限按位取反后进行按位 操作，再覆盖之前权限值          */          System.out.println();          if ((usera &amp; r) == r) {              System.out.println(&quot;用户a有查询权限&quot;);          } else {              System.out.println(&quot;用户a没有查询权限&quot;);          }          System.out.println(&quot;==&gt;取消用户a的查询权限&quot;);          usera = usera &amp; (~r);          if ((usera &amp; r) == r) {              System.out.println(&quot;用户a有查询权限&quot;);          } else {              System.out.println(&quot;用户a没有查询权限&quot;);          }      }  }  </code></pre><h2 id="二进制和十进制之间的转换"><a href="#二进制和十进制之间的转换" class="headerlink" title="二进制和十进制之间的转换"></a>二进制和十进制之间的转换</h2><pre><code>package test;  public class Trans {      public static void main(String[] args) {          int bit = 7;          System.out.println(Integer.toBinaryString(bit)); // 十进制转二进制          Integer it = Integer.valueOf(&quot;111&quot;, 2);          System.out.println(it);// 转换为10进制结果      }  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python url admin:password</title>
      <link href="/2018/01/02/python-urllib/"/>
      <url>/2018/01/02/python-urllib/</url>
      
        <content type="html"><![CDATA[<h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>curl  “<a href="http://admin:random_password@10.189.195.39:2999/api/dashboards/db/bls_mysql_metrics&quot;" target="_blank" rel="noopener">http://admin:random_password@10.189.195.39:2999/api/dashboards/db/bls_mysql_metrics&quot;</a></p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre><code>import urllib2, base64request = urllib2.Request(&quot;http://api.foursquare.com/v1/user&quot;)base64string = base64.b64encode(&#39;%s:%s&#39; % (username, password))request.add_header(&quot;Authorization&quot;, &quot;Basic %s&quot; % base64string)   result = urllib2.urlopen(request)body=result.read()</code></pre><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 配置go环境</title>
      <link href="/2017/12/18/ubuntu-install-go/"/>
      <url>/2017/12/18/ubuntu-install-go/</url>
      
        <content type="html"><![CDATA[<p>配置go环境</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></p><h1 id="配置env"><a href="#配置env" class="headerlink" title="配置env"></a>配置env</h1><pre><code>export GOROOT=/home/bamboo/goexport PATH=$GOROOT/bin:$PATHexport GOPATH=$HOME/Development/go</code></pre><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo高阶教程：想让你的博客被更多的人在搜索引擎中搜到吗？</title>
      <link href="/2017/06/10/hexo-blog-part-3/"/>
      <url>/2017/06/10/hexo-blog-part-3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20170506111627464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="coding"></p><ul><li>seo优化</li><li>多终端修改项目</li><li>同时托管到github和coding上</li><li>设置google和百度sitemap，让搜索引擎更好的抓取你的网站</li><li>使用gulp对css、js进行优化</li><li>接入七牛图床</li><li>加入打赏功能</li><li>加入照片模块</li></ul><h1 id="seo优化"><a href="#seo优化" class="headerlink" title="seo优化"></a>seo优化</h1><blockquote><p>SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。</p></blockquote><h2 id="让百度收录你的站点"><a href="#让百度收录你的站点" class="headerlink" title="让百度收录你的站点"></a>让百度收录你的站点</h2><p>我们首先要做的就是让各大搜索引擎收录你的站点，我们在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入<code>site:&lt;域名&gt;</code>,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站<br><img src="http://img.blog.csdn.net/20170504171112514?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="查看站点是否被百度收录"></p><h3 id="验证网站所有权"><a href="#验证网站所有权" class="headerlink" title="验证网站所有权"></a>验证网站所有权</h3><p>登录百度站长平台：<a href="http://zhanzhang.baidu.com,只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击[添加网站](http://zhanzhang.baidu.com/site/siteadd)然后输入你的站点地址，建议输入的网站为www开头的，不要输入github.io的，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名" target="_blank" rel="noopener">http://zhanzhang.baidu.com,只要有百度旗下的账号就可以登录，登录成功之后在站点管理中点击[添加网站](http://zhanzhang.baidu.com/site/siteadd)然后输入你的站点地址，建议输入的网站为www开头的，不要输入github.io的，因为github是不允许百度的spider爬取github上的内容的，所以如果想让你的站点被百度收录，只能使用自己购买的域名</a><br><img src="http://img.blog.csdn.net/20170504172333359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="百度站长添加网站"><br>在选择完网站的类型之后需要验证网站的所有权，验证网站所有权的方式有三种：文件验证。html标签验证和cname解析验证，使用哪一种方式都可以，都是比较简单的，<strong>但是一定要注意，使用文件验证文件存放的位置需要放在source文件夹下，如果是html文件那么hexo就会将其编译，所以必须要加上的<code>layout:false</code>，这样就不会被hexo编译。（如果验证文件是txt格式的就不需要）</strong>，其他两种方式也是很简单的，我个人推荐文件验证和cname验证，cname验证最为简单，只需加一条解析就好~<br><img src="http://img.blog.csdn.net/20170504175857203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="验证网站所有权"></p><h3 id="生成网站地图"><a href="#生成网站地图" class="headerlink" title="生成网站地图"></a>生成网站地图</h3><p>我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎</p><h4 id="安装sitemap插件"><a href="#安装sitemap插件" class="headerlink" title="安装sitemap插件"></a>安装sitemap插件</h4><pre><code>npm install hexo-generator-sitemap --save     npm install hexo-generator-baidu-sitemap --save</code></pre><h4 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h4><p>在根目录配置文件中修改url为你的站点地址</p><pre><code># URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://cherryblog.siteroot: /permalink: :title.htmlpermalink_defaults:</code></pre><p><strong>执行完之后就会在网站根目录生成sitemap.xml文件和baidusitemap.xml文件</strong>，可以通过<a href="http://www.cherryblog.site/baidusitemap.xml,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。" target="_blank" rel="noopener">http://www.cherryblog.site/baidusitemap.xml,查看该文件是否生成，其中sitemap.xml文件是搜索引擎通用的文件，baidusitemap.xml是百度专用的sitemap文件。</a></p><h3 id="向百度提交链接"><a href="#向百度提交链接" class="headerlink" title="向百度提交链接"></a>向百度提交链接</h3><p>然后我们就可以将我们生成的sitemap文件提交给百度，还是在百度站长平台，找到链接提交，这里我们可以看到有两种提交方式，自动提交和手动提交，自动提交又分为主动推送、自动推送和sitemap</p><blockquote><p>如何选择链接提交方式<br>1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。<br>2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。<br>3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。<br>4、手动提交：一次性提交链接给百度，可以使用此种方式。</p></blockquote><p>一般主动提交比手动提交效果好，这里介绍主动提交的三种方法<br>从效率上来说：</p><blockquote><p><strong>主动推送&gt;自动推送&gt;sitemap</strong></p></blockquote><p><img src="http://img.blog.csdn.net/20170504205614072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="连接提交"></p><h4 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h4><p>安装插件<code>npm install hexo-baidu-url-submit --save</code><br>然后再根目录的配置文件中新增字段</p><pre><code>baidu_url_submit:  count: 100 # 提交最新的一个链接  host: www.cherryblog.site # 在百度站长平台中注册的域名  token: 8OGYpxowYnhgVsUM # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里</code></pre><p>在加入新的deploye</p><pre><code>deploy: - type:baidu_url_submitter</code></pre><p> 这样执行<code>hexo deploy</code>的时候，新的链接就会被推送了</p><h4 id="设置自动推送"><a href="#设置自动推送" class="headerlink" title="设置自动推送"></a>设置自动推送</h4><p>在主题配置文件下设置,将baidu_push设置为true：</p><pre><code># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: true</code></pre><p>然后就会将一下代码自动推送到百度，位置是themes\next\layout_scripts\baidu_push.swig,这样每次访问博客中的页面就会自动向百度提交sitemap</p><pre><code>{% if theme.baidu_push %}<script>(function(){    var bp = document.createElement('script');    var curProtocol = window.location.protocol.split(':')[0];    if (curProtocol === 'https') {        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';            }    else {        bp.src = 'http://push.zhanzhang.baidu.com/push.js';    }    var s = document.getElementsByTagName("script")[0];    s.parentNode.insertBefore(bp, s);})();</script>{% endif %}</code></pre><h4 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h4><p>将我们上一步生成的sitemap文件提交到百度就可以了~<br><img src="http://img.blog.csdn.net/20170504211420159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="将sitemap提交到百度"><br>我记得被百度收录过程还是蛮久的，一度让我以为我的方法有问题，提交链接在站长工具中有显示大概是有两天的时候，站点被百度收录大概花了半个月= =，让大家看一下现在的成果<br>在百度搜索<code>site:cherryblog.site</code>已经可以搜索到结果<br><img src="http://img.blog.csdn.net/20170504212208725?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="站点已被百度收录"><br>在搜索框输入域名也可以找到站点<br><img src="http://img.blog.csdn.net/20170504212800850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="站点已被百度收录"><br>输入关键字的名字也可以在第二页就找到呢，好开森~<br><img src="http://img.blog.csdn.net/20170504213218169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="站点已被百度收录"></p><h2 id="让google收录你的站点"><a href="#让google收录你的站点" class="headerlink" title="让google收录你的站点"></a>让google收录你的站点</h2><p>相比于百度，google的效率实在不能更快，貌似十分钟左右站点就被收录了，其实方法是和百度是一样的，都是先验证你的站点所有权，然后提交sitemap<br>google站点平台：<a href="https://www.google.com/webmasters/，然后就是注册账号、验证站点、提交sitemap，一步一步来就好，过不了过久就可以被google收录了" target="_blank" rel="noopener">https://www.google.com/webmasters/，然后就是注册账号、验证站点、提交sitemap，一步一步来就好，过不了过久就可以被google收录了</a><br><img src="http://img.blog.csdn.net/20170504221124520?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="站点已被google收录"><br><img src="http://img.blog.csdn.net/20170504221145864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="站点已被google收录"><br><img src="http://img.blog.csdn.net/20170504221202442?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="站点已被google收录"></p><p><strong><em>具体怎么操作可以查看-<a href="http://www.jianshu.com/p/86557c34b671" target="_blank" rel="noopener">http://www.jianshu.com/p/86557c34b671</a></em></strong></p><h2 id="让其他搜索引擎收录你的站点"><a href="#让其他搜索引擎收录你的站点" class="headerlink" title="让其他搜索引擎收录你的站点"></a>让其他搜索引擎收录你的站点</h2><p>除了百度和google两大搜索引擎，还有搜狗、360等其他的搜索引擎，流程都是一样的<br> ，大家就自行选择添加哈，这里就不再赘述了~</p><h2 id="优化你的url"><a href="#优化你的url" class="headerlink" title="优化你的url"></a>优化你的url</h2><p>seo搜索引擎优化认为，网站的最佳结构是<strong>用户从首页点击三次就可以到达任何一个页面</strong>，但是我们使用hexo编译的站点打开文章的url是：sitename/year/mounth/day/title四层的结构，这样的url结构很不利于seo，爬虫就会经常爬不到我们的文章，于是，我们可以将url直接改成sitename/title的形式，并且title最好是用英文，在根目录的配置文件下修改permalink如下：</p><pre><code>url: http://cherryblog.siteroot: /permalink: :title.htmlpermalink_defaults:</code></pre><h2 id="其他seo优化"><a href="#其他seo优化" class="headerlink" title="其他seo优化"></a>其他seo优化</h2><p>seo优化应该说是一个收益延迟的行为，可能你做的优化短期内看不到什么效果，但是一定要坚持，seo优化也是有很深的可以研究的东西，从我们最初的网站设计，和最基础的标签的选择都有很大的关系，网站设计就如我们刚刚说的，要让用户点击三次可以到达网站的任何一个页面，要增加高质量的外链，增加相关推荐（比如说我们经常见到右侧本站的最高阅读的排名列表），然后就是给每一个页面加上keyword和描述<br>在代码中，我们应该写出能让浏览器识别的语义化HTML，这样有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；并且对外链设置nofollow标签，避免spider爬着爬着就爬出去了（减少网站的跳出率），并且我们要尽量在一些比较大的网站增加我们站点的曝光率，因为spider会经常访问大站，比如我们在掘金等技术社区发表文章中带有我们的站点，这样spider是很有可能爬到我们中的站点的，so….</p><ul><li>网站<strong>外链</strong>的推广度、数量和质量</li><li>网站的<strong>内链</strong>足够强大</li><li>网站的<strong>原创</strong>质量</li><li>网站的<strong>年龄</strong>时间</li><li>网站的<strong>更新频率</strong>（更新次数越多越好）</li><li>网站的<strong>服务器</strong></li><li>网站的<strong>流量</strong>：流量越高网站的权重越高</li><li>网站的<strong>关键词排名</strong>：关键词排名越靠前，网站的权重越高</li><li>网站的<strong>收录</strong>数量：网站百度收录数量越多，网站百度权重越高</li><li>网站的浏览量及深度：<strong>用户体验</strong>越好，网站的百度权重越高<h1 id="同时托管到github和coding上"><a href="#同时托管到github和coding上" class="headerlink" title="同时托管到github和coding上"></a>同时托管到github和coding上</h1>前面已经提到过一个惨绝人寰的消息，那就是github是不允许百度的爬虫爬取内容的，所以我们的项目如果是托管在github上的话基本是不会被百度收录的，所以我又同时托管到了coding上，然后在做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding<h2 id="将你的项目托管在coding上"><a href="#将你的项目托管在coding上" class="headerlink" title="将你的项目托管在coding上"></a>将你的项目托管在coding上</h2><img src="http://img.blog.csdn.net/20170506111627464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="coding"><blockquote><p>Coding 是一个面向开发者的云端开发平台[1]  ，目前提供代码托管，运行空间，质量控制，项目管理等功能。此外，还提供社会化协作功能，包含了社交元素，方便开发者进行技术讨论和协作。<br>2016年3月CODING宣布收购代码托管平台GitCafe。</p></blockquote></li></ul><p>之前好多小伙伴都是将项目托管在gitcafe上，但是现在gitcafe被coding收购了，于是就转到coding上了，之前好多人说github的服务器在国外，于是就转战国内的coding了，我将代码迁移至coding还有另外一个原因，github不让百度的爬虫爬取啊，让我哭一会，不然也不会这样折腾。coding就是中国版的github（只是打一个比喻），有提供pages服务。</p><h3 id="在coding上创建仓库"><a href="#在coding上创建仓库" class="headerlink" title="在coding上创建仓库"></a>在coding上创建仓库</h3><p>首先我们先要创建一个coding账号并且在coding上创建一个项目,必须要是公开项目，私有项目是没有page服务的，项目名称可以随意起<br><img src="http://img.blog.csdn.net/20170506114106649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="创建coding项目"></p><h3 id="将hexo博客同步到新创建的仓库中"><a href="#将hexo博客同步到新创建的仓库中" class="headerlink" title="将hexo博客同步到新创建的仓库中"></a>将hexo博客同步到新创建的仓库中</h3><p>第一次使用coding需要使用ssh，方法和之前github是一样一样的，将ssh公钥复制到coding上<br><img src="http://img.blog.csdn.net/20170506114846918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="自己的ssh公钥"><br><img src="http://img.blog.csdn.net/20170506114917277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="coding中贴入ssh"><br>在coding中添加过ssh公钥之后我们需要修改hexo根目录下的配置文件,官方要求配置格式如下</p><pre><code>deploy:  type: git  message: [message]  repo:    github: &lt;repository url&gt;,[branch]    gitcafe: &lt;repository url&gt;,[branch] </code></pre><p>所以我的配置就是这样的(我这个配置github和coding都有ssh和https两种方式)：</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo:    #github: git@github.com:sunshine940326/sunshine940326.github.io.git    github: https://github.com/sunshine940326/sunshine940326.github.io.git    coding: git@git.coding.net:cherry940326/cherry940326.git    #coding: https://git.coding.net/cherry940326/cherry940326.git</code></pre><p>完成之后在git bash 中输入</p><pre><code>ssh -T git@git.coding.net</code></pre><p>如果得到如图提示就说明配置成功了<br><img src="http://img.blog.csdn.net/20170506120449863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="配置成功ssh"><br>然后重新部署hexo就将代码上传至coding上了</p><h3 id="设置coding的pages服务"><a href="#设置coding的pages服务" class="headerlink" title="设置coding的pages服务"></a>设置coding的pages服务</h3><p>将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了<br><img src="http://img.blog.csdn.net/20170506121132351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="找到pages"><br><img src="http://img.blog.csdn.net/20170506120956994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="配置pages"></p><h3 id="设置域名解析"><a href="#设置域名解析" class="headerlink" title="设置域名解析"></a>设置域名解析</h3><p>然后我们到万网下面设置我们的域名解析，将默认ip解析到coding上（这里要注意，解析到coding时记录值是pages.coding.me，并没有具体的账号名或者仓库名，并且只有设置完成域名解析才可以在coding上设置自定义域名），将海外的ip解析到github上，设置如下：<br><img src="http://img.blog.csdn.net/20170506122622186?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="域名解析"></p><hr><p>至此就完成了将你的hexo编译的博客同时部署在github和coding上</p><h1 id="多终端编辑hexo博客"><a href="#多终端编辑hexo博客" class="headerlink" title="多终端编辑hexo博客"></a>多终端编辑hexo博客</h1><p>之前就想到了一个问题，如果我想要在公司写博客怎么办，或者说如果我换电脑了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上，这道题的解题思路（哈哈，突然想到这个词了）是，将我们的源文件上传至username.github.io的Hexo分支，并且设置为默认分支（分支需要自己创建），然后对我们的源文件进行版本管理，这样我们就可以在另一台电脑上pull我们的源码，然后编译完之后push上去。</p><blockquote><p>更为优雅的方式是使用travis-ci，然后用webhook自动部署。你只需要写markdown，push到github就行了。根本不用关心deploy，只要维护你的markdown就行。详情请参考：<a href="http://blog.bigruan.com/2015-03-09-Continuous-Integration-Your-Hexo-Blog-With-TravisCI/" target="_blank" rel="noopener">http://blog.bigruan.com/2015-03-09-Continuous-Integration-Your-Hexo-Blog-With-TravisCI/</a></p></blockquote><h2 id="创建Hexo分支"><a href="#创建Hexo分支" class="headerlink" title="创建Hexo分支"></a>创建Hexo分支</h2><p>创建两个分支：master 与 Hexo,并将Hexo设置为默认分支（这个Hexo分支就是存放我们源文件的分支，我们只需要更新Hexo分支上的内容据就好，master上的分支hexo编译的时候会更新的）</p><h2 id="删除文件夹内原有的-git缓存文件夹并编辑-gitignore文件"><a href="#删除文件夹内原有的-git缓存文件夹并编辑-gitignore文件" class="headerlink" title="删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件"></a>删除文件夹内原有的.git缓存文件夹并编辑.gitignore文件</h2><p>因为有些主题是从git上clone过来的，所以我们要先删除.git缓存文件，否则会和blog仓库冲突（.git默认是隐藏文件夹，需要先开启显示隐藏文件夹。<strong>.git文件夹被删除后整个文件对应的git仓库状态也会被清空</strong>)<br>.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：</p><pre><code>/.deploy_git/public  /_config.yml</code></pre><blockquote><p>.deploy_git是hexo默认的.git配置文件夹，不需要同步<br>public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多<br>即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去 </p></blockquote><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p>然后我们再初始化仓库，重新对我们的代码进行版本控制</p><pre><code>git initgit remote add origin &lt;server&gt;</code></pre><p><code>&lt;server&gt;</code>是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端</p><h2 id="将博客源文件上传至Hexo分支"><a href="#将博客源文件上传至Hexo分支" class="headerlink" title="将博客源文件上传至Hexo分支"></a>将博客源文件上传至Hexo分支</h2><p>依次执行</p><pre><code>git add .git commit -m &quot;...&quot;git push origin hexo</code></pre><p>提交网站相关的文件； </p><h2 id="对B电脑进行的操作"><a href="#对B电脑进行的操作" class="headerlink" title="对B电脑进行的操作"></a>对B电脑进行的操作</h2><p>假设B电脑现在没有我们的源文件</p><pre><code>git initgit remote add origin &lt;server&gt; #将本地文件和云端仓库映射起来。git fetch --allgit reset --hard origin/master</code></pre><h2 id="日常改动"><a href="#日常改动" class="headerlink" title="日常改动"></a>日常改动</h2><p>平时我们对源文件有修改的时候记得先pull一遍代码，再将代码push到Hexo分支，就和日常的使用git一样~</p><ol><li>依次执行git add .、git commit -m “…”、git push origin Hexo指令将改动推送到GitHub（此时当前分支应为Hexo）；</li><li>然后才执行hexo g -d发布网站到master分支上。<h1 id="使用gulp压缩你的代码"><a href="#使用gulp压缩你的代码" class="headerlink" title="使用gulp压缩你的代码"></a>使用gulp压缩你的代码</h1>当你在你的博客页面右键查看源代码的时候，你会发现你的html页面中会有大段大段的空白，这个时候我们就要使用压缩工具对我们的代码进行压缩，在前一段时间参见的前端开发者大会（FDCon2017）中，携程的框架式就有讲到，在携程，线上的资源是需要申请的（单位具体到k），所以说我们的代码不压缩实在是太奢侈~<h2 id="什么是gulp"><a href="#什么是gulp" class="headerlink" title="什么是gulp"></a>什么是gulp</h2>在2017年的前端中，gulp似乎不是最流行的自动化工具，但是谁让我们公司用的是gulp呢。为了能和公司用一样的构建工具，所以我自己的博客也是使用的gulp。<br>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器。不仅能对网站的资源进行优化，并且能在开发过程中能够对很多重复的任务使其自动完成。<blockquote><p>能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。</p></blockquote></li></ol><p>既然gulp是基于node，所以我们就要先有node环境，不过我们本身就是使用hexo构建我们的博客，就已经是基于node环境了~</p><h3 id="npm小知识"><a href="#npm小知识" class="headerlink" title="npm小知识"></a>npm小知识</h3><p>npm（node package manager）nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）<br>####使用npm安装插件：<code>npm install &lt;name&gt; [g] [--save -dev]</code></p><ul><li><code>&lt;name&gt;</code>:node 插件名称</li><li><code>-g</code>:全局安装，会在node安装的根目录下载对应的包，在计算机的任何文件都可以使用该插件，默认的node安装目录是：<code>C:\Users\Administrator\AppData\Roaming\npm</code>;如果不带该属性，将会安装在当前目录，下载安装包的位置是当前目录的<code>node_modules</code>文件夹</li><li><code>--save</code>：将配置信息保存在node项目配置文件<code>package.json</code>中</li><li><code>-dev</code>：保存至<code>package.json</code> 的devDependencies节点，如果没有该属性，该插件将会被保存至dependencies节点，devDependencies和dependencies有什么区别呢？其实从名字就应该可以看出来两者的区别，devDependencies中dev是development（开发）的缩写，dependencies是依赖的意思。所以 dependencies 是程序正常运行所需要安装的依赖，而devDependencies是开发所需要的依赖，比如一些单元测试的包~</li><li>为什么要保存至package.json？因为我们使用node的时候需要很多的包，所以我们将我们的配置信息，也就是我们需要包的名称等其他信息保存至一个文件中，如果说其他开发者就可以直接使用一个命令就可以安装和我们相同的配置，这个命令就是<code>npm install</code>，就可以下载<code>package.json</code> 下所有需要的包。<code>npm install --production</code>则只下载dependencies下的包<h4 id="使用npm卸载插件：npm-unstall-lt-name-gt-g-save-dev"><a href="#使用npm卸载插件：npm-unstall-lt-name-gt-g-save-dev" class="headerlink" title="使用npm卸载插件：npm unstall &lt;name&gt; [-g] [--save-dev]"></a>使用npm卸载插件：<code>npm unstall &lt;name&gt; [-g] [--save-dev]</code></h4></li><li>在npm中要卸载插件不是将文件夹删除就可以了，因为你的配置信息还在package中，所以要使用<code>npm unstall &lt;name&gt; [-g] [--save-dev]</code> 命令</li><li>删除全部插件:<code>rimraf node_modules</code>（首先你需要先安装rimraf 插件）<h4 id="更新npm插件：npm-update-lt-name-gt-g-save-dev"><a href="#更新npm插件：npm-update-lt-name-gt-g-save-dev" class="headerlink" title="更新npm插件：npm update &lt;name&gt; [g] [--save-dev]"></a>更新npm插件：<code>npm update &lt;name&gt; [g] [--save-dev]</code></h4><h3 id="使用cnpm"><a href="#使用cnpm" class="headerlink" title="使用cnpm"></a>使用cnpm</h3>什么是cnpm呢，大家都知道，由于不可描述原因，我们访问国外的资源有时候的速度，大家懂的，所以淘宝除了一个npm镜像，服务器就在中国。c可以理解为China（应该可以这样理解吧）,cnpm使用方法和npm完全相同，只需将npm全部换成cnpm就可以。本文都是使用的npm，如果想要尝试cnpmde的麻烦自行替换~<blockquote><p>这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p></blockquote></li></ul><p>cnpm 官网地址：<a href="http://npm.taobao.org；" target="_blank" rel="noopener">http://npm.taobao.org；</a><br>安装命令为<code>npm install cnpm -g --registry=https://registry.npm.taobao.org</code></p><blockquote><p>注意：安装完后最好查看其版本号<code>cnpm -v</code>或关闭命令提示符重新打开，安装完直接使用有可能会出现错误；</p></blockquote><h2 id="全局安装gulp"><a href="#全局安装gulp" class="headerlink" title="全局安装gulp"></a>全局安装gulp</h2><p>言归正传，简单介绍了gulp和npm，我们需要的是使用gulp压缩我们的代码<br><code>npm install gulp -g</code>,然后<code>npm -v</code> 查看版本号就可以知道我们是不是安装成功了~<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em>。撒花！</p><h2 id="新建package-json"><a href="#新建package-json" class="headerlink" title="新建package.json"></a>新建package.json</h2><p>使用<code>npm init</code>就可以创建package.json文件<br><img src="http://img.blog.csdn.net/20170502214954885?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="创建package.json文件">，然后输入yes之后你就会在文件夹中找到创建好的package.json文件。来贴一下我现在的package.json文件，已经是安装了不少包的了~</p><pre><code>{  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: {    &quot;version&quot;: &quot;3.2.2&quot;  },  &quot;dependencies&quot;: {    &quot;gulp&quot;: &quot;^3.9.1&quot;,    &quot;gulp-htmlclean&quot;: &quot;^2.7.14&quot;,    &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;,    &quot;gulp-imagemin&quot;: &quot;^3.2.0&quot;,    &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;,    &quot;gulp-uglify&quot;: &quot;^2.1.2&quot;,    &quot;hexo&quot;: &quot;^3.2.0&quot;,    &quot;hexo-baidu-url-submit&quot;: &quot;0.0.5&quot;,    &quot;hexo-deployer-git&quot;: &quot;^0.2.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.2&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,    &quot;hexo-generator-sitemap&quot;: &quot;^1.1.2&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,    &quot;hexo-server&quot;: &quot;^0.2.0&quot;,    &quot;hexo-util&quot;: &quot;^0.6.0&quot;,    &quot;hexo-wordcount&quot;: &quot;^2.0.1&quot;  },  &quot;devDependencies&quot;: {    &quot;gulp-babel&quot;: &quot;^6.1.2&quot;,    &quot;gulp-clean&quot;: &quot;^0.3.2&quot;,    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.2&quot;  }}</code></pre><h2 id="本地安装gulp插件"><a href="#本地安装gulp插件" class="headerlink" title="本地安装gulp插件"></a>本地安装gulp插件</h2><p>在你的Hexo目录下右键<code>git bash here</code>然后执行<code>npm install &lt;name&gt; --save</code>,和gulp有关的包名称有以下几个，只需将<code>&lt;name&gt;</code>替换一下就好~</p><pre><code>&quot;gulp&quot;: &quot;^3.9.1&quot;,    &quot;gulp-htmlclean&quot;: &quot;^2.7.14&quot;,    &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;,    &quot;gulp-imagemin&quot;: &quot;^3.2.0&quot;,    &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;,    &quot;gulp-uglify&quot;: &quot;^2.1.2&quot;,</code></pre><p>聪明的你是不是觉得有些眼熟，对的，就是我po出来的package.json中<code>dependencies</code>下面对应的包名称和版本号<del>是不是和刚刚所讲的npm的知识联系到了一块呢</del></p><h2 id="建立gulp-js"><a href="#建立gulp-js" class="headerlink" title="建立gulp.js"></a>建立gulp.js</h2><p>gulp.js是gulp的配置文件，需要我们手动创建（应该还会有更高级的方法T T ）<br>我的gulp.js文件如下</p><pre><code>var gulp = require(&#39;gulp&#39;);var minifycss = require(&#39;gulp-minify-css&#39;);var uglify = require(&#39;gulp-uglify&#39;);var htmlmin = require(&#39;gulp-htmlmin&#39;);var htmlclean = require(&#39;gulp-htmlclean&#39;);// 获取 gulp-imagemin 模块var imagemin = require(&#39;gulp-imagemin&#39;)// 压缩 public 目录 cssgulp.task(&#39;minify-css&#39;, function() {    return gulp.src(&#39;./public/**/*.css&#39;)        .pipe(minifycss())        .pipe(gulp.dest(&#39;./public&#39;));});// 压缩 public 目录 htmlgulp.task(&#39;minify-html&#39;, function() {    return gulp.src(&#39;./public/**/*.html&#39;)        .pipe(htmlclean())        .pipe(htmlmin({            removeComments: true,  //清除HTML注释            collapseWhitespace: true,  //压缩HTML            collapseBooleanAttributes: true,  //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input checked /&gt;            removeEmptyAttributes: true,  //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt;            removeScriptTypeAttributes: true,  //删除&lt;script&gt;的type=&quot;text/javascript&quot;            removeStyleLinkTypeAttributes: true,  //删除&lt;style&gt;和&lt;link&gt;的type=&quot;text/css&quot;            minifyJS: true,  //压缩页面JS            minifyCSS: true  //压缩页面CSS        }))        .on(&#39;error&#39;, function(err) {            console.log(&#39;html Error!&#39;, err.message);            this.end();        })        .pipe(gulp.dest(&#39;./public&#39;))});// 压缩 public/js 目录 jsgulp.task(&#39;minify-js&#39;, function() {    return gulp.src(&#39;./public/**/*.js&#39;)        .pipe(uglify())        .pipe(gulp.dest(&#39;./public&#39;));});// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task(&#39;images&#39;, function () {    // 1. 找到图片    gulp.src(&#39;./photos/*.*&#39;)    // 2. 压缩图片        .pipe(imagemin({            progressive: true        }))        // 3. 另存图片        .pipe(gulp.dest(&#39;dist/images&#39;))});// 执行 gulp 命令时执行的任务gulp.task(&#39;build&#39;, [    &#39;minify-html&#39;,&#39;minify-css&#39;,&#39;minify-js&#39;,&#39;images&#39;,]);</code></pre><h2 id="执行gulp：gulp-build"><a href="#执行gulp：gulp-build" class="headerlink" title="执行gulp：gulp build"></a>执行gulp：<code>gulp build</code></h2><p><img src="http://img.blog.csdn.net/20170503180052628?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="gulpbuild执行结果"></p><h3 id="在git-bash中执行"><a href="#在git-bash中执行" class="headerlink" title="在git bash中执行"></a>在git bash中执行</h3><p>在git bash中直接输入命令<code>gulp build</code>就可以，这个<code>gulp build</code>是你自己创建的任务，你创建的任务是什么名的就在gulp后面跟什么名字</p><h3 id="在webstorm中执行"><a href="#在webstorm中执行" class="headerlink" title="在webstorm中执行"></a>在webstorm中执行</h3><p>webstorm真的太强大，已经帮我们继承了gulp，我们只需要动动鼠标就可以执行gulp<br><img src="http://img.blog.csdn.net/20170502222748614?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="在webstorm中执行gulp"></p><h1 id="增加七牛图床"><a href="#增加七牛图床" class="headerlink" title="增加七牛图床"></a>增加七牛图床</h1><p>增加七牛图床就是要将我们电脑上的图片上传至七牛，然后获得外链，在我们使用md写博客的时候直接插入外链，更方便的是可以直接获取带水印、压缩、剪裁过后的图片~</p><h2 id="注册七牛"><a href="#注册七牛" class="headerlink" title="注册七牛"></a>注册七牛</h2><p>万年不变的第一步，注册。官网：<a href="https://portal.qiniu.com/signup?code=3lnd6wvc103f6" target="_blank" rel="noopener">七牛云</a></p><h2 id="上传资源"><a href="#上传资源" class="headerlink" title="上传资源"></a>上传资源</h2><p>在登录成功之后，点击对象存储<br><img src="http://img.blog.csdn.net/20170503180639396?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="上传资源至七牛"><br>上传完图片之后，关闭上传页面，可以在图片列表的最后面有一个眼睛的icon，点击之后就会在右下角找到该图片的外链，在用md写博客的时候就可以直接加入外链就好<del>也可以对上传的源文件进行重命名，因为大部分我上传到七牛上的图片都是相册中使用的，所以我将源文件的名字都改成统一的形式，在引用的时候只需要修改最后的数字就可以</del><br><img src="http://img.blog.csdn.net/20170504121228530?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="上传资源至七牛"></p><h3 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h3><p>使用七牛图床最棒的地方在于可以对图片进行处理，我就只拿添加水印来举例。<br>七牛可以对上传的图片添加图片样式<br><img src="http://img.blog.csdn.net/20170504164007175?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="增加图片样式"><br>增加图片样式就是对图片进行处理，这里的处理方式有很多，比如缩放方式、裁剪、增加图片水印、设置输出格式。<br><img src="http://img.blog.csdn.net/20170504164411602?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="增加图片样式"><br>在设置了图片样式之后我们要怎么使用呢，开始我也是一脸懵逼的，不知道怎么使用，百度之后才知道，你直接访问获取的外链就是你上传的原图，在外链的后面加上连接符和你的样式名称访问的就是经过处理后的图片，有没有很赞<del>既可以访问到你的原图片，也可以访问到经过处理后的图片，只不过是连接不同，还可以给一个图片增加多个样式访问，就不需要我们一张一张对图片进行处理了</del>简直不能太赞~(～￣▽￣)～比如:我的原图地址是：<a href="http://oova2i5xh.bkt.clouddn.com/IMG49.jpg，可以看到是一张很大的不带水印的图片" target="_blank" rel="noopener">http://oova2i5xh.bkt.clouddn.com/IMG49.jpg，可以看到是一张很大的不带水印的图片</a><br><img src="http://img.blog.csdn.net/20170504165826626?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后在该地址后加上我设置的连接符,”-“和我的样式名称：<a href="http://oova2i5xh.bkt.clouddn.com/IMG49.jpg-cherryblogImg，就可以看到是一张带水印的小图，我进行了缩放和加水印" target="_blank" rel="noopener">http://oova2i5xh.bkt.clouddn.com/IMG49.jpg-cherryblogImg，就可以看到是一张带水印的小图，我进行了缩放和加水印</a><br><img src="http://img.blog.csdn.net/20170504170056689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo高阶教程next主题优化之加入网易云音乐、网易云跟帖、动态背景、自定义主题、统计功能</title>
      <link href="/2017/06/10/hexo-blog-part-2/"/>
      <url>/2017/06/10/hexo-blog-part-2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1493223838128&di=c9a4b5d92b7ab41789dbde3069dbaf3a&imgtype=0&src=http%3A%2F%2Fpic4.zhimg.com%2Fd4c1239e75c02e8482c22017a6c8d407_r.jpg" alt="这里写图片描述"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本文转自</strong><a href="http://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html" target="_blank" rel="noopener">Cherry’s Blog</a><br>本篇文章是在已经搭建好gitpage+hexo的博客的前提下<br>本篇博文是使用next主题的进击版本，主要是有以下内容</p><ul><li>域名绑定，将github博客和你的独有域名绑定</li><li>添加更多的menu内容</li><li>添加头像</li><li>定义网站个性logo</li><li>自定义样式，重写默认样式，个性化定制你的博客</li><li>炫酷动态背景制作</li><li>添加网易云音乐</li><li>添加网易云跟帖</li><li>添加leancloud阅读次数统计功能</li><li>添加wordcount页面字数统计</li><li>添加fork me on github功能</li><li>添加Local search</li></ul><p>要想最快的知道这些功能的效果，请移步我的个人博客：<a href="http://cherryblog.site/" target="_blank" rel="noopener">http://cherryblog.site/</a> ，顺便求个fork，大爷们看过可以评论一下，试一下新加上的网易云跟帖效果怎么样ヽ(●´ε｀●)ノ </p><a id="more"></a><p>首先要说一下我使用的版本，这个是很重要的，我的博客最先创建于2016年的9月份，距离现在已经有大半年了，所以好多版本都已经进行了更新，特别是next主题集成了更多的插件，简直不要太爽＼（＠￣∇￣＠）／</p><blockquote><p>hexo  v3.2.2<br>next  v5.1.0<br>node v4.5.0</p></blockquote><p>在改成自己想要的效果之后，对整体的hexo的next主题我有了一个大概的了解，其实next主题的最新版（5.1）已经集成了大部分我们需要的插件，只需要在主题配置文件中将默认的false改为true即可，但是我们也仍然需要知道都有哪些新的功能，最有效的方法是直接去查看官网的api：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next官网</a><img src="http://img.blog.csdn.net/20170409220356907?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><blockquote><p>授之于鱼不如授之于渔<br>希望我们都能够理解其源码，制作出属于自己专属的个性化博客(•̀ᴗ•́)</p></blockquote><p> 我们需要改的文件其实也就那么几个，大部分是不需要更改，next都已经帮我们配置好了~<br> 默认目录结构：</p><pre><code>.├── .deploy├── public├── scaffolds├── scripts├── source|   ├── _drafts|   └── _posts├── themes├── _config.yml└── package.json</code></pre><ul><li>deploy：执行hexo deploy命令部署到GitHub上的内容目录</li><li>public：执行hexo generate命令，输出的静态网页内容目录</li><li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li><li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li><li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。<ul><li>drafts：草稿文章</li><li>posts：发布文章</li></ul></li><li>themes：主题文件目录</li><li>_config.yml：全局配置文件，大多数的设置都在这里</li><li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li></ul><p>我们最先修改的应该是在hexo根目录下的配置文件<code>_config.yml</code>文件，这里是配置整个站点的配置信息，在文章的最后贴出我的配置文件，有兴趣的朋友可以参考一下~<br> 其次就是我们的主题配置文件<br> 在对应的主题下的<code>_config.yml</code> 因为我使用的是next主题，所以目录的路径为<code>C:\Hexo\themes\next\_config.yml</code> 这里配置的是使用主题的配置文件，这个配置文件的东西就有点多了，我们大部分的修改也是在这个文件下完成的。比如说使用集成的第三方插件，默认为false，我们需要将其改为true并且配置相应的app_key就可以使用该插件了~有木有很方便(^ ◕ᴥ◕ ^)<br> 然后我们需要修改样式的话是需要设置css和甚至是修改模板，<br> 页面展现的全部逻辑都在每个主题中控制，源代码在hexo\themes\你使用的主题\中，以next主题为例：</p><pre><code>├── .github            #git信息├── languages          #多语言|   ├── default.yml    #默认语言|   └── zh-Hans.yml      #简体中文|   └── zh-tw.yml      #繁体中文├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制|   ├── _custom        #可以自己修改的模板，覆盖原有模板|   |   ├── _header.swig    #头部样式|   |   ├── _sidebar.swig   #侧边栏样式|   ├── _macro        #可以自己修改的模板，覆盖原有模板|   |   ├── post.swig    #文章模板|   |   ├── reward.swig    #打赏模板|   |   ├── sidebar.swig   #侧边栏模板|   ├── _partial       #局部的布局|   |   ├── head       #头部模板|   |   ├── search     #搜索模板|   |   ├── share      #分享模板|   ├── _script        #局部的布局|   ├── _third-party   #第三方模板|   ├── _layout.swig   #主页面模板|   ├── index.swig     #主页面模板|   ├── page           #页面模板|   └── tag.swig       #tag模板├── scripts            #script源码|   ├── tags           #tags的script源码|   ├── marge.js       #页面模板├── source             #源码|   ├── css            #css源码|   |   ├── _common    #*.styl基础css|   |   ├── _custom    #*.styl局部css|   |   └── _mixins    #mixins的css|   ├── fonts          #字体|   ├── images         #图片|   ├── uploads        #添加的文件|   └── js             #javascript源代码├── _config.yml        #主题配置文件└── README.md          #用GitHub的都知道</code></pre><h1 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h1><p>绑定域名的思路如下：</p><ul><li>在万网购买自己喜欢的域名（.com的会贵一点，.site和.xyz的相对便宜一些，有的只需要几块钱一年就可以）</li><li>解析DNS</li><li>在hexo中添加CNAME文件</li></ul><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>之前没有买域名的时候我想使用网易云跟帖，发现在注册网易云跟帖的时候使用原来的域名提示“url已被使用”，这是因为网易云跟帖不认可二级域名，所以要自己买域名。<br>我选择的是<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>，阿里下面的。我选择了一个<code>.site</code>的域名，原价8元，使用阿里云app支付还优惠5元，等于3元到手一个域名（一年）~<br>按照官网的步骤一步一来就可以了~</p><h2 id="解析DNS"><a href="#解析DNS" class="headerlink" title="解析DNS"></a>解析DNS</h2><p>购买完域名之后我们需要解析DNS地址，在管理控制台中的左侧有域名选项，然后找到你的域名，点击后面的“解析”<br><img src="http://img.blog.csdn.net/20170409132041051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>  点击添加解析，记录类型选A或CNAME，</p><blockquote><p>A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，<br>解析记录设置两个www和@，线路就默认就行了，CNAME记录值填你的github博客网址。如我的是sunshine940326.github.io。</p></blockquote><h2 id="在hexo中添加CNAME文件"><a href="#在hexo中添加CNAME文件" class="headerlink" title="在hexo中添加CNAME文件"></a>在hexo中添加CNAME文件</h2><p>接下来在你的hexo文件夹下source文件夹下新建一个CANME文件,里面加上你刚刚购买的域名比如我的<code>cherryblog.site</code><br><img src="http://img.blog.csdn.net/20170409141726073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后你就可以<code>hexo clean</code>,<code>hexo g</code>，<code>hexo d</code> 发布你的博客看看效果啦~<br><img src="http://img.blog.csdn.net/20170409142438270?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><strong>在这里我出现一个问题，就是单独输入域名是可以访问的，但是前面加上www之后就访问不聊了= =了，我感觉应该是可以的，但是不行，再等几天看看效果= =</strong> </p><h1 id="添加菜单页"><a href="#添加菜单页" class="headerlink" title="添加菜单页"></a>添加菜单页</h1><p>添加菜单页的思路（添加菜单页就是添加一个页面，有两种方式）：第一种是使用git命令<code>hexo new page &quot;photo&quot;</code> 就直接创建了<code>C:\Hexo\source\photo\index.md</code>文件，然后编辑index.md 文件就可以了~<br><img src="http://img.blog.csdn.net/20170409165246422?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>第二种：手动创建上面的文件= =</p><ul><li>在主题的配置文件添加menu索引路径（根路径是hexo/source）,所以你如果想要更改页面的内容就去hexo/source下找到对应的文件夹，默认内容是在其index.md文件下</li><li>在hexo的source文件下添加对应的文件夹</li><li>在主题的配置文件添加menu_icon字段设置对应的icon</li><li>修改language文件下zh-hans语言包</li><li>在发表文章的时候添加对应的menu字段就可以看到</li></ul><p>刚开始的时候不理解怎么添加分类页和添加文章的区别，公司有一个项目用到了wordpress，然后发现两者有相似的地方，不同的就是wordpress是有可视化的操作后台，而hexo是需要git bash自己创建<strong>首先我们要分清什么是页面，什么是文章，</strong><br><strong>在hexo中menu下的内容都是新的页面</strong>我们可以通过<code>hexo new page &quot;pagename&quot;</code> 创建，hexo默认的页面只有<code>home</code>,<code>archives</code>,<code>tags</code> 三个，之后我们写的博文就是文章，通过<code>hexo new &quot;name&quot;</code> 创建的<code>name.md</code> 文件在根目录的<code>source\_posts</code> 下，在每一个文章的头部，我们可以配置其tags或者categories内容，相当于文章是页面的下一级 </p><h2 id="在配置文件中添加menu索引路径"><a href="#在配置文件中添加menu索引路径" class="headerlink" title="在配置文件中添加menu索引路径"></a>在配置文件中添加menu索引路径</h2><p>我们可以在主题配置的_config文件下找到相应的字段，字段前加<code>#</code> 表示被注释掉，我们也可以自己添加menu的内容，比如我又新增了两个menu<code>life</code> 和<code>photo</code><br><img src="http://img.blog.csdn.net/20170409143920151?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这里添加的字段其实是加上文件索引的路径，这里hexo设置的根路径是<code>hexo/source</code> 接下来我们在这个根路径下建立相应的文件夹就可以实现点击mune跳转到相应的页面上了<br><img src="http://img.blog.csdn.net/20170409151941047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">,<br>没有明白什么意思的同学看下图</p><h2 id="在source文件添加menu文件夹"><a href="#在source文件添加menu文件夹" class="headerlink" title="在source文件添加menu文件夹"></a>在source文件添加menu文件夹</h2><p>我们需要在这个路径下自己建立对应的页面，比如说我新建了menu<code>life</code> 和<code>photos</code>，然后再source文件夹下面新建两个名字为<code>life</code> 和<code>photo</code> 的文件夹，里面添加一个<code>index.md</code> markdown文件，内容是类似这样的</p><pre><code>title: photodate: 2017-04-04 22:14:07type: &quot;photo&quot;comments: false---啦啦啦~</code></pre><p><img src="http://img.blog.csdn.net/20170409152554707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这是一个markdown文件，你可以自己编写，但是我还不知道怎么把添加html文件= =，回来研究一下</p><h2 id="给menu添加icon"><a href="#给menu添加icon" class="headerlink" title="给menu添加icon"></a>给menu添加icon</h2><p>如果只是上面的步骤，那么你可能会创建出一个新的页面，但是显示的效果会是这样：<img src="http://img.blog.csdn.net/20170409153513929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>怎么icon没有换？？？其实hexo中换icon是一个很简单的事情，因为hexo集成了<code>FontAwsome</code> 所以我们只需要在主题的配置文件中加入相应的icon名字即可<br><img src="http://img.blog.csdn.net/20170409153837056?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="查找FontAwsome-icon"><a href="#查找FontAwsome-icon" class="headerlink" title="查找FontAwsome icon"></a>查找<code>FontAwsome</code> icon</h2><p> 这时候你想要换一个自己喜欢的icon怎么办，这就需要自己动手，丰衣足食了，你需要自己到<a href="http://www.bootcss.com/p/font-awesome/#" target="_blank" rel="noopener">FontAwsome官网</a>，然后鼠标往下拉，在图标集中选择自己喜欢的icon，然后记住名字，保存在上面的menu_icon字段中就可以啦~<br> <img src="http://img.blog.csdn.net/20170409154335951?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">tips ：在字段中只需要填写icon-name后面跟的name即可，不需要加上前面的”icon-“</p><h2 id="在language添加zh-hans翻译字段"><a href="#在language添加zh-hans翻译字段" class="headerlink" title="在language添加zh-hans翻译字段"></a>在language添加zh-hans翻译字段</h2><p>上面的步骤完成之后你会发现，在你的博客首页显示的仍然是英文名，而我们想要有一个中文的名字，并且想要个性化定制我们的页面，我们可以在主题的language文件下的zh-hans（中文）语言包下增加相应的字段（做过翻译的童鞋应该都知道什么意思<del>）还可以修改其他的字段，这样就可以定制我们的博客了呢</del><br> <img src="http://img.blog.csdn.net/20170409171442363?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="在发表文章的时候添加对应的menu字段"><a href="#在发表文章的时候添加对应的menu字段" class="headerlink" title="在发表文章的时候添加对应的menu字段"></a>在发表文章的时候添加对应的menu字段</h2><p>在我们写文章的时候只要在头部信息添加相应的字段就在tags页面和categories中显示相应的分类，例如:</p><pre><code>title: Git使用中的报错情况date: 2017-03-11 23:54:11tags: [git,实战经验] categories: git---</code></pre><p>tags、categories都是支持数组的形式的，可以添加多个tags、categories。这样我们在tags、categories页面就可以看见相应的分类了<br><img src="http://img.blog.csdn.net/20170409172519879?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h1><p>我使用的主题头像是位于侧边栏，显示的效果如下，<br><img src="http://img.blog.csdn.net/20170409172733268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">要添加一个这个的头像要怎么操作呢，其实思路就是将你要上传的头像放在你的文件夹中，然后再配置文件中引用正确的路径即可，当然也可以上传绝对路径。在你的主题配置文件找到avatar字段，然后将你得图片路径写在后面，我是新建了一个uploads文件夹，将图片放在下面</p><pre><code># Sidebar Avatar# in theme directory(source/images): /images/avatar.jpg# in site  directory(source/uploads): /uploads/avatar.jpgavatar: /uploads/avatar.png</code></pre><p><img src="http://img.blog.csdn.net/20170409173222538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="设置网站logo"><a href="#设置网站logo" class="headerlink" title="设置网站logo"></a>设置网站logo</h1><p>跟设置头像其实是一个思路，都是在配置文件中引入正确的地址就可以了，不过网站的logo是对图片有要求的，我们需要在<a href="http://tool.lu/favicon/" target="_blank" rel="noopener">Favicon在线制作</a>工具中制作32*32的.ico图片，然后放在source/images下面。然后在主题配置文件下添加主题配置文件中添加：<code>favicon: images/favicon.ico</code></p><h1 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h1><p>不得不说next还是很人性化的，你可以个性化定制你的网站，你所有的改动（css）需要放在主题文件的source/css/_costum/costum.styl文件中，会覆盖原来的css，所以只要你不想要你修改的样式，只需要删除这个文件夹就可以了，再也不用担心还原不回去了~<br><img src="http://img.blog.csdn.net/20170409174107213?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="炫酷动态背景"><a href="#炫酷动态背景" class="headerlink" title="炫酷动态背景"></a>炫酷动态背景</h1><blockquote><p>2017.5.8更新，具体过程往下看<strong>仿知乎动态背景</strong><br>之前做过一个类似的canvas-nest的效果。新版本的next已经支持canvas-nest了，但是效果不怎么样，就不用了，但是也介绍一下，毕竟简单，只有两步就可以了。<br>添加修改代码<code>next/layout/_layout.swig</code>在<code>&lt;/body&gt;</code>之前加上</p></blockquote><pre><code>{% if theme.canvas_nest %}<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>{% endif %}</code></pre><p>打开<code>next/_config.yml</code>，添加以下代码就可以了：</p><pre><code> # Canvas-nestcanvas_nest: true</code></pre><h1 id="添加网易云音乐"><a href="#添加网易云音乐" class="headerlink" title="添加网易云音乐"></a>添加网易云音乐</h1><p>在知道了页面的结构之后，你就可以将你的播放器添加在页面的任意位置，开始我是放在了首页，然后发现一上来就自动播放太吵了，于是就放在了侧边栏，想要听得朋友可以手动点击播放，<br>我们可以直接在网易云音乐中搜索我们想要插入的音乐，然后点击生成外链播放器<br><img src="http://img.blog.csdn.net/20170409181717791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后可以根据你得设置生成相应的html代码，将获得的html代码插入到你想要插入的位置即可<br><img src="http://img.blog.csdn.net/20170409181941920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>我放在了<code>layout/_macro/sidebar.swig</code> 文件下</p><pre><code>&lt;div id=&quot;music163player&quot;&gt;    &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=280 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66&quot;&gt;    &lt;/iframe&gt;&lt;/div&gt;</code></pre><p>然后就可以在侧边栏看见我的播放器了~<br><img src="http://img.blog.csdn.net/20170409191354574?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h1 id="网易云跟帖"><a href="#网易云跟帖" class="headerlink" title="网易云跟帖"></a>网易云跟帖</h1><p>之前用的是多说，但是多说在2017年6月1日就关闭评论服务了= =，很忧伤，于是转到了网易云跟帖。由于最新版（5.1）版本的next已经集成了网易云跟帖，所以只需要在主题的设置文件中配置你的productKey就可以了。获取productKey也很简单，在官网<a href="https://manage.gentie.163.com/" target="_blank" rel="noopener">网易云跟帖</a>中注册，然后在获取代码&gt;通用代码中拿到productKey，之后在你的主题配置文件中的gentie_productKey字段后添加即可~<br>#添加Fork me on GitHub<br>去网址<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">https://github.com/blog/273-github-ribbons</a> 挑选自己喜欢的样式，并复制代码，添加到themes\next\layout_layout.swig的body标签之内即可<br>记得把里面的url换成自己的!</p><h1 id="hexo-wordcount实现统计功能"><a href="#hexo-wordcount实现统计功能" class="headerlink" title="hexo-wordcount实现统计功能"></a>hexo-wordcount实现统计功能</h1><p><img src="http://img.blog.csdn.net/20170409212441592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>wordcount可以实现字数统计，阅读时常还有总字数的统计功能<br>只需要<code>npm install hexo-wordcount --save</code> 就可以安装wordcount插件，<br>主要功能<br>字数统计:WordCount<br>阅读时长预计:Min2Read<br>总字数统计: TotalCount<br>安装完插件之后在主题的配置文件中开启该功能就可以~</p><pre><code># Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount:  item_text: true  wordcount: true  min2read: true</code></pre><h1 id="leancloud阅读次数统计"><a href="#leancloud阅读次数统计" class="headerlink" title="leancloud阅读次数统计"></a>leancloud阅读次数统计</h1><p>next也集成了leancloud，在<a href="https://leancloud.cn/" target="_blank" rel="noopener">leancloud官网</a><br>中注册账号等一步一步的操作就不说了哈~，我们主要是为了拿到app_key和app_id,然后在主题配置文件做一下配置</p><pre><code># Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors:  enable: true  app_id: yourapp_id  app_key: yourapp_key</code></pre><p>然后再leancloud的控制台中的存储添加一个counter的class就可以检测到我们的浏览量了，同时在你文章的副标题也可以看到有阅读次数的显示<br><img src="http://img.blog.csdn.net/20170409213510970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3Vuc2hpbmU5NDAzMjY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>#Local Search<br>1.安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p><pre><code> npm install hexo-generator-searchdb --save</code></pre><p>2.编辑 站点配置文件，新增以下内容到任意位置：</p><pre><code>search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><p>3.编辑 主题配置文件，启用本地搜索功能：</p><pre><code># Local searchlocal_search:  enable: true</code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用Gitpage+hexo开发自己的博客</title>
      <link href="/2017/06/10/hexo-blog-part-1/"/>
      <url>/2017/06/10/hexo-blog-part-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1493223838128&di=c9a4b5d92b7ab41789dbde3069dbaf3a&imgtype=0&src=http%3A%2F%2Fpic4.zhimg.com%2Fd4c1239e75c02e8482c22017a6c8d407_r.jpg" alt="这里写图片描述"></p><p>最近看同事用Gitpage+hexo构架了自己的博客，心血来潮也来弄个玩玩</p><a id="more"></a><h2 id="Gitpage-hexo"><a href="#Gitpage-hexo" class="headerlink" title="Gitpage+hexo"></a>Gitpage+hexo</h2><p>想要实现拥有一个独立的私有博客，我们需要两个东西，一个是可供浏览器访问的静态网页存储空间，这个我们选择gitPage，一个是一个静态网页生成工具，Octopress也好，Hexo也罢，这里我选择的是Hexo。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="1-安装Node"><a href="#1-安装Node" class="headerlink" title="1 安装Node"></a>1 安装Node</h2><p>到Node.js官网下载相应平台的最新版本，一路安装即可。我用的是node-v0.10.22-x86.msi</p><h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2 安装Git"></a>2 安装Git</h2><p>安装git，或安装github客户端，自我感觉github客户端很好用，界面很友好，同样操作起来也比git好用的多！我用的是window10系统，在官网下载数次都未安装成功，最后在知乎上终于找到安装包，链接: <a href="http://pan.baidu.com/s/1eS2mHxS" target="_blank" rel="noopener">http://pan.baidu.com/s/1eS2mHxS</a> 密码: yatq ，有需要的同学可以点击下载。</p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1 安装Hexo"></a>1 安装Hexo</h2><p>使用git shell,依次输入以下代码命令：</p><pre><code>cd /npm install hexo-cli -g</code></pre><p>建议使用cnpm</p><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>命令解释：</p><p><strong>cd和/之间要有空格</strong>，这条指令的作用是返回根目录，也可以在cd /后加入一个文件名，例如下文要用到的cd /Hexo 就可以指向这个文件夹，再输入代码行就默认在在此文件下执行。</p><p>采坑：<br>Ubuntu16.04 安装hexo方法</p><pre><code>sudo apt install nodejs npmsudo apt install nodejs npmsudo ln -s /usr/bin/nodejs /usr/bin/nodesudo npm i -g hexo hexo-cli</code></pre><h2 id="2-安装博客所需文件"><a href="#2-安装博客所需文件" class="headerlink" title="2 安装博客所需文件"></a>2 安装博客所需文件</h2><pre><code>cd /hexo init Hexocd /Hexonpm instalhexo generate（可简写为hexo g）hexo sever（可简写为hexo s）</code></pre><p>命令解释:</p><ul><li><p>cd /这里返回的根目录取决于你在github客户端的设置，我设置的是F盘，所以返回得也是F盘，所以下面创建的Hexo文件夹也在F盘。</p></li><li><p>Hexo这个文件名可以随便命名，存放的是构建博客所要用到的所有文件。</p></li><li><p>指向Hexo目录</p></li><li><p>安装依赖文件</p></li><li><p>编译</p></li><li><p>开启本地服务(第5、6步的操作可以合并成hexo s -g)</p></li></ul><p>此时打开浏览器，在地址栏输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><h2 id="3优化"><a href="#3优化" class="headerlink" title="3优化"></a>3优化</h2><p>1，找到 /themes/landscape/layout/_partial/after-footer.ejs把</p><pre><code>&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>替换</p><pre><code>&lt;script src=&quot;http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ &gt; &lt;/script&gt;</code></pre><p>2，找到 /themes/landscape/layout/_partial/header.ejs</p><pre><code>&lt;link href=&quot;//fonts.googleapis.com/css?family=Source+Code+Pro&quot; rel=”stylesheet” type=”text/css”&gt;</code></pre><p>替换</p><pre><code>    &lt;link href=&quot;//fonts.useso.com/css?family=Source+Code+Pro&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code></pre><h2 id="4-部署博客到服务器"><a href="#4-部署博客到服务器" class="headerlink" title="4 部署博客到服务器"></a>4 部署博客到服务器</h2><p>也就是把博客部署到github page提供的服务器上。</p><p>步骤</p><ul><li>首先回到git shell按ctrl+c，之后输入y即可</li></ul><ul><li>修改Hexo文件夹下_config.yml文件，如下图所示修改，repository后的地址要改成你自己的地址：<code>deploy:  type: github  repo: https://github.com/yourname/blog.git</code></li></ul><p>继续回到git shell输入命令：</p><pre><code> hexo clean hexo g hexo s hexo d</code></pre><p>命令解释:</p><ul><li>清除public，当 source 文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。<br>编译，一般部署上去的时候都需要编译一下，编译后，会出现一个 public 文件夹，将所有的md文件编译成html文件</li><li>开启本地服务，</li><li>部署博客到github上，如果一切顺利，你就通过访问usename.github.io访问你的博客了！<br>是的，现在你拥有了自己的博客！</li></ul><h1 id="发表博文"><a href="#发表博文" class="headerlink" title="发表博文"></a>发表博文</h1><p>千辛万苦建立了博客，那么我们来学习一下如何发表博文。</p><h2 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h2><p>继续回到git shell输入：</p><p>hexo new “新博文的名字”<br>即可在 Hexo\source_posts 目录中找到”新博文的名字.md”这个文件。你就可以使用maekdown编辑器打开进行编写博客内容了。</p><p><strong>Markdown编辑器</strong></p><p>推荐两款我所使用的markdown编辑器：</p><p><strong>MIU</strong>，据说是仿mac版的mou，界面相当友好，非常喜欢，官网都下载不了，挺小众，可能我就是典型的少说派，我也是偶然间得到，在此提供下载地址：<br>链接: <a href="http://pan.baidu.com/s/1slMPeTR" target="_blank" rel="noopener">http://pan.baidu.com/s/1slMPeTR</a><br>密码: 2pnk<br><strong>正在使用的Atom:</strong>更为先进的文本代码编辑器 ,由 Github 打造的下一代编程开发神器,其中支持markdown。<br>可能会遇到的问题<br><strong>在线编辑器:</strong><a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">https://pandao.github.io/editor.md/</a></p><blockquote><p>hexo new [layout] “postName” #新建文章</p></blockquote><p>其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md</p><pre><code>title: { { title } }date: { { date } }tags:---</code></pre><p>大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。<br>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行</p><pre><code>title: { { title } }date: { { date } }categories:tags:---</code></pre><p>postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。</p><p>注意，所有文件：后面都必须有个空格，不然会报错。</p><p>看一下刚才生成的文件hexo\source_posts\postName.md</p><pre><code>title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格---</code></pre><p>始使用markdown格式输入你的正文。，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章Markdown简明语法。</p><p><strong>fancybox</strong><br>可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。<br>很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：</p><pre><code>layout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg</code></pre><p>经过测试，文件头上的layout: photo可以省略。</p><p>不想每次都手动添加怎么办？同样的，打开您的hexo\scaffolds\photo.md</p><pre><code>layout: { { layout } }title: { { title } }date: { { date } }tags:photos:----</code></pre><p>然后每次可以执行带layout的new命令生成照片文章：</p><pre><code>hexo new photo &quot;photoPostName&quot; #新建照片文章</code></pre><p>description<br>markdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。</p><pre><code>title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述---</code></pre><p>hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。</p><p><strong>文章摘要</strong><br>在需要显示摘要的地方添加如下代码即可：</p><pre><code>以上是摘要&lt;!--more--&gt;以下是余下全文</code></pre><p>more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。</p><p>hexo中所有文件的编码格式均是UTF-8。</p><h2 id="优雅的在博客上插入图片"><a href="#优雅的在博客上插入图片" class="headerlink" title="优雅的在博客上插入图片"></a>优雅的在博客上插入图片</h2><p>看到很多博客上说使用七牛，但是这种方法可能是用着最爽的，我们来看一下如何使用：</p><p>首先确认 _config.yml 中更改 post_asset_folder:true 。<br>回到git shell，输入</p><p>npm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save</p><p>继续执行</p><pre><code> hexo clean hexo g hexo s hexo d</code></pre><p>重新创建一个博客名字，然后发现Hexo\source_posts下多了一个与博客名字相同的空文件夹</p><p>然后就可以把我们博客中要用到的图片存放在这个文件夹下，需要时直接引用即可，是不是特别方便？<br>提醒：</p><p>写一篇博文时尽量只使用一种markdown编辑器，如果同时使用两个编辑器，我感觉不同编辑器对markdown语法的编译还是有一些差别的，用这个编辑器写好的格式用另一个编辑器打开却乱了！</p><h2 id="预览和发表"><a href="#预览和发表" class="headerlink" title="预览和发表"></a>预览和发表</h2><p>继续重复以下命令即可实现预览和发表，恭喜你已经在自己建设的博客网站上发表了第一篇博文！</p><pre><code>1.  hexo clean2.  hexo g3.  hexo s4.  hexo d</code></pre><p>更高大上的发表博文的方法</p><p>使用Travis CI自动部署你的Hexo博客到Github,请参考<a href="http://i.woblog.cn/2016/05/04/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0Github%E4%B8%8A/#more" target="_blank" rel="noopener">手把手教你使用Travis CI自动部署你的Hexo博客到Github上</a></p><p>使用could9在线更新博客，这样的话即使更换了电脑，也能优雅的更新博客了。详细请参考：用c9.io实现在线更新博客</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>如果你跟我一样觉得原始的博客主题很low，想更换一个高逼格的，那我们继续往下进行：</p><p>选择主题</p><p>你可以在<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">Themes·Hexo</a>上选择你喜欢的主题，我使用的Next主题</p><h2 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h2><p>参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next官方文档</a>,内容十分详尽！</p><p>安装主题的方法就是一句git命令：</p><pre><code>git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</code></pre><p>目录是否是modernist无所谓，只要与_config.yml文件一致即可。</p><p>安装完成后，打开hexo_config.yml，修改主题为modernist</p><pre><code>theme: modernist</code></pre><p>打开hexo\themes\modernist目录，编辑主题配置文件_config.yml：</p><pre><code>menu: #配置页头显示哪些菜单#  Home: /  Archives: /archives  Reading: /reading  About: /about#  Guestbook: /aboutexcerpt_link: Read More #摘要链接文字archive_yearly: false #按年存档widgets: #配置页脚显示哪些小挂件  - category#  - tag  - tagcloud  - recent_posts#  - blogrollblogrolls: #友情链接  - bruce sha&#39;s duapp wordpress: http://ibruce.duapp.com  - bruce sha&#39;s javaeye: http://buru.iteye.com  - bruce sha&#39;s oschina blog: http://my.oschina.net/buru  - bruce sha&#39;s baidu space: http://hi.baidu.com/iburufancybox: true #是否开启fancybox效果duoshuo_shortname: buru #多说账号google_analytics:rss:</code></pre><p>更新主题</p><pre><code>cd themes/modernistgit pull</code></pre><h2 id="评论框"><a href="#评论框" class="headerlink" title="评论框"></a>评论框</h2><p>静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">多说</a><br>直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以<a href="http://dev.duoshuo.com/docs/4ff1cfd0397309552c000017" target="_blank" rel="noopener">参考这里</a>，我是在HeroicYang的基础上修改的。</p><p>如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\themes\modernist\layout_partial\comment.ejs里面，如下：</p><pre><code>&lt;% if (config.disqus_shortname &amp;&amp; page.comments){ %&gt;&lt;section id=&quot;comment&quot;&gt;  #你的通用代码&lt;% } %&gt;</code></pre><h2 id="构建新页面"><a href="#构建新页面" class="headerlink" title="构建新页面"></a>构建新页面</h2><p>那些小图标都是一个新页面，需要手动创建，那么如何创建？</p><p>回到git shell，</p><p>hexo new page “页面名称”<br>比如你要创建一个about页面，就输入hexo new page “about”</p><p>正确显示各页面内容</p><p>发表博文后发现点击上面建立的页面后发现是空白页，比如，打开标签页面，发现是空白，或者提示找不到！</p><p>解决方法：以标签页为例，打开Hexo\source\tags下index.md文件，修改如下：</p><p>comments: false即关闭此页面的评论功能</p><p>type: “tags”这里的值根据你想更改的页面决定</p><p>更改过后，在重新部署到github上，你就可以点击各个页面查看，发现一切都是那么美好！</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>hexo支持的插件：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">Plugins | Hexo</a><br>想安装什么插件，按照相关README.md中介绍操作即可。</p><p>安装多说评论、不蒜子（或LeanCloud）和分享插件，参考:<a href="http://theme-next.iissnan.com/third-party-services.html#swfitype" target="_blank" rel="noopener">第三方服务集成</a>，介绍非常全面！好好用来装饰你的博客吧！</p><p>安装sitemap和feed插件时，如果遇到问题，可以参考:<a href="http://www.imys.net/20150513/wordpress-to-hexo.html#%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AFRSS%E5%92%8Csitemap" target="_blank" rel="noopener">博客搬迁记 - 从WordPress到Hexo</a>，安装sitemap后要到<a href="http://zhanzhang.baidu.com/?castk=LTE=" target="_blank" rel="noopener">百度站长</a>提交你的网站，首先要添加站点，然后在链接提交你的sitemap.xml，详细操作参考:<a href="http://www.gfwsb.com/2016/use-sitemap-for-hexo/" target="_blank" rel="noopener">为Hexo博客生成sitemap</a></p><p>安装swiftype插件，如果遇到问题，可以参考<a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html" target="_blank" rel="noopener">利用swiftype为hexo添加站内搜索</a></p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。</p><p>免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里<a href="https://support.qiniu.com/hc/" target="_blank" rel="noopener">关于key-value存储系统</a>。</p><p>七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇<a href="https://linux.cn/article-2311-1.html" target="_blank" rel="noopener">Linux中国采用七牛云存储支撑图片访问</a>。</p><p>如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。</p><p>如果你对七牛web版的文件管理界面不满意，可以用官方的<a href="http://docs.qiniu.com/tools/v6/index.html" target="_blank" rel="noopener">七牛云存储工具</a>。</p><p>您还可以使用如下图床服务 FarBox，Dropbox，又拍云<br>主题优化</p><hr><p>Next主题很美观，个人也非常喜欢，但是一点令我们烦恼的就是主题加载的特别缓慢，那怎么优化呢？请参考一下两篇博文，作者已经总结的非常详细了，有需要的可以拜读一下，受益匪浅！</p><p><a href="http://www.gfwsb.com/2016/improveNexTspeed/" target="_blank" rel="noopener">提升Hexo的NexT主题加载速度</a></p><p><a href="http://www.5941740.cn/2016/02/19/%E4%BD%BF%E7%94%A8gulp%E7%B2%BE%E7%AE%80hexo%E5%8D%9A%E5%AE%A2%E4%BB%A3%E7%A0%81/" target="_blank" rel="noopener">使用gulp精简hexo博客代码</a></p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>1.购买域名，我是在<a href="https://account.aliyun.com/login/login.htm?oauth_callback=http://netcn.console.aliyun.com/core/domain/tclist" target="_blank" rel="noopener">万网</a>购买的，可以申请到国际域名，免去了备案的繁杂过程，我居然申请了两个，由于自学前端，所以就构建了一个网站来展示自己写的一些demo，【至于如何快速的构建一个网站，从购买域名，云空间到上传文件，你可以试一下这个<a href="http://www.xiaoerguo.com/" target="_blank" rel="noopener">网站</a>,但是现在可以用github page做服务器，也可以构建多个项目主页来展现demo，是我马上要研究的方向，自己上传云服务器感觉步骤好繁琐，看一下在github建立项目主页能否得到改善！】还一个正好闲置着，所以就拿来解析到github page上，以后就可以通过自己的域名访问自己的博客了！</p><p>2.推荐免费域<a href="http://www.freenom.com/zh/freeandpaiddomains.html" target="_blank" rel="noopener">freenom</a>使用1年</p><p>如何操作：在 Hexo\source 文件夹里新建一个名为 CNAME 的文件，用文本编辑器打开，添加内容 yourwebsite.com （你的个人域名 ）。保存后，部署你的博客即可。如果这步遇到问题，也可手动在万网上解析，github page提供的IP：</p><p>192.30.252.153</p><p>192.30.252.154</p><h2 id="制作ICO图标"><a href="#制作ICO图标" class="headerlink" title="制作ICO图标"></a>制作ICO图标</h2><p>favicon.ico一般用于作为缩略图的网站标志，<a href="http://www.bitbug.net/" target="_blank" rel="noopener">在线制作网站</a><br>关于是否绑定域名</p><p>经过这几天的试用，关于是否绑定域名，发表一下自己的看法，如果你仅仅是使用个人主页来托管个人博客。绑定与否看你自己的想法，如果你还想使用github的项目主页来展示平时写的一些小练习demo，那我劝你不要绑定个人域名了，关于如何使用github的项目主页，请参考<a href="http://chitanda.me/2015/11/03/multiple-git-pages-in-one-github-account/" target="_blank" rel="noopener">单个GitHub帐号下添加多个GitHub Pages的相关问题</a>,这样你就可以直接在需要展示的项目下添加gh-pages分支，然后通过访问“用户名。github.io/项目名/*.html”来查看页面展示效果了。这多方便，不用自己在上传云空间了，省去了一堆麻烦事！</p><p>#至此，基本操作介绍完毕，以下内容普通用户无需了解。<br>默认目录结构：</p><pre><code>.├── .deploy├── public├── scaffolds├── scripts├── source|   ├── _drafts|   └── _posts├── themes├── _config.yml└── package.json</code></pre><ul><li>deploy：执行hexo deploy命令部署到GitHub上的内容目录</li><li>public：执行hexo generate命令，输出的静态网页内容目录</li><li>scaffolds：layout模板文件目录，其中的md文件可以添加编辑</li><li>scripts：扩展脚本目录，这里可以自定义一些javascript脚本</li><li>source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。<ul><li>drafts：草稿文章</li><li>posts：发布文章</li></ul></li><li>themes：主题文件目录</li><li>_config.yml：全局配置文件，大多数的设置都在这里</li><li>package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮</li></ul><p>接下来是重头戏_config.yml，做个简单说明：</p><pre><code># Hexo Configuration## Docs: http://zespia.tw/hexo/docs/configure.html## Source: https://github.com/tommy351/hexo/# Site #整站的基本信息title: 不如 #网站标题subtitle: 码农，程序猿，未来的昏析师 #网站副标题description: bruce sha&#39;s blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到author: bruce #网站作者，在下方显示email: bu.ru@qq.com #联系邮箱language: zh-CN #语言# URL #域名和文件结构## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://ibruce.info #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code# Writing #写文章选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认layout方式auto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsehighlight: #代码高亮  enable: true #是否启用  line_number: false #是否显示行号  tab_replace:# Category &amp; Tag #分类与标签default_category: uncategorized # defaultcategory_map:tag_map:# Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server #本地服务参数## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: truelogger_format:# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination #分页设置## Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page# Disqus #社会化评论disqus，我使用多说，在主题中配置disqus_shortname:# Extensions #插件，暂时未安装插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themes## 主题theme: modernist # raytaylorism # pacman # modernist # lightexclude_generator:# Deployment #部署## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy:  type: github  repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库</code></pre><h2 id="修改局部页面"><a href="#修改局部页面" class="headerlink" title="修改局部页面"></a>修改局部页面</h2><p>页面展现的全部逻辑都在每个主题中控制，源代码在hexo\themes\你使用的主题\中，以modernist主题为例：</p><pre><code>.├── languages          #多语言|   ├── default.yml    #默认语言|   └── zh-CN.yml      #中文语言├── layout             #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制|   ├── _partial       #局部的布局，此目录下的*.ejs是对头尾等局部的控制|   └── _widget        #小挂件的布局，页面下方小挂件的控制├── source             #源码|   ├── css            #css源码|   |   ├── _base      #*.styl基础css|   |   ├── _partial   #*.styl局部css|   |   ├── fonts      #字体|   |   ├── images     #图片|   |   └── style.styl #*.styl引入需要的css源码|   ├── fancybox       #fancybox效果源码|   └── js             #javascript源代码├── _config.yml        #主题配置文件└── README.md          #用GitHub的都知道</code></pre><p>如果你需要修改头部，直接修改hexo\themes\modernist\layout_partial\header.ejs，比如头上加个搜索框：</p><pre><code>&lt;div&gt;&lt;form class=&quot;search&quot; action=&quot;//google.com/search&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;q&quot; id=&quot;search&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; maxlength=&quot;20&quot; placeholder=&quot;Search&quot; /&gt; &lt;input type=&quot;hidden&quot; name=&quot;q&quot; value=&quot;site:&lt;%- config.url.replace(/^https?:\/\//, &#39;&#39;) %&gt;&quot;&gt;&lt;/form&gt;&lt;/div&gt;</code></pre><p>将如上代码加入即可，您需要修改css以便这个搜索框比较美观。</p><p>再如，你要修改页脚版权信息，直接编辑hexo\themes\modernist\layout_partial\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。</p><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>页面上显示访问次数可以使用 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>，两行代码即可搞定。</p><p>因Google Analytics偶尔被墙，故用百度统计，以modernist主题为例，介绍如何添加。<br>编辑文件hexo\themes\modernist_config.yml，增加配置选项：</p><pre><code>baidu_tongji: true</code></pre><p>新建文件hexo\themes\modernist\layout_partial\baidu_tongji.ejs，内容如下：</p><pre><code>&lt;% if (theme.baidu_tongji){ %&gt;&lt;script type=&quot;text/javascript&quot;&gt;#你的百度统计代码&lt;/script&gt;&lt;% } %&gt;</code></pre><p>注册并登录百度统计获取你的统计代码。</p><p>编辑文件hexo\themes\modernist\layout_partial\head.ejs，在『/head』之前增加：</p><pre><code>&lt;%- partial(&#39;baidu_tongji&#39;) %&gt;</code></pre><p>重新生成并部署你的站点。</p><p>不出意外的话，在你的站点的每个页面的左上角都会看到一个恶心的百度LOGO。你只能在『百度统计首页-&gt;网站列表-&gt;获取代码-&gt;系统管理设置-&gt;统计图标设置-&gt;显示图标』，把那个勾去掉。百度真是恶心，我准备还是用Google Analytics。</p><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><p>我没有添加分享，觉得这个不是很必要，导致页面看起来啰嗦。以加网为例介绍如何添加：</p><ul><li>在hexo\themes\modernist\layout_partial\post下新建jiathis.ejs文件。<br>注册加网获得你的分享代码，写入jiathis.ejs。</li><li>在hexo\themes\modernist\layout_partial\article.ejs中，添加&lt;%-partial(‘post/jiathis’)%&gt;。</li><li>分享服务还可以使用如下企业提供的技术<a href="http://www.jiathis.com/" target="_blank" rel="noopener">加网</a>，<a href="http://www.bshare.cn/" target="_blank" rel="noopener">bShare</a>，<a href="http://share.baidu.com/" target="_blank" rel="noopener">百度分享</a>。</li></ul><p>网站图标</p><p>看一下hexo\themes\modernist\layout_partial\head.ejs，找到这句：</p><pre><code>&lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;&lt;%- config.root %&gt;favicon.ico&quot;&gt;</code></pre><p>你懂的，将你的favicon.ico放到工程根目录下即可，也就是hexo\source目录。可以<a href="http://www.faviconer.com/" target="_blank" rel="noopener">在Faviconer</a>制作你的ico图标，国内有<a href="http://www.bitbug.net/" target="_blank" rel="noopener">比特虫</a>。</p><h2 id="自定义挂件"><a href="#自定义挂件" class="headerlink" title="自定义挂件"></a>自定义挂件</h2><p>除了默认已提供的挂件外，你还可以自定义自己的小挂件，在hexo\themes\modernist\layout_widget\下，新建自己的ejs文件，如myWidget.ejs，然后在配置文件hexo\themes\modernist_config.yml中配置。</p><pre><code>widgets:  - myWidget</code></pre><p>用上述方法可以添加新浪微博小挂件。</p><ul><li>生成自己的微博组件。</li><li>添加hexo\themes\modernist\layout_widget\weibo.ejs文件。</li><li>配置hexo\themes\modernist_config.yml。<br>插件</li><li>-</li></ul><p>安装插件：</p><pre><code>npm install &lt;plugin-name&gt; --save</code></pre><p>启用插件：在*hexo_config.yml文件添加：</p><pre><code>plugins:- &lt;plugin-name&gt;  #插件名</code></pre><p>升级插件：</p><pre><code>npm update</code></pre><p>卸载插件：</p><pre><code>npm uninstall &lt;plugin-name&gt;</code></pre><p>RSS插件<br>将上述命令中的『plugin-name』，替换为hexo-generator-feed。一旦安装完成，你可以在配置显示你站点的RSS，文件路径\atom.xml。</p><p>你可以用rss作为迁移工具，用如下命令读取其他位置的rss：</p><pre><code>hexo migrate rss &lt;source&gt;</code></pre><p>『source』是本地或网络文件路径。</p><p>Sitemap插件<br>将上述命令中的『plugin-name』，替换为hexo-generator-sitemap。你可以将你站点地图提交给搜索引擎，文件路径\sitemap.xml。</p><p>更多插件的安装方法，请参考<a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="noopener">官方Wiki</a>。</p><p>如果你按照上述步骤做，但插件不起作用，没有生成atom.xml和sitemap.xml，也没有报错，那么你应该cd到你的hexo初始化目录，在该目录下重新安装插件，重试。</p><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>hexo支持从其他类型站点迁移，如通用RSS，Jekyll，Octopress，WordPress等，这一部分我没试过。请参考官方文档Hexo Migration。</p><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p>你可以到<a href="http://www.sousuoyinqingtijiao.com/" target="_blank" rel="noopener">屈站长</a>提交你的站点给搜索引擎。其他内容如添加站点或页面的description，提交Sitemap，添加百度统计，Google Analytics等等，参考本文其他章节的内容，不再一一阐述。</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新hexo：</p><pre><code>npm update -g hexo</code></pre><p>更新主题：</p><pre><code>cd themes/你的主题git pull</code></pre><p>更新插件：</p><pre><code>npm update</code></pre><p>干掉IE</p><p>Kill IE6 提示的javascript代码，请自行搜索。</p><h2 id="换机器"><a href="#换机器" class="headerlink" title="换机器"></a>换机器</h2><p>你要保留好自己的博客源码。换机器写博客，就只能使用各种网盘的同步功能，或者你把你的站点源文件提交到某代码托管服务器。另外，貌似这篇很牛逼，Hexo 服务器端布署及 Dropbox 同步。</p><p>我的办法是这样的，先在一个目录下做好Node+Git+Hexo的绿色环境，写个hexos.bat可以一键启动hexo工作台，把整个目录用Dropbox同步，这样随便在办公室或家的任何笔记本台式机都可以写博客，也不用处理什么文件拷贝备份的事情，非常爽。</p><h2 id="统计功能"><a href="#统计功能" class="headerlink" title="统计功能"></a>统计功能</h2><p>为hexo博客添加访问次数统计功能</p><p>其它</p><p>网站加速</p><p><a href="http://www.webluker.com/" target="_blank" rel="noopener">Webluker-CDN 网站加速 免费CDN DNS解析</a></p><p>Webluker-FAQ索引</p><p>网站监控</p><p><a href="http://www.jiankongbao.com/" target="_blank" rel="noopener">监控宝-网站监控 网页监控 服务器监控</a></p><p><a href="http://www.jiankongbao.com/faq" target="_blank" rel="noopener">监控宝-常见问题</a></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><p><a href="http://blog.netpi.me/%E5%AE%9E%E7%94%A8/hexo/" target="_blank" rel="noopener">hexo + github + 多说 来搭建免费博客</a></p></li><li><p><a href="http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html" target="_blank" rel="noopener">利用swiftype为hexo添加站内搜索</a></p></li><li><p><a href="http://www.tuicool.com/articles/umEBVfI" target="_blank" rel="noopener">在 hexo中无痛使用本地图片</a></p></li><li><p><a href="http://i.woblog.cn/2016/05/04/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8Travis%20CI%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0Github%E4%B8%8A/#more" target="_blank" rel="noopener">手把手教你使用Travis CI自动部署你的Hexo博客到Github上</a></p></li><li><p><a href="http://www.gfwsb.com/2016/use-sitemap-for-hexo/" target="_blank" rel="noopener">为Hexo博客生成sitemap</a></p></li></ul><ul><li><p><a href="http://www.5941740.cn/2016/02/19/%E4%BD%BF%E7%94%A8gulp%E7%B2%BE%E7%AE%80hexo%E5%8D%9A%E5%AE%A2%E4%BB%A3%E7%A0%81/" target="_blank" rel="noopener">使用gulp精简hexo博客代码</a></p></li><li><p><a href="http://chitanda.me/2015/11/03/multiple-git-pages-in-one-github-account/" target="_blank" rel="noopener">单个GitHub帐号下添加多个GitHub Pages的相关问题</a></p></li><li><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="noopener">hexo你的博客</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
